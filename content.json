{"meta":{"title":"Ainevsia's Blog","subtitle":"Coding without learning ends in danger.","description":"Personal Blog","author":"Ainevsia","url":"https://ainevsia.github.io"},"pages":[{"title":"categories","date":"2018-08-15T12:21:57.000Z","updated":"2018-08-15T12:22:40.265Z","comments":true,"path":"categories/index.html","permalink":"https://ainevsia.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-15T12:20:23.000Z","updated":"2018-08-15T12:21:32.967Z","comments":true,"path":"tags/index.html","permalink":"https://ainevsia.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-17T05:56:43.000Z","updated":"2018-10-17T06:03:42.841Z","comments":true,"path":"about/index.html","permalink":"https://ainevsia.github.io/about/index.html","excerpt":"","text":"EducationCurrently studying in Shanghai JiaoTong University for a bachelor’s degree, majoring in Cyber Security. PersonalityDoll and stale hobbiesNetEast Music Contact meYou can visit my GitHub page at the left corner of the page."}],"posts":[{"title":"07-图5 Saving James Bond - Hard Version","slug":"07-图5 Saving James Bond - Hard Version","date":"2018-10-17T13:43:08.000Z","updated":"2018-10-17T13:56:52.750Z","comments":true,"path":"2018/10/17/07-图5 Saving James Bond - Hard Version/","link":"","permalink":"https://ainevsia.github.io/2018/10/17/07-图5 Saving James Bond - Hard Version/","excerpt":"","text":"LinksHere ThoughtsHow to use the function qsort() parameters: qsort(void * array, int numberofcells, int sizeofeachcell, function cmp) function cmp: cmp(const void * a, const void * b) &#123;12 return ((*pointer* to the type of the elements waiting to be sorted)a)-&gt;some attribute of the element - ...b;&#125; It is certainly a great habbit to write comments while writing the codesTalk is cheap, show me your Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define max 102const int radius = 50;int maxtime = max;struct node &#123; //crocodile -- node int x, y; //position label x and y bool flag; //true if the crocodile is close enough to the beach node * precedent; //pointer to the previous crocodile double distance; //distance to the previous crocodile int nodetime; //attribute that trace the distance from island&#125;;struct Stack &#123; //stack to implement the closest way node * stack[max * 2]; int sp; node * Pop()&#123;return stack[sp--];&#125; void Push(node * ptr)&#123;stack[++sp] = ptr;&#125;&#125;;node croco[max]; //all the crocodiles are kept in this arrayStack priostack; //priority stacknode * FinalNode = NULL;//keep the exitusing namespace std;double getdis(int x1, int y1, int x2, int y2);void dfs(node * ptr, int n, int d, node * pre, int times);int cmp(const void * a, const void * b);int main(int argc, char const *argv[]) &#123; freopen(\"../test.txt\", \"r\", stdin); int n, d;cin &gt;&gt; n &gt;&gt; d; priostack.sp = -1; for (int i = 0; i &lt; n; ++i) &#123; //inialization cin &gt;&gt; croco[i].x &gt;&gt; croco[i].y; croco[i].flag = radius - abs(croco[i].x) &lt;= d || radius - abs(croco[i].y) &lt;= d; croco[i].precedent = NULL; croco[i].distance = 0; croco[i].nodetime = max; &#125; //first iteration for (int i = 0; i &lt; n; ++i) &#123; if (getdis(0,0,croco[i].x,croco[i].y)&lt;=7.5+d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; if (priostack.sp+1 &gt; 1) qsort(&amp;priostack.stack[0], priostack.sp+1, sizeof(node*), cmp); int cnt = 0, num = priostack.sp + 1; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,NULL,1); //out put section if (maxtime == max) cout &lt;&lt; 0; else if (d &gt;= 43) cout &lt;&lt; 1; else &#123; int outputcnt = 0; while (FinalNode) &#123; outputcnt++; priostack.Push(FinalNode); FinalNode = FinalNode-&gt;precedent; &#125; cout &lt;&lt; outputcnt + 1 &lt;&lt; endl; while (outputcnt--) &#123; FinalNode = priostack.Pop(); cout &lt;&lt; FinalNode-&gt;x &lt;&lt; ' ' &lt;&lt; FinalNode-&gt;y &lt;&lt; endl; &#125; &#125; return 0;&#125;void dfs(node * ptr, int n, int d, node * pre, int times) &#123; ptr-&gt;precedent = pre; if (ptr-&gt;flag &amp;&amp; times &lt; maxtime) &#123; maxtime = times; FinalNode = ptr; &#125; ptr-&gt;nodetime = times; int bp = priostack.sp; for (int i = 0; i &lt; n; ++i) &#123; if (croco[i].nodetime&gt;times+1 &amp;&amp; getdis(ptr-&gt;x,ptr-&gt;y,croco[i].x,croco[i].y)&lt;=d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; int num = priostack.sp - bp; if (num &gt; 1) qsort(&amp;priostack.stack[bp+1], (size_t)priostack.sp-bp, sizeof(node*), cmp); int cnt = 0; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,ptr,times+1);&#125;int cmp(const void * a, const void * b) &#123; double d = (*((node**)b))-&gt;distance - (*((node**)a))-&gt;distance; return d &gt; 0 ? 1 : -1;&#125;double getdis(int x1, int y1, int x2, int y2) &#123; double ret = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); return ret;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ainevsia.github.io/categories/数据结构与算法/"}],"tags":[{"name":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","slug":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","permalink":"https://ainevsia.github.io/tags/中国大学MOOC-陈越、何钦铭-数据结构-2018秋/"}]},{"title":"A Woman decays like this","slug":"Woman","date":"2018-10-12T10:10:46.000Z","updated":"2018-10-12T11:26:32.045Z","comments":true,"path":"2018/10/12/Woman/","link":"","permalink":"https://ainevsia.github.io/2018/10/12/Woman/","excerpt":"","text":"一个女人是这样衰老的1When I was twenty, walked around the campus in a vested denim skirt, my face flushed as my mouth open. Now I am thirty, sitting in my office and scolding my subordinates, crulty written on my face, “How can you dare to ask such a silly question before even making a draft?” 二十岁的时候，我穿着一条背心式牛仔裙在校园里走来走去，一说话就脸红。 三十岁的我穿着名牌套装，坐在办公桌前，满脸冷酷地对下属说：“这么愚蠢的问题你也敢问？也不先打个草稿。” 2When I was twenty, the books borrowed from the library were The Complete Works of Shakespeare, Self-portrait of a young artist and Ulysses. Now I am in my thirties, on the bedside table lays The scrects of following the banker, ELLE and A manager’s personal charm. 二十岁的时候，从图书馆借的是《莎士比亚全集》、《一个青年艺术家的自画像》和《尤里西斯》。 三十岁之后，床头摆的是《跟庄密笈》、《ELLE》和《经理人的个人魅力》. 3In the summer of my twenty, met the boy I crushed who was said to be admitted to a graduate school. Dismayed by the progress he had made, my heart torn with grief and my tears droped as it occured to me that it was beyond my whole life to become elegent enough so that he could gave me a glance. After thirty, searching everywhere for a bought MBA. 二十岁的暑假，在家乡的大街上偶遇自己的暗恋对象，听说他考上了研究生，被他的进步所打击，心如刀绞，想到这辈子终于不能出色得让他看我一眼，不禁怅然泪下。 三十岁之后，到处打听那里可以花钱买个MBA. 4In my twenty, indicating my age from time to time, even before they asked. After thirty, find it an odious thing when asked about age. If you do, “have a guess”. 二十岁的时候，随时随地向人透露我的年龄，答得比问的还快。 三十岁之后，最恨别人问年龄，你要是非问不可，你猜啊。 5In my twenty, overwhelmed with the idea to date with boys majoring in sports or arts. After thirty, regard myself then as an idiot. 二十岁的时候，一心想和体育系、美术系的男生约会。 三十岁后，我简直认为自己当年是白痴。 6In my twenty, saw a bookstore and went in, have books there and bought. After thirty, turn a blind eye to bookstores and directly went into the Beauty Salon next door. 二十岁的时候，有书店必须逛，有书必买。 三十岁之后，对书店视而不见，直接去了隔壁的美容院。 7In my twenty, bet on myself that I wasn’t as outdated as defending this place till dead. Live elsewhere. After thirty, run out of my legs for a house in this city that I satisfied and can afford. 二十岁的时候，打赌说我这辈子不可能土到死守在一个地方，生活在别处嘛。 三十岁之后，我为了在这座城市买个满意又便宜的房子跑断了双腿. 8In my twenty, went to a movie with someone at night. Hand in hand without conscious which made me happy for a whole summer. After thirty, sitting in the revolving restaurant of Shangri-La Hotel to accompany clients and eat self help meals. As the restaurant rotates slowly, I feels an unknow inanity and suddenly grows boring toward the whole world. 二十岁的时候，和某个人晚上一起去看了场电影，不经意中拉了一次手，结果幸福了整整一个夏天。 三十岁之后，坐在香格里拉酒店的旋转餐厅陪客户吃自主助餐，在缓缓的转动之中，莫名其妙地一阵空虚，突然间对一切感到索然无味 Acknowledgement 周可, my handsome roommate who inspired me to translate this passage that moved me so much.","categories":[{"name":"translation","slug":"translation","permalink":"https://ainevsia.github.io/categories/translation/"}],"tags":[{"name":"SJTU","slug":"SJTU","permalink":"https://ainevsia.github.io/tags/SJTU/"}]},{"title":"scholarship","slug":"scholarship","date":"2018-09-25T14:27:16.000Z","updated":"2018-11-10T13:38:53.692Z","comments":true,"path":"2018/09/25/scholarship/","link":"","permalink":"https://ainevsia.github.io/2018/09/25/scholarship/","excerpt":"","text":"奖学金每当自己要填各种申请表格的时候，我总会发现自己一无是处。 两面性今天的铣工做的是还算不是很爆炸，但是晚上情绪就很低落，大物和概统的作业都做的很难受。 不敢相信他们了不想看着自己每况愈下，成绩渐渐开始走下坡路。 所以说我为什么不喜欢在qq上问别人问题我讨厌等别人回答我迫切需要解答的问题 想要自己弄明白一切的东西，想要知道这一切背后所隐藏的奥秘，想要从一开始就有一个好的基础。 所以上课好好听可以嘛？","categories":[],"tags":[{"name":"SJTU","slug":"SJTU","permalink":"https://ainevsia.github.io/tags/SJTU/"}]},{"title":"7-11 关键活动","slug":"7-11 关键活动","date":"2018-09-19T09:18:49.000Z","updated":"2018-09-21T09:40:00.767Z","comments":true,"path":"2018/09/19/7-11 关键活动/","link":"","permalink":"https://ainevsia.github.io/2018/09/19/7-11 关键活动/","excerpt":"","text":"进展 题目是什么意思啊？我一开始以为是最小生成树，后来觉得是dijkstra,现在我已经弄不清楚了。 有向图 需要判断是不是有回路 好吧，似乎是拓扑排序…. 预备知识 AOV网络(Activity on Vertex) Top拓扑序:若v-&gt;w 则v先输出 拓扑排序：AOV若有合理的拓扑序(无环)，则必定是有向无环图(DAG, Directed Acyclic Graph) 关键路径问题：AOE网络(Activity on Edge) 题目描述原题在这 思路难点体会与感想 好累啊，好想哭啊 刷OJ最难受的事情就是要求太多的输出格式 一道题卡了两天的感受实在是太难受了 学习的过程绝对的连续的 一旦你停止在一件事情上花时间，他马上就会给你颜色看关键代码 7-11.cpp","categories":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/categories/数据结构与算法题目集（中文）/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"https://ainevsia.github.io/tags/最小生成树/"}]},{"title":"02-线性结构1 两个有序链表序列的合并","slug":"02-线性结构1 两个有序链表序列的合并","date":"2018-09-14T11:33:58.000Z","updated":"2018-09-14T11:36:09.448Z","comments":true,"path":"2018/09/14/02-线性结构1 两个有序链表序列的合并/","link":"","permalink":"https://ainevsia.github.io/2018/09/14/02-线性结构1 两个有序链表序列的合并/","excerpt":"","text":"感想 写程序题实在是太麻烦了 好久没用malloc了，连头指针和头结点都分不清楚了。 使用头结点可以很方便地解决很多的问题 源代码123456789101112131415161718192021222324252627282930List Merge( List L1, List L2 )&#123; List head = (List)malloc(sizeof(struct Node)); PtrToNode current = head; PtrToNode ptr1 = L1-&gt;Next; PtrToNode ptr2 = L2-&gt;Next; while (1) &#123; if (!ptr1) &#123; current-&gt;Next = ptr2; break; &#125; if (!ptr2) &#123; current-&gt;Next = ptr1; break; &#125; if (ptr1-&gt;Data &lt; ptr2-&gt;Data) &#123; current-&gt;Next = ptr1; current = ptr1; ptr1 = ptr1-&gt;Next; &#125;else&#123; current-&gt;Next = ptr2; current = ptr2; ptr2 = ptr2-&gt;Next; &#125; &#125; L1-&gt;Next = NULL; L2-&gt;Next = NULL; return head;&#125; 顺便把二分查找的代码也贴上来12345678910111213Position BinarySearch( List L, ElementType X )&#123; int start = 1, end = L-&gt;Last, mid; while (start&lt;=end) &#123; mid = (start + end) / 2; if (L-&gt;Data[mid]&lt;X) &#123; start = mid + 1; &#125;else if (L-&gt;Data[mid]&gt;X) &#123; end = mid - 1; &#125;else if (L-&gt;Data[mid]==X) return mid; &#125; return NotFound;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ainevsia.github.io/categories/数据结构与算法/"}],"tags":[{"name":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","slug":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","permalink":"https://ainevsia.github.io/tags/中国大学MOOC-陈越、何钦铭-数据结构-2018秋/"}]},{"title":"03-树2 List Leaves","slug":"03-树2 List Leaves","date":"2018-09-14T08:57:28.000Z","updated":"2018-09-14T09:26:45.013Z","comments":true,"path":"2018/09/14/03-树2 List Leaves/","link":"","permalink":"https://ainevsia.github.io/2018/09/14/03-树2 List Leaves/","excerpt":"","text":"thoughts 重要的细节，也是全部写完之后发现的唯一一个错误：char的数字向int装换的时候要-‘0’； 实现细节，就是给每一个节点一个完全二叉树时的序号，然后sort qsort的具体使用细节 参数表：qsort(void *, num, sizeof(), cmp) cmp的参数：int cmp(const void front, const void rear)，不可以自己改 return的参数：返回正数就是说 cmp 传入参数第一个要放在第二个后面, 负数就是传入参数第一个要放第二个前面, 如果是 0, 那就无所谓谁前谁后. ‘’+’’ 需要swap ‘’-‘’ 不要交换 int cmp(const void small, const void big) return small - big 从小到大 codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;struct node &#123; int data; bool leaf; unsigned int pos; char left; char right;&#125;;int readtree(node * tree, int n, int * num);void attachweight(node * tree, int ptr, int weight);void printleaf(node * tree, int n);int cmp(const void * front, const void * rear);int main(int argc, char const *argv[]) &#123; freopen(\"D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt\", \"r\", stdin); int n;cin &gt;&gt; n; node * tree = new node [n]; int leafnum = 0; int head = readtree(tree,n,&amp;leafnum); //cout &lt;&lt; head; attachweight(tree,head,1); //cout &lt;&lt; \"attach done\"; qsort(tree,n,sizeof(node),cmp); //cout &lt;&lt; \"sorted\"; printleaf(tree,leafnum); delete [] tree; return 0;&#125;void printleaf(node * tree, int n) &#123; int cnt = 0; for (int i = 0; true; i++) &#123; if (tree[i].leaf) &#123; cout &lt;&lt; tree[i].data; ++cnt; if (cnt!=n) &#123; cout &lt;&lt; ' '; &#125;else return; &#125; &#125;&#125;int cmp(const void * front, const void * rear) &#123; int ret = ((node*)front)-&gt;pos - ((node*)rear)-&gt;pos; return ret;&#125;void attachweight(node * tree, int ptr, int weight) &#123; tree[ptr].pos = weight; if (tree[ptr].left!='-') &#123; attachweight(tree,tree[ptr].left-'0',2*weight); &#125; if (tree[ptr].right!='-') &#123; attachweight(tree,tree[ptr].right-'0',2*weight+1); &#125;&#125;int readtree(node * tree, int n, int * num) &#123; bool * ishead = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; ishead[i] = true; &#125; for (int i = 0; i &lt; n; i++) &#123; tree[i].data = i; tree[i].leaf = true; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; if (tree[i].left!='-') &#123; tree[i].leaf = false; ishead[tree[i].left-'0'] = false; &#125; if (tree[i].right!='-') &#123; tree[i].leaf = false; ishead[tree[i].right-'0'] = false; &#125; if (tree[i].leaf) &#123; (*num)++; &#125; &#125; int head = 0; for (int i = 0; i &lt; n; i++) &#123; if (ishead[i]==true) &#123; head = i; break; &#125; &#125; delete [] ishead; return head;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ainevsia.github.io/categories/数据结构与算法/"}],"tags":[{"name":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","slug":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","permalink":"https://ainevsia.github.io/tags/中国大学MOOC-陈越、何钦铭-数据结构-2018秋/"}]},{"title":"02-线性结构4 Pop Sequence","slug":"02-线性结构4 Pop Sequence","date":"2018-09-14T04:11:54.000Z","updated":"2018-09-14T07:39:27.731Z","comments":true,"path":"2018/09/14/02-线性结构4 Pop Sequence/","link":"","permalink":"https://ainevsia.github.io/2018/09/14/02-线性结构4 Pop Sequence/","excerpt":"","text":"thoughts too simple: just stack simulation 这一次真的是爽啊，一次性过，代码简洁没有任何冗余的边界调试 这样的题目是可遇而不可求啊！ 我用树和用图也要达到我用堆的这样的境界！ codes12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;bool check(int m, int n);int main(int argc, char const *argv[]) &#123; int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; bool valid = check(m,n); if (valid) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return 0;&#125;bool check(int m, int n) &#123; int * stack = new int [n], stk = -1; int * store = new int [n], str = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; store[i]; &#125; bool valid = false; for (int topush = 1; topush &lt;= n; topush++) &#123; stack[++stk] = topush; if (stk==m) break; while (stk!=-1 &amp;&amp; store[str]==stack[stk]) &#123; stk--;str++; &#125; &#125; if (stk==-1) valid = true; delete [] stack; return valid;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ainevsia.github.io/categories/数据结构与算法/"}],"tags":[{"name":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","slug":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","permalink":"https://ainevsia.github.io/tags/中国大学MOOC-陈越、何钦铭-数据结构-2018秋/"}]},{"title":"01-复杂度2 Maximum Subsequence Sum","slug":"01-复杂度2 Maximum Subsequence Sum","date":"2018-09-12T06:03:19.000Z","updated":"2018-09-12T06:06:35.816Z","comments":true,"path":"2018/09/12/01-复杂度2 Maximum Subsequence Sum/","link":"","permalink":"https://ainevsia.github.io/2018/09/12/01-复杂度2 Maximum Subsequence Sum/","excerpt":"","text":"主要做的几个改动 引入track变量来控制ij的记录时间点 修补了maxsum=0的一个小bug 反思 好好看清楚题目再做很重要，不要觉得自己做过一遍就有多懂了，还不是花了2h多吗，看看清楚要输出序号还是要输出值。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ainevsia.github.io/categories/数据结构与算法/"}],"tags":[{"name":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","slug":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","permalink":"https://ainevsia.github.io/tags/中国大学MOOC-陈越、何钦铭-数据结构-2018秋/"}]},{"title":"02-线性结构3 Reversing Linked List","slug":"02-线性结构3 Reversing Linked List","date":"2018-09-12T06:03:19.000Z","updated":"2018-09-13T13:10:55.873Z","comments":true,"path":"2018/09/12/02-线性结构3 Reversing Linked List/","link":"","permalink":"https://ainevsia.github.io/2018/09/12/02-线性结构3 Reversing Linked List/","excerpt":"","text":"进展 时间 进展 2018年9月12日中午 到目前为止还有两个测试点没过一个是全部反转，我测试的时候是对的呀；还有一个是超时 2018年9月13日21:02:58 AC 难点 容易想到一些歪门邪道，比如说我第一次想到的排序方法。 模拟内存的想法。 具体进行逆转的时候的操作 反思 做OJ的题目有一些注意事项是你不得不放在心上的 边界条件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;iomanip&gt;#define max 100005using namespace std;struct node &#123; int ads; int data; int next;&#125;;node memory[max];int getlength(node * head);node * reverse(node * head, int k);void print(node * head, int length);int main(int argc, char const *argv[]) &#123; freopen(\"D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt\", \"r\", stdin); int ads, n, k;cin &gt;&gt; ads &gt;&gt; n &gt;&gt; k; int address, data, next; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; memory[address].ads = address; memory[address].data = data; memory[address].next = next; &#125; node head, *headptr; head.next = ads; headptr = &amp;head; int length = getlength(headptr); for (size_t i = k; i &lt;= length; i+=k) &#123; int front = headptr-&gt;next; headptr-&gt;next = reverse(headptr,k)-&gt;ads; headptr = &amp;memory[front]; //print(&amp;head,length);cout &lt;&lt; endl; &#125; headptr = &amp;head; print(headptr,length); return 0;&#125;node * reverse(node * head, int k) &#123; node * front = &amp;memory[head-&gt;next]; node * rear = &amp;memory[front-&gt;next]; node * temp; int cnt = 1; while (cnt&lt;k) &#123; temp = &amp;memory[rear-&gt;next]; rear-&gt;next = front-&gt;ads; front = rear; rear = temp; cnt++; &#125; memory[head-&gt;next].next = rear-&gt;ads; return front;&#125;int getlength(node * head) &#123; int cnt = 0, adds = head-&gt;next; while (adds!=-1) &#123; cnt++; adds = memory[adds].next; &#125; return cnt;&#125;void print(node * head, int length) &#123; node * ptr = &amp;memory[head-&gt;next]; for (size_t i = 0; i &lt; length; i++) &#123; cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;ads; cout &lt;&lt; ' ' &lt;&lt; ptr-&gt;data &lt;&lt; ' '; if ( i==length-1 ) cout &lt;&lt; \"-1\"; else cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;next &lt;&lt; endl; ptr = &amp;memory[ptr-&gt;next]; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ainevsia.github.io/categories/数据结构与算法/"}],"tags":[{"name":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","slug":"中国大学MOOC-陈越、何钦铭-数据结构-2018秋","permalink":"https://ainevsia.github.io/tags/中国大学MOOC-陈越、何钦铭-数据结构-2018秋/"}]},{"title":"白帽子讲web安全","slug":"白帽子讲Web安全","date":"2018-09-10T11:35:49.000Z","updated":"2018-09-10T11:40:41.772Z","comments":true,"path":"2018/09/10/白帽子讲Web安全/","link":"","permalink":"https://ainevsia.github.io/2018/09/10/白帽子讲Web安全/","excerpt":"","text":"如何实施安全评估 资产等级划分 威胁分析 风险分析 设计安全方案 白帽子兵法 Secure by Default 最小权限原则 Defense in Depth 纵深防御原则 数据与代码分离原则 不可预测原则","categories":[{"name":"信息安全","slug":"信息安全","permalink":"https://ainevsia.github.io/categories/信息安全/"}],"tags":[{"name":"SJTU","slug":"SJTU","permalink":"https://ainevsia.github.io/tags/SJTU/"}]},{"title":"7-10 公路村村通","slug":"DS-7-10","date":"2018-08-24T11:54:04.000Z","updated":"2018-08-27T01:43:59.614Z","comments":true,"path":"2018/08/24/DS-7-10/","link":"","permalink":"https://ainevsia.github.io/2018/08/24/DS-7-10/","excerpt":"","text":"预备知识 最小生成树(Minimum Spanning Tree) 是一棵树 是由原图生成的 包含图内的所有的顶点 所有的边都是图中的边 权最小 图连通 等价 存在最小生成树 贪心算法 每一步都要眼前最好的 约束条件 Prim算法-让小数长大 算法复杂度 平方级别 稠密图 Kruskal算法-将森林合并成树 算法复杂度 ElogE 稀疏图 需要储备的数据结构：集合、并查集、最小堆 集合存储实现： 树结构：双亲表示法 孩子指向父节点 数组： 根节点为-1 堆是用数组实现的完全二叉树题目描述原题在这 思路Prim算法，日后再实现Kruskal算法 难点Prim算法的实现 体会与感想 Prim算法简直了，和Dijkstra算法一模一样 好tm烦啊 关键代码 7-10-Prim.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int Prim(int ** G, int n) &#123; bool * collected = new bool [n]; int * dist = new int [n], mincost = 0; for (int i = 0; i &lt; n; i++) &#123; collected[i] = false; dist[i] = inf; &#125; collected[0] = true; dist[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (G[0][i]&lt;dist[i]) &#123; dist[i] = G[0][i]; &#125; &#125; while (true) &#123; bool found = false; int min = inf, v = 0; for (int i = 1; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]&lt;min) &#123; found = true; min = dist[i]; v = i; &#125; &#125; if (!found) &#123; break; &#125; mincost += min; collected[v] = true; dist[v] = 0; // for every node w linking to the node v for (int w = 0; w &lt; n; w++) &#123; if (G[v][w]!=inf &amp;&amp; !collected[w]) &#123; if (G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (collected[i]==false) &#123; return -1; &#125; &#125; return mincost;&#125;","categories":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/categories/数据结构与算法题目集（中文）/"}],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"军训日记","slug":"MilitaryTrainning","date":"2018-08-23T13:32:45.000Z","updated":"2018-09-03T08:45:22.586Z","comments":true,"path":"2018/08/23/MilitaryTrainning/","link":"","permalink":"https://ainevsia.github.io/2018/08/23/MilitaryTrainning/","excerpt":"","text":"8月23日8月24日今天上午的训练结束之前连长组织了会操，我觉得自己的口令下的没什么毛病，同学们做的也都很好，可是没有被表扬。可能是走的时候排面还是没有标齐。 8月26日昨天晚上忘记知米背单词的打卡了，今天早上才发现，心里好难受。 今天上午还是下雨，我们班的进度我感觉已经十分落后了。大家正步走的时候分解动作都不稳。 下午教唱歌：打靶归来、有我在、军中绿花。 下午主攻正步走和跑步走的连贯练习。 先是正步走的臂腿结合一步两动的练习 8月27日哈哈哈昨晚拉练。 很开心，现在只记得前面的连是3连，后面的连是八连，走到凯旋门之前我们一直在疯狂拉歌。拍完照之后前后连队距离都比较大，也就没有再拉歌了。 记一下一件我认为是宝贵教训的一次经历：过了凯旋门的那一个加油点我居然怂恿梁力佳去女生手里拿了一瓶农夫山泉orz。然后他不要我就背自己包里了。我本来带的两瓶水明明正正好好，结果后半程我就在疯狂喝水，结果到最后还没喝完。 你要的东西会成为你的负担。 想清楚你要什么。 8月29日昨天晚上和7连联谊，玩到熄灯了才猛然惊醒，收拾收拾回宿舍了。 我总是觉得我准备的还不够充分，觉得自己没有买水果，买的士力架发现是辣花生味的。 说实话，联谊，有点累的。 今天下午我原来带的班被拆掉了，负责新的一列，是方阵的队形。 然后下午练跑步走的时候再一次被当场活捉。orz捉奸现场 今天不开连务会，早点休息。好想王宏武…… 8月30日今天一整天都是练方阵，orz，先送上一首分列式进行曲，此乃洗脑神曲也。 然后结束的时候我们营长来验收，我们好像把自己走的最差的一次展现给了营长看…. 从（1，4）的位置调到了（9,1）的位置，很舒服，能直接看到标兵，就是标齐感觉有些困难。 连着两天内务满分，嘤嘤嘤，我们好强。 加油，所有的一切终将消失，好好珍惜剩下的仅剩4天的训练时间吧！ 8月31日今天还是在练无聊的方阵。中途被连长T出去休息了好一会，最后又被连长调上第一列了orz 求无聊的日子快点结束吧！ 9月1日今天早上醒来发现手机开不了，悲剧。昨天夜间不就是设置了一个夜间更新然后今早起来就爆掉了。 上午去胡法光体育场练了三遍，踢的乱七八糟、一塌糊涂。 在等手机开了之后去取周可的杯子。 9月3日军训明天就结束了，看了一遍《悟空》，真的很难说再见。 王宏武说这会是一个难忘的军训，确实，真的很难忘。 我该怎样去告别这一段岁月。 这一敬，你我命运相交。 别人穿上军装就是这么好看，而为什么穿在自己的身上却觉得没那么好看了呢？ 昨晚的军训晚会坐在了很偏的位置，只能听到下面女生的尖叫声，和舞台上不停变幻着的刺眼灯光。","categories":[{"name":"军训","slug":"军训","permalink":"https://ainevsia.github.io/categories/军训/"}],"tags":[{"name":"SJTU","slug":"SJTU","permalink":"https://ainevsia.github.io/tags/SJTU/"}]},{"title":"7-9 旅游规划","slug":"DS-7-9","date":"2018-08-17T11:01:28.000Z","updated":"2018-08-17T12:37:14.995Z","comments":true,"path":"2018/08/17/DS-7-9/","link":"","permalink":"https://ainevsia.github.io/2018/08/17/DS-7-9/","excerpt":"","text":"预备知识 Floyd算法：复杂度 V^3 重要前提：一步一步向后推的 三重循环，每次从DK 归纳推理到 DK+1 其中DK是只经过编号为i（i&lt;K）时各个点对间的最短路 Dijkstra算法: 复杂度最高 V^2+E 这就是运行超时和答案正确之间的区别 题目描述原题在这 思路原先想着用Floyd算法去做的，写完发现有一个测试点运行超时了，无奈只好回到了Dijkstra算法，思路基本一致，唯一的不同点就是图换成了邻接矩阵表示，同时还多了一个fee的权需要检测。 难点不能用Floyd，本题实质是单源有权图的最短路问题（从s到d）。 体会与感想 stray ‘\\357’ in program```出现此类错误的原因，在编辑器中使用的utf-8的格式保存源代码中出现了中文的标点符号。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 关键代码&gt;7-9-Floyd.cpp```C++#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);void Floyd(int ** G, int n, int ** cost);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt&quot;, &quot;r&quot;, stdin); int n, m, s, d, ** cost = NULL; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); Floyd(G,n,cost); int length = G[s][d]; int fee = cost[s][d]; cout &lt;&lt; length &lt;&lt; &apos; &apos; &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;void Floyd(int ** G, int n, int ** cost) &#123; for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (G[i][j] &gt; G[i][k]+G[k][j]) &#123; G[i][j] = G[i][k] + G[k][j]; cost[i][j] = cost[i][k] + cost[k][j]; &#125; else if (G[i][j] == G[i][k]+G[k][j]) &#123; if (cost[i][j] &gt; cost[i][k] + cost[k][j]) &#123; cost[i][j] = cost[i][k] + cost[k][j]; &#125; &#125; &#125; &#125; &#125;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125; 7-9-Dijkstra.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend);int main(int argc, char const *argv[]) &#123; freopen(\"D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt\", \"r\", stdin); int n, m, s, d, ** cost = NULL, fee; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); int length = Dijkstra(G,n,s,d,cost,&amp;fee); cout &lt;&lt; length &lt;&lt; ' ' &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend)&#123; int * dist = new int [n]; int * fee = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; fee[i] = inf; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; for (int i = 0; i &lt; n; i++) &#123; if(!collected[i] &amp;&amp; G[s][i]!=inf) &#123; dist[i] = G[s][i]; fee[i] = cost[s][i]; &#125; &#125; int v = -1; while (true) &#123; int min = inf; v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (v==d || v==-1) break; collected[v] = true; for (int w = 0; w &lt; n; w++) &#123; if(!collected[w] &amp;&amp; G[v][w]!=inf) &#123; if (dist[v]+G[v][w]&lt;dist[w]) &#123; dist[w] = dist[v] + G[v][w]; fee[w] = fee[v] + cost[v][w]; &#125;else if (dist[v]+G[v][w]==dist[w]) &#123; if (fee[w] &gt; fee[v] + cost[v][w]) &#123; fee[w] = fee[v] + cost[v][w]; &#125; &#125; &#125; &#125; &#125; int ret = dist[v]; *spend = fee[v]; delete [] dist; delete [] fee; delete [] collected; return ret;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125;","categories":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/categories/数据结构与算法题目集（中文）/"}],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"7-8 哈利·波特的考试","slug":"DS-7-8","date":"2018-08-17T04:46:16.000Z","updated":"2018-08-17T05:20:38.742Z","comments":true,"path":"2018/08/17/DS-7-8/","link":"","permalink":"https://ainevsia.github.io/2018/08/17/DS-7-8/","excerpt":"","text":"预备知识 最短路径问题的分类： 单源最短路：从固定的源点出发求其到所有其他顶点的最短路径 无权图 BFS算法 有权图 Dijkstra 多源最短路 无权图的单源最短路算法：BFS算法 按照递增的顺序找出找出源点到各个顶点的最短路 算法要点：需要两个数组dist和path分别记录最短距离和上一个顶点 有权图的单源最短路算法：Dijkstra算法 分为已经确定最短路的集合S以及一个长度数组dist 实现原理：若路径是按照递增顺序生成的，则： 下一个加入S的点必定只经过S内的点（不然不是S内的点应该比当前点先加入S） 每次选一个dist最小的加入S（贪心算法） 加入点后会影响dist，影响的都是加入点的邻接点 算法实现要点： 需要dist、path和collected数组分别记录最短距离、上一个节点以及是否被收入S的信息 初始化条件：dist都为无穷大，path都没有，collect全不是 123dist[i] = inf;path[i] = -1;collected[i] = false; 修改源点的数据，进入Dijkstra函数 题目描述原题在这给定一张有权图，判断是否连通，若连通，则求使从一个顶点出发最长的最短路最短的那个节点。 思路Dijsktra算法对每一个节点使用 难点Dijsktra算法实现 体会与感想 这个金光闪闪的算法一定要记在脑子里啊~ 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int Dijkstra(node * G, int n, int s)&#123; int * dist = new int [n]; int * path = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; path[i] = -1; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; node * ptr = G[s].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[s]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[s] + ptr-&gt;weight; path[w] = s; &#125; &#125; ptr = ptr-&gt;next; &#125; while (true) &#123; int min = inf, v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (min==inf || v&lt;0) break; collected[v] = true; node * ptr = G[v].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[v]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[v] + ptr-&gt;weight; path[w] = v; &#125; &#125; ptr = ptr-&gt;next; &#125; &#125; int min = -1; for (int i = 0; i &lt; n; i++) &#123; if (dist[i]==inf) return -1; if (dist[i]&gt;min) min = dist[i]; &#125; delete [] dist; delete [] path; delete [] collected; return min;&#125;","categories":[],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"7-7 六度空间","slug":"DS-7-7","date":"2018-08-15T09:51:11.000Z","updated":"2018-08-15T09:59:22.659Z","comments":true,"path":"2018/08/15/DS-7-7/","link":"","permalink":"https://ainevsia.github.io/2018/08/15/DS-7-7/","excerpt":"","text":"预备知识 六度空间理论：社交关系图中，任一两个节点总可以在六步之内相互关联。 题目描述用深度优先搜索一幅图的每一个节点相对于其他所有节点满足六度空间理论的百分率。 思路用上次写的邻接表表示的图，基本没什么多的操作，就是控制一下BFS的层数就结束了。 难点没有难点 体会与感想 在Clion中调试的时候，想看new出来的一片连续空间时，需要在new watch中添加命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175- c++想要控制输出固定位小数时，先用fixed固定好小数点，在用setprecesion控制保留几位小数- setprecesion本来是用来控制有效数字的# 源代码```C++#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);int BFSvalid(node * G, int i, int n);void deleteGraph(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt&quot;, &quot;r&quot;, stdin); int n, m;cin &gt;&gt; n &gt;&gt; m; node * G = createGraph(n); readGraph(G,m); for (int i = 0; i &lt; n; i++) &#123; int valid = BFSvalid(G,i,n); double percentage = valid / (double)n; cout &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 100 * percentage; cout &lt;&lt; &apos;%&apos; &lt;&lt; endl; &#125; deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited, int * cnt) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); (*cnt)++; visited[min] = true; &#125;&#125;int BFSvalid(node * G, int start, int n) &#123; //return the number of valid nodes Queue * q = creatQueue(n); //of the BFS of node i bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; int cnt = 1, degree = 6; enQueue(q,start); visited[start] = true; int sentry = q-&gt;tail; while (q-&gt;head!=q-&gt;tail+1 &amp;&amp; degree&gt;0) &#123; while (q-&gt;head!=sentry+1) &#123; int popelement = deQueue(q); push(q,&amp;G[popelement],visited,&amp;cnt); &#125; sentry = q-&gt;tail; degree--; &#125; delete [] visited; deleteQueue(q); return cnt;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi-1, vj-1); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;","categories":[],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"7-6 列出连通集","slug":"DS-7-6","date":"2018-08-14T13:16:52.000Z","updated":"2018-08-14T13:25:13.636Z","comments":true,"path":"2018/08/14/DS-7-6/","link":"","permalink":"https://ainevsia.github.io/2018/08/14/DS-7-6/","excerpt":"","text":"预备知识 图 多对多的关系 无向边（u v） 有向边 线性表 一对一 树 一对多 抽象数据类型定义的三要 类型名称 数据对象集 操作集 网络 带权重的图 图的表示方法取决于你要解决的具体问题 DFS 深度优先搜索 出栈 DFS 时间复杂度取决于图的表示方法 领接表 O(N+E) 邻接矩阵 O(N^2) BFS 广度优先 DFS BFS 复杂度相同 广优的话，占内存多，能找到最优解，必须遍历所有分枝. 广优的一个应用就是迪科斯彻单元最短路径算法. 深优的话，占内存少，能找到最优解（一定条件下），但能很快找到接近解（优点），可能不必遍历所有分枝（也就是速度快）, 深优的一个应用就是连连看游戏. 连通分量 一次DFS 遍历了一个连通分量 题目描述分别用深度优先搜索和广度优先搜索遍历一幅图的所有节点。 思路首先就是考虑这个图该用领接表还是邻接矩阵来表示，后来在码代码的过程中发现确实是邻接矩阵方便的多，不用findmin函数。但我没用过邻接表，这次练习一下。 难点基本没有难点 体会与感想 大工程绝对不要企图用一个.cpp文件就想写完，太天真了。 果然写的太长了是因为我太菜了嘛 半天200行的效率 反复传图指针很难受 还没来得及看视频 源代码 这次的代码比较长，放一个文件里也比较乱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;iostream&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);void DFSlistComponents(node * G, int n);void deleteGraph(node * G, int n);void BFSlistComponents(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen(\"D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt\", \"r\", stdin); int n, e;cin &gt;&gt; n &gt;&gt; e; node * G = createGraph(n); readGraph(G,e); DFSlistComponents(G,n); BFSlistComponents(G,n); deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); visited[min] = true; &#125;&#125;void BFSlistComponents(node * G, int n) &#123; Queue * q = creatQueue(n); bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i]) &#123; cout &lt;&lt; \"&#123; \"; enQueue(q,i); visited[i] = true; while (q-&gt;head!=q-&gt;tail+1) &#123; int popelement = deQueue(q); cout &lt;&lt; popelement &lt;&lt;\" \"; push(q,&amp;G[popelement],visited); &#125; cout &lt;&lt; '&#125;' &lt;&lt; endl; &#125; &#125; delete [] visited; deleteQueue(q);&#125;void DFS(node * G, int i, bool * visited) &#123; while (remains(&amp;G[i],visited)) &#123; int min = findMin(&amp;G[i],visited); if (min==-1) return; cout &lt;&lt; min &lt;&lt;\" \"; visited[min] = true; DFS(G,min,visited); &#125;&#125;void DFSlistComponents(node * G, int n) &#123; bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (visited[i]) continue; cout &lt;&lt; \"&#123; \"; if (!visited[i]) &#123; cout &lt;&lt; i &lt;&lt;\" \"; visited[i] = true; DFS(G,i,visited); &#125; cout &lt;&lt; \"&#125;\" &lt;&lt; endl; &#125; delete [] visited;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi, vj); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;","categories":[],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"自搭梯子翻越GFW","slug":"across-GFW","date":"2018-08-12T12:04:23.000Z","updated":"2018-08-12T12:37:12.558Z","comments":true,"path":"2018/08/12/across-GFW/","link":"","permalink":"https://ainevsia.github.io/2018/08/12/across-GFW/","excerpt":"","text":"主要借鉴 十分钟搭建自己的科学上网SSR梯子非常感谢！ 思路 首先你得先租借好专用的VPS，推荐的有Digitalocean和Vultr 我先是试了试Singapore的服务器发现很慢，于是换了LA的，爽的不行。 然后就是在登陆服务器之后通过rrsmu.sh脚本安装ShadowsocksR 最后在自己的客户端装上SSR 奇迹就这样发生了","categories":[],"tags":[]},{"title":"7-4 是否同一棵二叉搜索树","slug":"DS-7-4","date":"2018-08-12T03:28:11.000Z","updated":"2018-08-12T08:52:25.880Z","comments":true,"path":"2018/08/12/DS-7-4/","link":"","permalink":"https://ainevsia.github.io/2018/08/12/DS-7-4/","excerpt":"","text":"题目描述判断给定的插入序列是否构成同一棵二叉搜索树 （二叉搜索树：所有左子树元素都小于自身，所有右子树元素都大于自身） 输入12345678984 23 1 4 23 4 1 23 2 4 12 12 11 20 输出123YesNoNo 思路判断数列的奇淫技巧，测试点1过不了。 哈哈现在我的奇淫技巧过了。 更新了根据即将插入的根进行判断。 难点选择比较的方法以及原始数据和比较数据的储存形式 体会与感想自己写的代码多看几遍总归是能看懂的，理清楚的。 还有很想说的是cmake不支持中文以及文件名中的空格，以后再也不用中文了。 真的，实在是..所有中文一律乱码 看了视频之后再写真的是畅通无比，一次提交直接AC。 膜递归… 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;void comparetree(int n, int l);int main(int argc, char const *argv[]) &#123; freopen(\"D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt\", \"r\", stdin); while (true) &#123; int n;cin&gt;&gt;n; if (n==0) break; int l;cin&gt;&gt;l; comparetree(n,l); &#125; return 0;&#125;void print(bool same)&#123; switch (same) &#123; case true: cout &lt;&lt; \"Yes\" &lt;&lt; endl;break; case false:cout &lt;&lt; \"No\" &lt;&lt; endl;break; &#125;&#125;void comparetree(int n, int l)&#123; int * src = new int [n]; //src--the original array int * select = new int [n]; //select 0--&gt;not added to the cmp tree for (size_t i = 0; i &lt; n; i++) cin &gt;&gt; src[i]; //select 1--&gt;added to the cmp tree int * cmp = new int [n]; for (size_t i = 0; i &lt; l; i++) &#123; bool same = true; for (size_t i = 0; i &lt; n; i++) &#123;cin &gt;&gt; cmp[i];select[i]=0;&#125; if (src[0]!=cmp[0]) &#123; //judge the head same = false; print(same); continue; &#125;else select[0] = 1; for (size_t i = 1; i &lt; n &amp;&amp; same; i++) &#123; //i--indecate the cmp node int rootcmp = src[0]; for (size_t k = 1; k &lt; n; k++) &#123; if (src[k]&gt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&gt;rootcmp) &#123; rootcmp = src[k]; &#125;else if (src[k]&lt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&lt;rootcmp) &#123; rootcmp = src[k]; &#125; &#125; for (size_t j = 1; j &lt; n; j++) &#123; if (select[j]==1) continue; if (cmp[i]==src[j]) &#123; select[j] = 1; break; &#125; int rootsrc = src[0]; for (size_t k = 1; k &lt; j; k++) &#123; if (src[k]&gt;rootsrc&amp;&amp;src[j]&gt;rootsrc) &#123; rootsrc = src[k]; &#125;else if (src[k]&lt;rootsrc&amp;&amp;src[j]&lt;rootsrc) &#123; rootsrc = src[k]; &#125; &#125; if (rootcmp==rootsrc) &#123; if (cmp[i]&gt;rootcmp&amp;&amp;src[j]&gt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; if (cmp[i]&lt;rootcmp&amp;&amp;src[j]&lt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; &#125; &#125; &#125; if (same) print(same); &#125;&#125; 顺便再贴一下看了视频之后的源码结构更加清晰 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;struct node &#123; int value; node * left; node * right; int select;&#125;;node * maketree(int n);void deletetree(node * tree);bool treecmp(node * tree, int n);int main(int argc, char const *argv[]) &#123; freopen(\"D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt\", \"r\", stdin); int n;cin &gt;&gt; n; while (n) &#123; int l;cin &gt;&gt; l; node * tree = maketree(n); for (int i = 0; i &lt; l; i++) &#123; if (treecmp(tree,n)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; deletetree(tree); cin &gt;&gt; n; &#125; return 0;&#125;bool check(node * tree, int v)&#123; if (!tree) return false; if (tree-&gt;value==v) &#123; tree-&gt;select = 1; return true; &#125; if (tree-&gt;select==0) &#123; return false; &#125; if (tree-&gt;value&gt;v) &#123; return check(tree-&gt;left,v); &#125;else&#123; return check(tree-&gt;right,v); &#125;&#125;void settree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) settree(tree-&gt;left) ; if (tree-&gt;right) settree(tree-&gt;right); tree-&gt;select = 0;&#125;bool treecmp(node * tree, int n)&#123; settree(tree); int v; bool ret = true; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v; if (!check(tree,v)) ret = false; &#125; return ret;&#125;void deletetree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) deletetree(tree-&gt;left) ; if (tree-&gt;right) deletetree(tree-&gt;right); delete tree;&#125;node * newnode(int value)&#123; node * treenode = new node; treenode-&gt;left = NULL ; treenode-&gt;right = NULL ; treenode-&gt;value = value ; treenode-&gt;select = 0 ; return treenode;&#125;node * attachnode(node * tree, int value)&#123; if (!tree) &#123; return newnode(value); &#125;else&#123; if (tree-&gt;value&gt;value) tree-&gt;left = attachnode(tree-&gt;left ,value); else tree-&gt;right= attachnode(tree-&gt;right,value); return tree; &#125;&#125;node * maketree(int n)&#123; int value; node * tree = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; tree = attachnode(tree,value); &#125; return tree;&#125;","categories":[],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"7-3 树的同构","slug":"DS-7-3","date":"2018-08-11T14:12:10.000Z","updated":"2018-08-11T14:31:09.215Z","comments":true,"path":"2018/08/11/DS-7-3/","link":"","permalink":"https://ainevsia.github.io/2018/08/11/DS-7-3/","excerpt":"","text":"题目描述判断给出的两棵树是否是同构的（同构-即左右子树可以相互交换位置） 输入1234567891011121314151617188A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 - 输出1Yes 思路刚开始听了MOOC上说用静态链表（简单来说就是数组，只不过每个元素带有指针效果的元素）后这么想的：读入需要两个inArray，再根据这两个Array构造两个满二叉树的char型数组，然后用递归写一个cmp在满二叉树的char型数组上比较。实在太麻烦了。 然后就用了MOOC上的方法。搞了全局变量，简直不要太舒服。 最后一个边界条件（n=0）引起的段错误调的我ooxx 难点怎么组织你的数据，就像老师讲的： 你打算怎么储存两棵树 怎么找到根节点（这个简单） 怎么比较同构1和3我现在都还是无法驾驭。1是熟练掌握数据结构的应用，3是写递归程序。 体会与感想深深地体会到了大神的代码和我自己的代码之间的区别（100+行都写不完和60行AC的差距）orz 当你函数的参数≥四个并且还是在反复传同一个参数的时候，你就该想想你的思路是不是不太对了。 有时候全局变量该用就得用，否则到时候难受的是你自己。 main函数里东西越少越好，代码质量越高，可读性越好。 递归函数感觉还是比较虚，边界条件有时理不清。 尽可能地检查边界条件（极小与极大）。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#define max 10#define null -1using namespace std;struct node &#123; char element; int left; int right;&#125;tree1[max], tree2[max];int build(node * tree);bool isomorphic(int r1, int r2);int main(int argc, char const *argv[]) &#123; freopen(\"D:\\\\SJTU\\\\Freshman Summer\\\\DS\\\\test.txt\", \"r\", stdin); int r1 = 0, r2 = 0; r1 = build(tree1); r2 = build(tree2); if (r1!=-1 &amp;&amp; r2!=-1) &#123; if (isomorphic(r1,r2)) cout &lt;&lt; \"Yes\"; else cout &lt;&lt; \"No\"; &#125;else if (r1==-1 &amp;&amp; r2==-1) &#123; cout &lt;&lt; \"Yes\"; &#125;else cout &lt;&lt; \"No\"; return 0;&#125;bool isomorphic(int r1, int r2)&#123; if (r1==null &amp;&amp; r2==null) return true; if (r1==null || r2==null) return false; int n1 = 0, n2 = 0; if (tree1[r1].left==null) n1++; if (tree1[r1].right==null) n1++; if (tree2[r2].left==null) n2++; if (tree2[r2].right==null) n2++; if (n1!=n2) return false; if (tree1[r1].element!=tree2[r2].element) return false; if (n1==2) return true; else if (n1==1) &#123; if (tree1[r1].left==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].right); &#125; else if (tree1[r1].left==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].left); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].right); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].left); &#125; &#125; else if (n1==0) &#123; if (tree1[tree1[r1].left].element==tree2[tree2[r2].left].element) &#123; return isomorphic(tree1[r1].left,tree2[r2].left) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].right); &#125;else&#123; return isomorphic(tree1[r1].left,tree2[r2].right) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].left); &#125; &#125; return true;&#125;int build(node * tree)&#123; int n;cin &gt;&gt; n; if (n==0) return -1; int * select = new int [n]; char le, ri; for (int i = 0; i &lt; n; i++) select[i] = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tree[i].element &gt;&gt; le &gt;&gt; ri; if (le!='-') &#123; tree[i].left = le - '0'; select[tree[i].left] = 1; &#125;else tree[i].left = null; if (ri!='-') &#123; tree[i].right = ri - '0'; select[tree[i].right] = 1; &#125;else tree[i].right = null; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (select[i]==0) &#123; ret = i; break; &#125; &#125; delete [] select; return ret;&#125;","categories":[],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"JavaScript编程艺术读后感","slug":"jsdom","date":"2018-08-02T04:18:00.000Z","updated":"2018-08-02T04:36:40.543Z","comments":true,"path":"2018/08/02/jsdom/","link":"","permalink":"https://ainevsia.github.io/2018/08/02/jsdom/","excerpt":"","text":"关于本书知乎上不知道是看了谁的推荐找到的这本书，从上周五放假了之后花了一周陆陆续续看完了 感想js感觉和c没什么差别啦最大的感觉就是web规范还有穿透全书的两大主题：平稳退化以及渐进增强 平稳退化：就是你要考虑到当你写的js被禁用的时候网页会变成什么样子。是直接蹦了还是跑样式了还是能勉强浏览。这是作者始终在强调的，可是我觉得现在我是理解无能的。说实话，有点小小抵触这种想法，我学js不就是为了实现那些行为效果吗，可能以后会有更深的理解的。 渐进增强：由底向上编程。了解了web才知道HTML css js这三驾马车，缺一不可。HTML是网站的主体内容，css负责美工上色，js负责网页行为交互。书最后还介绍了Ajax，我是看不懂了。总之看了这本书给我的一个启示就是：我不喜欢js。","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://ainevsia.github.io/tags/阅读/"}]},{"title":"小学期结束了，假期开始了","slug":"SummerSemesterEnd","date":"2018-07-27T08:40:02.000Z","updated":"2018-07-27T08:58:07.171Z","comments":true,"path":"2018/07/27/SummerSemesterEnd/","link":"","permalink":"https://ainevsia.github.io/2018/07/27/SummerSemesterEnd/","excerpt":"","text":"离别昨天傍晚阿阳一家就已经接他回江苏了，今早阿可一个人很早就出发了，中午的时候，阿韬的爸妈也来接他回江苏了。寝室里的人一个个地减少，最后，现在只剩下我了。 宿舍里的生气渐渐变少，阳台上晒着的衣服一件件地被不同的人收了进来，带回了家，阳台变得一干二净。上铺的床被搬空，书架上的书被带回了家，书桌被收拾的干干净净。窗外的蝉叫的更响亮了。 离别的气息充斥。 我一个人默默地考完最后一场考试，从东上院走出来。路上没有什么人，整个校园安安静静，仿佛整个世界只剩下闷热的空气。 孤独是一种常态吧，是嘛？ 我曾经不停地希望着中午回到寝室他们能不要吵，让我安安静静地再看一会儿书。 人可真是奇怪的动物，哈哈。 QQ也已经聊得很少了，在学期里明明是不想过多地去了解别人的消息，可是现在却热切地渴望着掌握别人的动态。 起航这个假期我准备干些什么呢？ 我想准备GRE，复习数据结构，看js书，多多做一些家务，多学一些日常本领。 还想预习一下下学期的电学基础课，多看一些文学书。 想保证一个健康的作息。","categories":[],"tags":[{"name":"Freshman-Summer","slug":"Freshman-Summer","permalink":"https://ainevsia.github.io/tags/Freshman-Summer/"}]},{"title":"7-2 一元多项式的乘法与加法运算","slug":"DS-7-2","date":"2018-07-18T12:09:50.000Z","updated":"2018-07-18T12:24:29.697Z","comments":true,"path":"2018/07/18/DS-7-2/","link":"","permalink":"https://ainevsia.github.io/2018/07/18/DS-7-2/","excerpt":"","text":"题目描述设计函数分别求两个一元多项式的乘积与和。 输入124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 思路首先要确定多项式的储存结构，决定用链表按照指数递降顺序存储。 接下来无非就是两个难题，一个是怎么加，一个是怎么乘。 难点一开始的时候我乘法用了我现在用的加法算法在一个个向后推，可以说是相当的蠢萌了。 加法标准做法是3个循环搞定，第一轮循环两个链表同时向后推，一个推到最后就把另一个剩下的全接上去就可以了。 乘法有很多种做法，我用了老师讲的插入法。 两轮循环，每一次都要向已有的链表上插入一个新的点，有时需要合并，有时需要删点。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;iostream&gt;using namespace std;const int MAX = 1003;struct node&#123; int coef;//系数 int expo;//指数 node * next;&#125;;node * CreatList(node * head); //单链表的读入与创建void PrintList(node * head); //输出以head为头结点的链表node * MultiplyList(node * p1, node *p2); //多项式乘法void Attach(int coef, int expo, node **nodepointer); //插入一个节点至nodepointer后node * AddList(node * p1, node *p2); //多项式加法void FreeList(node * p); //内存释放int main(int argc, char const *argv[]) &#123; node *head1 = NULL, *head2 = NULL; head1 = CreatList(head1); head2 = CreatList(head2); node *multi = MultiplyList(head1, head2); node *add = AddList(head1, head2); PrintList(multi);cout &lt;&lt; endl; PrintList(add); FreeList(head1);FreeList(head2);FreeList(multi);FreeList(add); return 0;&#125;node * CreatList(node * head)&#123; int coef, expo, k; node * p; head = new node; cin &gt;&gt; k; if ( !k ) return NULL; cin &gt;&gt; coef &gt;&gt; expo; head-&gt;coef = coef; head-&gt;expo = expo; head-&gt;next = NULL; p = head; for (size_t i = 1; i &lt; k; i++) &#123; cin &gt;&gt; coef &gt;&gt; expo; node *temp = new node; p-&gt;next = temp; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = NULL; p = temp; &#125; return head;&#125;void PrintList(node * head)&#123; if ( !head ) &#123; cout &lt;&lt; \"0 0\"; &#125; while ( head ) &#123; cout &lt;&lt; head-&gt;coef &lt;&lt; \" \" &lt;&lt; head-&gt;expo; head = head-&gt;next; if ( head ) cout &lt;&lt; \" \"; &#125;&#125;//by inserting to the right place 2 loopsnode * MultiplyList(node * p1, node *p2)//p is the pointor&#123; //poining to the current node node *head = new node; head-&gt;expo = MAX; head-&gt;next = NULL; while ( p1 ) &#123; node *p = p2; while ( p ) &#123; //PrintList(head-&gt;next); //cout &lt;&lt; endl &lt;&lt; endl; int coef = p1-&gt;coef * p-&gt;coef; int expo = p1-&gt;expo + p-&gt;expo; node *temp = head; while ( true ) &#123; //point to one in front // cout &lt;&lt; \"once \"; if ( !(temp-&gt;next) || temp-&gt;next-&gt;expo&lt;=expo ) break; temp = temp-&gt;next; &#125; //now temp points to the insert place ahead // cout &lt;&lt; \"now expo is \" &lt;&lt; expo; // cout &lt;&lt; \"my temp-&gt;expo = \" &lt;&lt; temp-&gt;expo &lt;&lt; endl; if ( temp-&gt;next &amp;&amp; temp-&gt;next-&gt;expo == expo ) &#123; if ( temp-&gt;next-&gt;coef + coef == 0 ) &#123; //delete node * tobefreed = temp-&gt;next; temp-&gt;next = tobefreed-&gt;next; delete tobefreed; &#125;else &#123; //join together temp-&gt;next-&gt;coef += coef; &#125; &#125;else Attach(coef, expo, &amp;temp); p = p-&gt;next; &#125; p1 = p1-&gt;next; &#125; node * tobedeleted = head; head = head-&gt;next; delete tobedeleted; return head;&#125;void Attach(int coef, int expo, node **nodepointer)&#123; // cout &lt;&lt; \"now coef=\" &lt;&lt; coef &lt;&lt; \" expo=\" &lt;&lt; expo &lt;&lt; // \" inserted after expo=\" &lt;&lt; (*nodepointer)-&gt;expo &lt;&lt; endl; node * temp = new node; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = (*nodepointer)-&gt;next; (*nodepointer)-&gt;next = temp;//here // cout &lt;&lt; \"now temp-&gt;next=\" &lt;&lt; temp-&gt;next; // cout &lt;&lt; \" *nodepointer points to expo\" &lt;&lt; (*nodepointer)-&gt;expo;&#125;node * AddList(node * p1, node *p2) //receive 2 pointers and return the AddList&#123; //head is a pointer to the head node node * p, * head; head = new node; //head is a head noder contains p = head; //nothing but a next pointor head-&gt;coef = 0; head-&gt;expo = 0; head-&gt;next = NULL; while ( p1 &amp;&amp; p2 ) &#123; int expo1, expo2; expo1 = p1-&gt;expo; expo2 = p2-&gt;expo; if ( expo1 &gt; expo2 ) &#123;//copy p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125;else if ( expo1 &lt; expo2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125;else &#123; int coef = p1-&gt;coef + p2-&gt;coef; if ( coef ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = coef; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; &#125; while ( p2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125; while ( p1 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125; //cout &lt;&lt; head-&gt;next; p = head; head = head-&gt;next; delete p; return head; // if ( head-&gt;next ) &#123; // &#125;else &#123; // return head; // &#125;&#125;void FreeList(node * p)&#123; node * next; while ( p ) &#123; next = p-&gt;next; delete p; p = p-&gt;next; &#125;&#125;/*程序最后的两个细节问题1- 当加法结果为零时的输出2- 当有一个k为零时的输出*/","categories":[],"tags":[{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","permalink":"https://ainevsia.github.io/tags/数据结构与算法题目集（中文）/"}]},{"title":"一些感悟","slug":"reflection","date":"2018-06-14T08:14:30.000Z","updated":"2018-06-14T08:19:53.141Z","comments":true,"path":"2018/06/14/reflection/","link":"","permalink":"https://ainevsia.github.io/2018/06/14/reflection/","excerpt":"","text":"后悔这学期做了很多我现在想想会感到后悔的事情，比如说选了学术英语这门课：实在是无比后悔。 我感觉人活着就是看一股气 这股气来自于自己的内心","categories":[],"tags":[]},{"title":"期末感想","slug":"dark-time-reflection","date":"2018-06-07T04:07:48.000Z","updated":"2018-06-07T07:42:29.162Z","comments":true,"path":"2018/06/07/dark-time-reflection/","link":"","permalink":"https://ainevsia.github.io/2018/06/07/dark-time-reflection/","excerpt":"","text":"我曾经一直以为期末挂科是不可能的 现在发现我太天真了It is possible that I am going to fail the 大学物理 量子物理 电路理论就是因为别人不在听，所以我就没有动力去做吗就是因为觉得课程弱智，一点都帮不到我，所以我就一拖再拖，拖到最后就不做吗网络并不是万能的远远不是万能的 他搜索不到钱寅哲的下落 你永远都想不到你连大英都会挂我并不认为自己比别人差我认为把自己在做的事情做到最好就可以了 这只不过是一道坎罢了 坚持下去 跨过去 你就会成长what doesn’t kill you makes you stronger. 为了加分使劲地举手 很令人丢脸吗我的存在对他人的影响 有很大吗 有电脑在手上 就是把自由带在了身边不要把别人想的想你一样浅薄 是什么让我变得平庸 他们从来都没有失败我觉得他们比我自己强多了失败让他们变得更加强大那么我呢失败是否会击败我还是让我变的更加强大呢 成绩难道不是我自己求得的吗只是我自己的随想罢了 我本来很强嘛我觉得思考这些东西很累说实话 让我去思考什么全球化的东西 我一点感想都没有让我对时政发表看法 我一点想法都没有我认为别人会时时刻刻地关注我然而 他们并没有 他们只是关注于自己的事情罢了就像我自己一样我有时候很讨厌说话装逼的人我有时候讨厌那些说大话空话的人我有时候根本就不想说话我有时候想享受大家对我的关心然而却不愿意去主动关心他人 你学到的东西eye contact","categories":[],"tags":[{"name":"不要放弃 熬过去就行了","slug":"不要放弃-熬过去就行了","permalink":"https://ainevsia.github.io/tags/不要放弃-熬过去就行了/"}]},{"title":"重新出发","slug":"18-06-05","date":"2018-06-05T15:45:13.000Z","updated":"2018-06-06T14:06:34.476Z","comments":true,"path":"2018/06/05/18-06-05/","link":"","permalink":"https://ainevsia.github.io/2018/06/05/18-06-05/","excerpt":"","text":"晚上看俞闻韬打了两小时dota2每个人都有自己的爱好不是吗重要的是你自己究竟想要什么 明天就是高考了对于明天的展望今天下午在图书馆坐了一下午先是很快地做完了谐振的一道大题然后看了看今天刚教的三相电路的习题线电压 线电流 相电压 相电流这些概念还是不清楚啊不要把一切事情都想得太过简单了也不要把一切事情都看得难如上青天 高考 到点休息","categories":[],"tags":[{"name":"失意 涅槃","slug":"失意-涅槃","permalink":"https://ainevsia.github.io/tags/失意-涅槃/"}]},{"title":"PAT-A-1051","slug":"PAT-A-1051","date":"2018-05-07T11:52:55.000Z","updated":"2018-05-07T12:00:41.743Z","comments":true,"path":"2018/05/07/PAT-A-1051/","link":"","permalink":"https://ainevsia.github.io/2018/05/07/PAT-A-1051/","excerpt":"","text":"DescriptionGiven a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Thoughtsjust Stack simulation Long time no code and my coding ability drops significantly. This problem may be rather simple for some one, but it just serve the purpose of revieweing the basic knowledges for me. Sometimes a tiny bug can drive you crazy. No one can come to the final solution at the first glance, but as long as you spend your time on it, it will no doubt seem more ane more clear to you. Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]) &#123; //freopen(&quot;D:\\\\cpphomework\\\\test.txt&quot;, &quot;r&quot;, stdin); int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; int **Sequence = new int * [k]; for (size_t i = 0; i &lt; k; i++) Sequence[i] = new int [n]; int *used = new int [n+1], *result = new int [n]; int remaining = m; for (size_t i = 0; i &lt; k; i++) &#123; result[i] = 1; for (size_t j = 0; j &lt; n; j++) &#123; cin &gt;&gt; Sequence[i][j]; &#125; &#125; //prepare for (size_t i = 0; i &lt; k; i++) &#123; remaining = m; for (size_t j = 1; j &lt;= n; j++) used[j]=0; int q = 1, c = 0; //start while ( q&lt;=n &amp;&amp; remaining&gt;0 &amp;&amp; result[i] ) &#123; if ( q==Sequence[i][c] ) &#123; used[q] = 1; while ( c+1&lt;n &amp;&amp; Sequence[i][c+1]&lt;Sequence[i][c] ) &#123; int examine = Sequence[i][c]-1; while ( used[examine]==1 ) examine--; if ( Sequence[i][c+1]==examine ) &#123; used[examine] = 1; remaining++;c++; &#125;else &#123; result[i] = 0;break; &#125; &#125; q++;c++; &#125; else &#123; q++;remaining--; &#125; &#125; if ( q&lt;=n ) &#123; result[i] = 0; &#125; for (size_t j = 1; result[i] &amp;&amp; j &lt;= n; j++) &#123; if ( used[j]!=1 ) &#123; result[j] = 0; break; &#125; &#125; &#125; //output for (size_t i = 0; i &lt; k; i++) &#123; switch ( result[i] ) &#123; case 1: cout &lt;&lt; &quot;YES&quot;;break; case 0: cout &lt;&lt; &quot;NO&quot;;break; &#125; if ( i!=k-1 ) cout &lt;&lt; endl; &#125; //delete for (size_t i = 0; i &lt; k; i++) delete [] Sequence[i]; delete [] Sequence; delete [] used; delete [] result; return 0;&#125;","categories":[],"tags":[{"name":"PAT-Advanced-Level","slug":"PAT-Advanced-Level","permalink":"https://ainevsia.github.io/tags/PAT-Advanced-Level/"}]},{"title":"18-04-03","slug":"reflectino","date":"2018-04-03T05:34:09.000Z","updated":"2018-04-11T15:23:09.950Z","comments":true,"path":"2018/04/03/reflectino/","link":"","permalink":"https://ainevsia.github.io/2018/04/03/reflectino/","excerpt":"","text":"我并不是讨厌生活，我只是讨厌现在的自己中午搜了半小时的《向死而生》的当年看过的那篇博客。 然后就发现了，我确实是不会用搜索引擎。 上午的高数课最后一小点儿我没听懂 大物课我也是最后的质心参考系没跟上老师的进度。 我只是想把我在做的每一件事都尽我的可能做到最好，为什么这么简单的要求我还是做不到？昨天两次实验全部做崩。 物理实验线性关系没有做出来 化学实验产率13% 思路一旦没有转过来我就全完蛋 这几天为什么都诸事不顺啊高数做10题能错7题。离散上周的作业都留到了这周才做。思修小组作业没有做。练琴没有时间练。电路理论上了课作业还是不会做。 大学和高中完全不同。 大学可能是玄学。 怎么在巩固好学业的基础上处理学生事务、生活事务。 不要灰心、不要沮丧、坚持、坚持、坚持、坚持、坚持。 黎明前的黑暗是最难熬的。 不要再自我安慰了离散你只是上课去听个课你说你能学好吗？ 就像你只听老师讲c++自己不码代码绝对的挂科。 晚安。 开心一点。 再过几分钟就是全新的一天了。 明天加油。 思修课抱到大腿了超级大的腿 天生的演讲者 不劳而获的愧疚感 不要一直只想着自己 多为别人考虑考虑","categories":[],"tags":[{"name":"心情日记","slug":"心情日记","permalink":"https://ainevsia.github.io/tags/心情日记/"}]},{"title":"寒假见闻","slug":"寒假见闻","date":"2018-02-14T13:49:51.000Z","updated":"2018-09-08T14:33:28.206Z","comments":true,"path":"2018/02/14/寒假见闻/","link":"","permalink":"https://ainevsia.github.io/2018/02/14/寒假见闻/","excerpt":"","text":"这个寒假我干了啥呢？ 日期 事件 5日 去九院看牙齿，得知还不能装上牙套，母生气，徐家汇购物，校医院配药 6日 外婆家，高烧，傍晚五院点滴 7日 科目四，查询报销 8日 无所事事,忘了 9日 blog 10日 收快递，驾照，win7 11日 外婆家， 12日 ？ 13日 外婆，dokidoki cao，全tm记不起来了我一直以为我可以记得很tm清楚的 不得不说，我真的是一个很拖延的人，明明知道有些事是对的事，有些事是错的事，但是我并没有去做那些对的事，也没有改掉那些错的习惯。 离开舒适区，请，求你了。 大年三十又是糟糕的一天 一整天几乎就没干什么事情 在外婆家有一种什么都干不了的感觉 真的好烦。 与其坐以待毙，不如主动出击。 大一暑假假期见闻这个暑假好像很短啊！先是忙小学期，然后稍微修整了十多天军训就轰轰烈烈地开始了，度过了这个难忘的军训之后我抽空和几位舍友一起去南京玩了两天，回来之后就是现在了，开学了，我已经大二了。 首先说说小学期吧。这个小学期我选了三门非常喜欢的课：ICS、大学生健康教育和刑法与生活。真的是学到了很多的东西，虽然最后的成绩都不是很好看，但是回想上课的那四周我真的是完全地投入其中的。哎，期末的时候千万不要太放松，你一放松期末总评就刷刷往下掉，越到期末越是不能放松啊。 虽然这中间的十几天没有参加什么有意思有意义的社会实践，但是不久就开始小班长集训了。大学的军训我是一辈子都不会忘记的，这可能是大家最后一次表现地这么有凝聚力，共同齐心协力只为了一个共同的目标的时光了。我们收获珍贵的情谊，培养过硬的作风，把军人坚韧刚毅果敢的品质内化为自己的内心力量。虽然交大的军训确实是有点水，除了队列练习基本上没有什么别的主要的内容了，体贴学生简直到了放纵的地步，但是最后那几天方阵彩排的那个闷热的上午，我第一次知道我的手臂上居然能沁出如此细密的汗珠，第一次知道汗水流到眼睛里是多么的刺眼睛，第一次感受到汗水顺着腹部流下的奇痒难忍。","categories":[],"tags":[{"name":"寒假","slug":"寒假","permalink":"https://ainevsia.github.io/tags/寒假/"}]},{"title":"Reinstall my Win7 Ultimate","slug":"Ultimate","date":"2018-02-10T12:10:21.000Z","updated":"2018-02-12T13:05:55.437Z","comments":true,"path":"2018/02/10/Ultimate/","link":"","permalink":"https://ainevsia.github.io/2018/02/10/Ultimate/","excerpt":"","text":"TriggersMy old ThinkPad E430c, which my father bought in about 2012, is operatering more and more slowly nowadays. A few days ago, it even experienced several bruescreens breakups, and it took me a whole morning to just start it. After examing the hard-drive, I found that it was severely damaged, maybe due to the bumping on the road. So last night, I bought a SSD (TOSHIBA Q200 240G) PreparationsAfter searching the Internet for almost a whole day, I decided to still install the Win7 Ultimate. I also learned a lot through searching. :D I finally found a detailed tutorial called xitongcheng. It guided me to turn my original onlydisk into a USB setup disk. What I need now is only a Win7 system now (from msdn). Place the SSD in place and start your computerHere comes a terrible question.What should I do? I googled it and founded the solution. just type in three commands:123find --set-root /bootmgrchainloader /bootmgrboot and it entered the PE system. Then just choose the Win7 Ultimate. It works. install the DRIVERFirst of all, you should make sure that your computer can have access to the Internet. Then everything went on smoothly without explaination. Inflections I don’t want to reinstall any system any longer! It’s really complicated!","categories":[],"tags":[]},{"title":"Hello World","slug":"README","date":"2018-02-09T03:54:57.061Z","updated":"2018-02-09T03:54:57.061Z","comments":true,"path":"2018/02/09/README/","link":"","permalink":"https://ainevsia.github.io/2018/02/09/README/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}