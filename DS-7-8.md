---
layout: blog
title: 7-8 哈利·波特的考试
date: 2018-8-17 12:46:16
tags: 数据结构与算法题目集（中文）
---
# 预备知识
- 最短路径问题的分类：
 - 单源最短路：从固定的源点出发求其到所有其他顶点的最短路径
   - 无权图 BFS算法
   - 有权图 Dijkstra
 - 多源最短路
- 无权图的单源最短路算法：BFS算法
 - 按照**递增**的顺序找出找出源点到各个顶点的最短路
 - 算法要点：需要两个数组dist和path分别记录最短距离和上一个顶点
- 有权图的单源最短路算法：**Dijkstra算法**
 - 分为已经确定最短路的集合S以及一个长度数组dist
 - 实现原理：若路径是按照递增顺序生成的，则：
   - 下一个加入S的点必定只经过S内的点（不然不是S内的点应该比当前点先加入S）
   - 每次选一个dist最小的加入S（贪心算法）
   - 加入点后会影响dist，影响的都是加入点的邻接点
 - 算法实现要点：
   - 需要dist、path和collected数组分别记录最短距离、上一个节点以及是否被收入S的信息
   - 初始化条件：dist都为无穷大，path都没有，collect全不是
   ```
   dist[i] = inf;
   path[i] = -1;
   collected[i] = false;
   ```
   - 修改源点的数据，进入Dijkstra函数
   ![Dijsktra算法的伪码描述](https://res.cloudinary.com/ainevsia/image/upload/v1550225373/Dijsktra.png)

# 题目描述
[原题在这](https://pintia.cn/problem-sets/15/problems/716)
给定一张有权图，判断是否连通，若连通，则求使从一个顶点出发最长的最短路最短的那个节点。

# 思路
Dijsktra算法对每一个节点使用

# 难点
Dijsktra算法实现

# 体会与感想
- 这个金光闪闪的算法一定要记在脑子里啊~

# 关键代码
```C++
int Dijkstra(node * G, int n, int s)
{
    int * dist = new int [n];
    int * path = new int [n];
    bool * collected = new bool [n];
    for (int i = 0; i < n; i++) {
        dist[i] = inf;
        path[i] = -1;
        collected[i] = false;
    }
    dist[s] = 0;
    collected[s] = true;
    node * ptr = G[s].next;
    while (ptr) {
        if (!collected[ptr->element]) {
            int w = ptr->element;
            if (dist[s]+ptr->weight<dist[w]) {
                dist[w] = dist[s] + ptr->weight;
                path[w] = s;
            }
        }
        ptr = ptr->next;
    }

    while (true) {
        int min = inf, v = -1;
        for (int i = 0; i < n; i++) {
            if (!collected[i] && dist[i]!=-1 && dist[i]<min) {
                min = dist[i];
                v = i;
            }
        }
        if (min==inf || v<0) break;
        collected[v] = true;
        node * ptr = G[v].next;
        while (ptr) {
            if (!collected[ptr->element]) {
                int w = ptr->element;
                if (dist[v]+ptr->weight<dist[w]) {
                    dist[w] = dist[v] + ptr->weight;
                    path[w] = v;
                }
            }
            ptr = ptr->next;
        }
    }

    int min = -1;
    for (int i = 0; i < n; i++) {
        if (dist[i]==inf) return -1;
        if (dist[i]>min) min = dist[i];
    }
    delete [] dist;
    delete [] path;
    delete [] collected;
    return min;
}
```
