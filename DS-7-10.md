---
layout: blog
title: 7-10 公路村村通
date: 2018年8月24日 19:54:04
categories: 数据结构与算法题目集（中文）
tags: 数据结构与算法题目集（中文）
---
# 预备知识
- 最小生成树(Minimum Spanning Tree)
 - 是一棵树
 - 是由原图生成的
   - 包含图内的所有的顶点
   - 所有的边都是图中的边
 - 权最小
- **图连通** 等价 **存在最小生成树**
- 贪心算法
 - 每一步都要眼前最好的
 - 约束条件
- Prim算法-让小数长大 算法复杂度 平方级别 稠密图
- Kruskal算法-将森林合并成树 算法复杂度 ElogE 稀疏图
 - 需要储备的数据结构：集合、并查集、最小堆
 - 集合存储实现：
   - 树结构：双亲表示法 孩子指向父节点
   - 数组： 根节点为-1
 - **堆是用数组实现的完全二叉树**
# 题目描述(更新)
[原题在这](https://pintia.cn/problem-sets/15/problems/718)

# 思路
Prim算法，日后再实现Kruskal算法

# 难点
Prim算法的实现

# 体会与感想
- Prim算法简直了，和Dijkstra算法一模一样
- 好tm烦啊

# 关键代码
>7-10-Prim.cpp

```C++
int Prim(int ** G, int n) {
    bool * collected = new bool [n];
    int * dist = new int [n], mincost = 0;
    for (int i = 0; i < n; i++) {
        collected[i] = false;
        dist[i] = inf;
    }
    collected[0] = true;
    dist[0] = 0;
    for (int i = 1; i < n; i++) {
        if (G[0][i]<dist[i]) {
            dist[i] = G[0][i];
        }
    }
    while (true) {
        bool found = false;
        int min = inf, v = 0;
        for (int i = 1; i < n; i++) {
            if (!collected[i] && dist[i]<min) {
                found = true;
                min = dist[i];
                v = i;
            }
        }
        if (!found) {
            break;
        }
        mincost += min;
        collected[v] = true;
        dist[v] = 0;
        // for every node w linking to the node v
        for (int w = 0; w < n; w++) {
            if (G[v][w]!=inf && !collected[w]) {
                if (G[v][w] < dist[w]) {
                    dist[w] = G[v][w];
                }
            }
        }

    }

    for (int i = 0; i < n; i++) {
        if (collected[i]==false) {
            return -1;
        }
    }
    return mincost;
}
```
