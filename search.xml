<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2006混淆C语言大赛-sykes2源码解析]]></title>
    <url>%2F2019%2F04%2F19%2Fsykes2%2F</url>
    <content type="text"><![CDATA[上周六在准备华为网络技术考试的闲暇之余发现了一段超级有趣的代码，出自国际C语言混乱代码大赛。或许你像我一样第一次听说这个比赛，那就摘一段维基百科的介绍： 国际C语言混乱代码大赛（IOCCC, The International Obfuscated C Code Contest）是一项国际程序设计赛事。从1984年开始，本赛事每年举办一次。本赛事的目的是写出最有创意和最让人难以理解的C语言代码。 先看一眼这段小巧玲珑的代码1main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; 运行这段代码看看干了啥123456789$ gcc ioccc.c -o a.out$ ./a.out !! !! !! !!!!!! !!!!!! !!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !! !! !! !! !! !!!! !!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !!!!!! !!!!!! 发现有6条warning 1234567891011121314151617181920$ gcc -Wall ioccc.c -o a.outioccc.c:1:1: warning: return type defaults to 'int' [-Wreturn-type] main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; ^ioccc.c: In function 'main':ioccc.c:1:14: warning: value computed is not used [-Wunused-value] main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; ^ioccc.c:1:1: warning: implicit declaration of function 'putchar' [-Wimplicit-function-declaration] main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; ^ioccc.c:1:103: warning: suggest parentheses around arithmetic in operand of '|' [-Wparentheses] main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; ^ioccc.c:1:123: warning: suggest parentheses around arithmetic in operand of '|' [-Wparentheses] main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; ^ioccc.c:1:1: warning: control reaches end of non-void function [-Wreturn-type] main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; ^ 这段代码能够将编译时刻系统时间（非运行程序时间）按照ASCII风格输出，太强了。 说实话，第一次看到这种操作的我感觉已经被秀了一脸了；等我仔细研究完这行代码之后的感觉是：太骚了，代码居然还能这么写！ 接下来准备详细分析这一行小小的代码是如何实现如此炫酷复杂吊炸天的功能的。 烧脑预警 在文章开始之前你可能需要思考一些你从来没有考虑过的问题 何时可以不指明返回类型？正常的main函数声明都是这样的 12345int main(int argc, char * arcgc[])&#123; return 0;&#125; 当然main函数的参数是可以省略的，可以单单写成main()。return 0也是可以省略的，程序会正常终止，只不过会多一条warning。 在实际生产环境中当然不会出现这样的代码，这只是极客们利用c语言的细节追求极简的成果。 甚至，main前面的int声明都可以省略。 Stack Overflow上有讨论这个默认类型声明： C89/90 still has the implicit int rule, so main() is equivalent to int main(). By leaving off the return type, you’ve implicitly defined the return type as int. “implicit int” in the C89/90 standard isn’t really a single rule in a single place – it’s spread around in a couple of places. For function parameters, there’s a separate specification (at §6.7.1) that: “Any parameter that is not declared has type int.” 在K&amp;R的经典教材C Programming Language的§6.5.2.1中列举了一些隐含的类型声明： int, signed, signed int, or no type specifiers 这句话的意思是：int, signed, signed int 或是没有声明类型这四者是等价的。 所以main前面的int可以省略，参数列表里的int也可以省略，最后就会只剩下代码中的： 1main(_)&#123;&#125; 注意到_是一个变量名，处在原本argc的位置，经过试验发现，其功能就是记录传入的参数个数。当你想我一样使用$ ./a.out不加任何参数调用的时候，其值就是1。 argc is 1; argv[0] is the string “./a.out” argv[1] is a NULL pointer 何时可以不包含头文件？putchar()函数可以不用include头文件。虽然它不是系统函数，但是实测确实可以。 这样我们可以愉快地把这段代码的格式排排好，把省略的声明补齐，顺便加上头函数。 1234567#include &lt;stdio.h&gt;int main(int i)&#123; i^448&amp;&amp;main(-~i); putchar(--i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); return 0;&#125; 利用&amp;&amp;的短路求值特性将第一行展开，^亦或运算符仅在i==448时为假，-~i将i取反之后取负数。由于int是使用补码在计算机内部存储的，取负数操作实际上等效于按位取反后加1，-~i等效于i+1。所以可以发现第一行就是一个条件递归。 123456int main(int i)&#123; if (i != 448) main(i+1); i--; putchar(i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); return 0;&#125; 此时需要知道我们在第一次进入main函数的时候i的初始值是1（不加参数的话）。此时需要把之后会对i有操作的–i提取到putchar外面（不然没法转化），这句递归可以转化为循环（非常不直观，需要花点时间好好想想）。 12345int main()&#123; for (int i=447; i&gt;=0; i--) &#123; //由于外层i--的操作，这里从447到0 putchar(i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); &#125;&#125; 要注意i是从447减小到0的，一共执行448次。因为递归调用的时候是从main(1)一直到main(448)。i=448时不再继续递归，但该次main剩下的操作还是要进行。 接下来只有一句putchar了，看来一共会输出448个字符。最后的:10可以知道根据条件输出会有回车LF(ASCII:10)，数一数最开始输出的图形的行数，我们发现有7行，可以猜测一下这个输出回车的条件应该会是与7的倍数有关。但是中间这一行putchar实在太长，我们一点一点看。首先看一看第一个?:运算符的条件 1putchar(i%64?/*some value*/:10); 这时我们突然发现每行的字符448/7=64。于是我们知道了每64个字符会出现一个换行符。 把:?运算符写成if-else形式会更加直观1234567int main()&#123; for (int i=447; i&gt;=0; i--) &#123; if (i%64 == 0) putchar('\n'); else putchar(32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1); &#125;&#125; 你看的精疲力尽了吗？ 哈哈我也写的累了。但是正真巧妙的东西还没有开始呢！ 我们需要花非常大的力气去看看putchar里到底写了什么。 来看这个输出，发现里面有两个字符串常量，还有移位运算和许多的位运算。这时候我不得不默默地掏出了好久没看的运算符优先级顺序表，给优先级加上括号。一句话就是算数运算优先，位运算次之，最后逻辑运算。 132|-~7[__TIME__-(i/8%8)]["&gt;'txiZ^(~z?"-48] &gt;&gt; ";;;====~$::199"[(i*2)&amp;8|i/64]/(((i&amp;2)?1:8)%8)&amp;1]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>ioccc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poem]]></title>
    <url>%2F2019%2F03%2F25%2Fpoem%2F</url>
    <content type="text"><![CDATA[四季是一首小诗四季四个季节里，我最喜欢夏天。 因为夏天天暗的晚。 落霞傍晚六点考完实验从四号楼里走出来，天居然还没有暗，是灰暗的深蓝色，西方只露出点点的晚霞。我突然间意识到夏天已经到了，我最喜爱的夏天，连春分也已经是上个星期的事情了。光线还足够，来来回回的人影看的清楚，但是他们的脸却看得朦胧，只能听到哒哒的脚步声。 我突然有一种恍然隔世之感。 我好像回到了小时候读过的课文里：拥挤的弄堂里，天色暗下来了。饭点已经到了，大人们都急着买菜回家，耳边是吵吵嚷嚷的讨价还价声。人们匆匆从我的身旁走过，他们是谁？我并不认识他们，他们也无意认识我。 上宝的英语老师顾琼在毕业时学校出的校本读物《风雅颂》里写过的话：我最喜欢做的事情是一个人去乘一号线，从莘庄乘到常熟路，不必要有座位，即使是站着也好，只是感受车厢里的风拂过面颊，吹乱头发，看着车厢里的人上上下下，忙碌而又有序。他们各有各的目的地，而我呢？我的目的地在哪儿呢？ 宣怀大道我第一次知道交大的时候，是什么时候的事情了呢？是爷爷带我去思源广场喂鸽子吗？是沿着南洋南路骑车骑得精疲力竭的那次吗？是学校组织统一去交大参观吗？是高二一个人拿着临时借书卡像做贼一样溜进交大图书馆吗？是高二暑假里每日的泡图刷题吗？是综合评价面试吗？ 我还记得，当我累得再也骑不动的时候，当我停下车环视我的四周的时候，天还没有完全黑，远处是深灰色阴沉的天空，眼前是一片波光粼粼的湖，身后是一座古色古香的建筑。 左边的道路当然，我现在已经知道了，那条路想必就是宣怀大道，那片湖显然就是电草前面那片湖，而建筑十有八九就是新图或是行政楼。但是我隐隐不安，因为我始终记得图书馆面前就是那片湖，或是行政楼，但是现实却不是这样，现实里，正对着电草的是另一片树林，没有任何建筑。 很显然，不出意外的话，只剩下两年我就即将要从交大滚蛋，离开这个我心心念念的地方，离开这个我注定要在其中度过我的青春的地方。 我绝对不是乐观的人。但是高考之前，即便是我联考掉出年级前一百，我也始终乐观地相信自己，我能考上交大的，我能考上交大的，虽然我这次考得很烂，但是高考的话我一定能考上交大的。如果本科没有考上交大，我研究生一定再考交大。 高考果然神奇发挥，语文成绩直接给我喂了一颗定心丸，轻轻松松地、甚至是以比较靠前的排名进入工科试验班，进入了我梦寐以求的电院。在入学前，我梦想着我能够改头换面，重新以新的状态开启人生新的阶段。 这是我选择的道路，那么现在呢？两年已经过去了，我又成长了多少？ 我的心态还是飘忽不定，心情不好的时候还是会失眠，心情好的时候又会觉得飘飘然，我就这样在既厌恶自己又羡慕自己的状态反复切换。 我好像没有什么改变，还是背从前的书包，还是很少与人交流。但是我肯定是有所改变的，变的更加迷茫，变得更加不知所措。 中间的道路可能因为第一个提到中国最高等学府的人只提到了交大，所以我对交大有所固执。我也曾想有一天我的大学、我的高中、我的初中会因为曾不经意录取了我这么一个学生而感到骄傲，可是我现在呢？世界因为我的存在而发生了任何的改变吗？ He who believes he can change the world can change the world. –Steve Jobs 我在幻想中虚度了我的每一天。我无法重新处理好我与学习之间的关系。 我是一个不会享受的人，只需要给我一个任务，再给我一个有必要完成它的理由，我就会开始心神不宁，开始想办法尽早完成它。大学两年我除了军训完的两天去了南京大学找老唐玩了半天，其余就没有任何的旅行，我甚至很少离开闵行。我避免选课，没有选二专。认为剩下的时间可以好好地做我自己喜欢的事情。 而实际上，我并没有因为这些我认为节省出来的时间做成任何小事，导师让我写简历想了一周还是放弃。相反，那些每日都安排的满满当当的人还能抽出空余时间干了一番大事。我开始怀疑自己是不是活的太过安逸了，我是不是把青春那朵娇艳的玫瑰亲手锁进保险箱里了。我保守但是完善的思想体系开始出现裂缝。 我整整一周没有干任何导师或是学长要求我该做的事情。我不知道未来我该何去何从，我不知道毕业时的海浪会不会吞没我这朵小小的浪花，我甚至不知道我当下该做什么有意义的事情。 右边的道路我想要变强，但是我不知道什么是强。 我知道什么是强，但是我不知道我该怎么变强。 成功的人总是各有各的成功方式， 但是迷惘的人往往都是同一种迷惘的想法。 本文完美地展现了一篇文章是如何跑题的]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深夜沉思]]></title>
    <url>%2F2019%2F03%2F24%2FMar24%2F</url>
    <content type="text"><![CDATA[这个周末我又干了些啥？周六下午两点TCTF开赛，上线看题还是一道也不会，除了水水热身题我真的是一道也做不下去。周六下午是一个好天气，本来不想辜负这般明媚的春光的，但是后来为了装电子技术实验要用的ise，一个下午就装了那个沙雕玩意。 这个周末实验室的进度为0，什么事情也没有干，吴恩达的ml也没有继续看下去，老师买的西瓜署只翻了几页，pytorch也没有去学。我又有点看不清我自己的方向了。 上一周一直想把数论里实现的一些简单操作用c来自己实现一下的，但是到现在还没有开始。华为网络挑战赛的学习资料还没有学习，老师叫我准备的简历也没有写。 颓废我觉得，大学若果再像现在这样：大好的时间里我既没有能够好好地乘周末愉快地放松一下自己，工作又没有好好工作，效率低的令自己惭愧，还不知道自己想要什么的人，可能真的是最悲惨的。]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>CTF AI ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-next+LaTeX输入公式时遇到的一些错误]]></title>
    <url>%2F2019%2F03%2F23%2FusingLaTeXinmd%2F</url>
    <content type="text"><![CDATA[起因去next配置里开了mathjax功能试了一下，遇到了些问题。 举个栗子当你按照LaTeX语法在md文件里输入如下公式时，在本地的Markdown preview里是没有任何错误的，但是部署上线后会是如下的效果 公式 1$J(\theta)=-\frac&#123;1&#125;&#123;m&#125; \sum_&#123;i=1&#125;^&#123;m&#125;\left[y^&#123;(i)&#125; \log \left(h_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)+\left(1-y^&#123;(i)&#125;\right) \log \left(1-h_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)\right]$ 效果 $J(\theta)=-\frac{1}{m} \sum{i=1}^{m}\left[y^{(i)} \log \left(h{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$ 注意在_之间的部分全部被解析成了Markdown语法中的斜体，其实原因就是hexo在静态生成网页时是先用Markdown的语法解析器解析你的md文件，然后再交给mathjax解析其中的公式。 解决在_前全部加上Markdown语法中的转义符\。 不过这样感觉就即不是纯正的Markdown，也不是是纯正的LaTeX了。 公式 1$J(\theta)=-\frac&#123;1&#125;&#123;m&#125; \sum\_&#123;i=1&#125;^&#123;m&#125;\left[y^&#123;(i)&#125; \log \left(h\_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)+\left(1-y^&#123;(i)&#125;\right) \log \left(1-h\_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)\right]$ 效果 $J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>LaTeX hexo-nex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Note Week 3]]></title>
    <url>%2F2019%2F03%2F12%2FML-W3%2F</url>
    <content type="text"><![CDATA[ClassificationTo attempt classification, one method is to use linear regression and map all predictions greater than 0.5 as a 1 and all less than 0.5 as a 0. However, this method doesn’t work well because classification is not actually a linear function. The classification problem is just like the regression problem, except that the values we now want to predict take on only a small number of discrete values. For now, we will focus on the binary classification problem in which y can take on only two values, 0 and 1. (Most of what we say here will also generalize to the multiple-class case.)For instance, if we are trying to build a spam classifier for email, then $x^{(i)}$may be some features of a piece of email, and y may be 1 if it is a piece of spam mail, and 0 otherwise. Hence, y∈{0,1}. 0 is also called the negative class, and 1 the positive class, and they are sometimes also denoted by the symbols “-” and “+.” Given $x^{(i)}$, the corresponding $y^{(i)}$ is also called the label for the training example. Simplified Cost Function and Gradient DescentWe can fully write out our entire cost function as follows: $J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$ $\theta_{j} :=\theta_{j}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}$ A vectorized implementation is: $\theta :=\theta-\frac{\alpha}{m} X^{T}(g(X \theta)-\vec{y})$]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Note Week 2]]></title>
    <url>%2F2019%2F03%2F11%2FML-W2%2F</url>
    <content type="text"><![CDATA[Multiple FeaturesLinear regression with multiple variables is also known as “multivariate linear regression”. We now introduce notation for equations where we can have any number of input variables. Gradient Descent in Practice I - Feature Scaling 特征缩放We can speed up gradient descent by having each of our input values in roughly the same range. This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven. The way to prevent this is to modify the ranges of our input variables so that they are all roughly the same. The goal is to get all input variables into roughly one of these ranges, give or take a few. Two techniques to help with this are feature scaling and mean normalization. Feature scaling involves dividing the input values by the range (i.e. the maximum value minus the minimum value) of the input variable, resulting in a new range of just 1. Mean normalization involves subtracting the average value for an input variable from the values for that input variable resulting in a new average value for the input variable of just zero. To implement both of these techniques, adjust your input values as shown in this formula: $x_{i} :=\frac{x_{i}-\mu_{i}}{s_{i}}$ Note that dividing by the range, or dividing by the standard deviation, give different results. The quizzes in this course use range - the programming exercises use standard deviation. Normal EquationGradient descent gives one way of minimizing J. Let’s discuss a second way of doing so, this time performing the minimization explicitly and without resorting to an iterative algorithm. In the “Normal Equation” method, we will minimize J by explicitly taking its derivatives with respect to the θj ’s, and setting them to zero. This allows us to find the optimum theta without iteration. The normal equation formula is given below: $\theta=\left(X^{T} X\right)^{-1} X^{T} y$ round off 四舍五入]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anagram]]></title>
    <url>%2F2019%2F03%2F09%2Fanagram%2F</url>
    <content type="text"><![CDATA[一个很有意思的易位构词本来想在寝室四人的合影上刻上一句话 结果想到了易位构词 Three hero outwit few gamer. Together with me, we are four.]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Note]]></title>
    <url>%2F2019%2F03%2F07%2FML-W1%2F</url>
    <content type="text"><![CDATA[What is Machine Learning?Two definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the abilit3y to learn without being explicitly programmed.” This is an older, informal definition. Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.” Example: playing checkers.E = the experience of playing many games of checkersT = the task of playing checkers.P = the probability that the program will win the next game.In general, any machine learning problem can be assigned to one of two broad classifications:Supervised learning and Unsupervised learning. Machine Learning Algorithms Supervised Learning Unsupervised Learning Supervised LearningIn supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.Supervised learning problems are categorized into “regression” and “classification” problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories. Example 1:Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem.We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories. Example 2:(a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture(b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign. Unsupervised LearningUnsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.We can derive this structure by clustering the data based on relationships among the variables in the data.With unsupervised learning there is no feedback based on the prediction results. Example:Clustering: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.Non-clustering: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party). Linear RegressionModel RepresentationTo establish notation for future use, we’ll use $x^{(i)}$ to denote the “input” variables (living area in this example), also called input features, and $y^{(i)}$ to denote the “output” or target variable that we are trying to predict (price). A pair $\left(x^{(i)}, y^{(i)}\right)$ is called a training example, and the dataset that we’ll be using to learn—a list of m training examples $\left(x^{(i)}, y^{(i)}\right); i=1,…,m$—is called a training set. Note that the superscript “(i)” in the notation is simply an index into the training set, and has nothing to do with exponentiation. We will also use X to denote the space of input values, and Y to denote the space of output values. In this example, X = Y = ℝ. To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn a function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y. For historical reasons, this function h is called a hypothesis. Seen pictorially, the process is therefore like this: When the target variable that we’re trying to predict is continuous, such as in our housing example, we call the learning problem a regression problem. When y can take on only a small number of discrete values (such as if, given the living area, we wanted to predict if a dwelling is a house or an apartment, say), we call it a classification problem. Cost FunctionWe can measure the accuracy of our hypothesis function by using a cost function. This takes an average difference (actually a fancier version of an average) of all the results of the hypothesis with inputs from x’s and the actual output y’s. ​$J\left(\theta_{0}, \theta_{1}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\limits\left(\hat{y}_{i}-y_{i}\right)^{2}=\frac{1}{2 m} \sum_{i=1}^{m}\limits\left(h_{\theta}\left(x_{i}\right)-y_{i}\right)^{2}$ 注释：方差(Mean squared error)的1/2。统计学中参数估计部分的内容。 To break it apart, it is $\frac{1}{2}\bar{x}$ where $\bar{x}$ is the mean of the squares of $h_{\theta}\left(x_{i}\right)-y_{i}$, or the difference between the predicted value and the actual value. This function is otherwise called the “Squared error function”, or “Mean squared error”. The mean is halved$\left(\frac{1}{2}\right)$ as a convenience for the computation of the gradient descent(梯度下降), as the derivative(导数) term of the square function will cancel out the $\frac{1}{2}$ term. The following image summarizes what the cost function does: Cost Function - Intuition IIf we try to think of it in visual terms, our training data set is scattered on the x-y plane. We are trying to make a straight line (defined by hθ(x)) which passes through these scattered data points. Our objective is to get the best possible line. The best possible line will be such so that the average squared vertical distances of the scattered points from the line will be the least. Ideally, the line should pass through all the points of our training data set. In such a case, the value of J(θ0,θ1) will be 0. Thus as a goal, we should try to minimize the cost function. In this case, θ1=1 is our global minimum. Cost Function - Intuition IIA contour plot(等高线地形图) is a graph that contains many contour lines. A contour line of a two variable function has a constant value at all points of the same line.]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode-2-AddTwoNumbers%2F</url>
    <content type="text"><![CDATA[读题的时候不认真看题写的时候就会完全按照自己想象中的题目去解题 这道题两个数字明明是已经逆向好给我做加法了 我还傻呵呵地先写了一遍 把两个链表逆向了一遍 另外 java也不太懂 reflections5+5的情况WA了一次 没有想到这样的情况 myCode1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; boolean conti = true; ListNode ret = new ListNode(0), al1 = l1, al2 = l2; ListNode r = ret; while (conti) &#123; int a1 = 0, a2 = 0; if (al1!=null) &#123; a1 = al1.val; al1 = al1.next; &#125; if (al2!=null) &#123; a2 = al2.val; al2 = al2.next; &#125; int sum = a1 + a2 + carry; if (sum&gt;=10) &#123; sum -= 10; carry = 1; &#125;else &#123; carry = 0; &#125; ret.val = sum; if (al1==null &amp;&amp; al2==null &amp;&amp; carry==0) conti = false; if (conti) &#123; ret.next = new ListNode(0); ret = ret.next; &#125; &#125; return r; &#125;&#125; Official12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 真的是短小精悍啊！]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假回顾+学期计划]]></title>
    <url>%2F2019%2F02%2F17%2Fsophomore-Winter%2F</url>
    <content type="text"><![CDATA[寒假见闻寒假从1月14日开始执行，由于在1月25日约了朋友一起参加美赛，所以14日到25日这两个礼拜就是常规培训、准备美赛。由于我和密院同年级的同学组队，中途跑了一个，只好带了一个大一小学妹凑满3个人，十足的菜鸡队配置。好像是第一次认认真真地参加大型团队竞赛，内心也没有什么底，抱着纯粹体验一把的心态稀里糊涂地就混到了25日。 我个人确实是极其不擅长与他人合作完成一个项目。开赛两小时我去图书馆借走了相关的书，我一度认为这些书能成为我们队的优势。但是，可能就是这些书限制了思路。书上用了CA，虽然到最后我们也没有能实现这个程序。当我和别人发生意见上的分歧时，我总是很难说服对方，我总是倾向于放弃我自己的想法，去听别人的指挥做事。我觉得自己除了第一天状态是在线的，剩下的4天智商全面下线，程序不想写，模型不知道怎么建，自暴自弃。 最后一天的通宵也是非常有意思。人生中第一次通宵，0点小憩了10分钟左右，之后完全没有很难受的感觉。整个教室挤满了人，没有回去睡觉的……虽然如此，如果是为了我个人的事情，我是绝对不会通宵的。 我也很想变的强一点，想一个更好的模型云云。美赛结束就已经29日了，再过一个礼拜就春节了。29日到除夕这个礼拜就完全是放飞自我的状态，每天打网游、补番、刷小说，干着自己每次放假都会干的事。把自己玩过的游戏一个个地玩过来，没有一个游戏能让我玩超过半天。我已经不再年轻了，曾经陪我一起打网游的人，现在也都各奔东西，再也找不到曾今的感觉了。而那些游戏，也随之失去了意义。嘛总之，花了不超过两周吧，把那些令人放纵的东西都玩腻了，把目光转向修养身心的东西上。 阅读文学类的从学期结束之前就已经在知米阅读上看原版的《时间机器》和《弗兰肯斯坦》，也不是会每天都读，会把情节攒起来一口气看。开学之后必须要养成每日打卡的习惯了，因为没什么时间能一口气看了。 非文学类的看了《万万没想到》、《csapp》、《算法》，这三本都是只看了10页的那种看，真正看的主要是老师要求的《漏洞分析》。 春节的时候，我轻哼：三个礼拜二十一天三百页十七章，按照我三天四章的速度，真的是绰绰有余。今天已经是寒假最后一天了，我正好看了一半。 有些时候吧，求其上者得其中，这种感觉真的实在是太强烈了。像我这种懒惰的人，在设定目标的时候就应该设置的高一点。压力对我来说并不是朋友，在高压下我只会惊慌失措，只有在心情平稳的时候我的效率才是最高的。所以说，大段的连续的时间是我必须要全神贯注地工作学习的时候。 有的时候我会问自己：我这是在干什么？当舍友告诉我他因为组会没法参加而决定退出的时候，我问自己：我是真的喜欢漏洞挖掘所以来到目前的这个实验室吗？我思考问题的时候一直是一种小农思想，即使进入大学这种想法也没法改正过来。过分地关注短期将会得到的利益，而不做长远的考虑。我害怕做出选择，选择之后又患得患失。我还需学习的知识实在是太多了，不知道我学什么能够学好。解决这种选择困难的方法就是安慰自己：我的生活并不会因为这一个选择就能变好，选了就选了，硬着头皮干下去，时间和努力不会亏待你的。 未来规划这个寒假和父母稍微聊了一下关于自己未来准备走的路线。我个人还是非常向往国外的教育的，但是父亲指出我根本不具备一个人在异国独立生活的基本能力。我想想也是，所以还是把目标定在了保研或是考研国内升学的方向。 上个学期给自己定下的每门课不低于85分的目标完美地完成了，更多的还是因为课程考试不难的原因，但是这学期出现了信号与系统和模电，我不敢再轻言不下85了。我渐渐意识到这种单纯以成绩来评价一学期是不科学的，因为这学期我还会有实验室的工作要做，难免会占去学习课内知识的时间。 我这学期的计划是信安的专业课我绝对是放在第一优先级的事情，然后再是电院的平台课，中间穿插实验室的研究吧。 写的非常的乱，但都是心底想说的话，暂且作为人生这一小段时光的总结吧。]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>保研 出国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建服务器]]></title>
    <url>%2F2019%2F02%2F17%2FOpenVpnOnOpenWrt%2F</url>
    <content type="text"><![CDATA[现状目前手上有三台服务器：一台windows，两台linux，还有一台路由器，openwrt固件，上面跑openvpn服务器，客户端安装openvpn客户端实现连接。公网ip从哪里来的还不清楚，暂时默认是从百度云上买来的，算是已知的了。 目标5月份开始正式调试，最多两周的时间要搞定，不想拖的时间太长了。 最终实现的目标是完整地复制已有的路由器的所有功能，目前主要只有openvpn的配置。]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>vpn 计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Future]]></title>
    <url>%2F2019%2F02%2F17%2FFuture%2F</url>
    <content type="text"><![CDATA[刚刚和父母聊了聊他们对于我未来的规划，重大的选择之前，我总是会考虑他们的意见。 无论对我的任何选择，母亲总是会理解我、支持我，而父亲则是站在了一个完全理性的角度给我指明可预见的最好的那条路。 我说我打算出国，美国太乱的话欧洲也可以。 父亲指出：我目前自理能力全无，衣食住行没有一样是能够独立的。以我的能力，能申请到的也都是些野鸡学校。 我反驳，我自理能力确实不行，但是我绝对能申请到名校！ 父亲说，现在已经不是改革开放了，大家都挤破头往外国去。目前外国的毕业生在就业市场上并没有什么什么优势。 我沉默了。 如果最终的目标还是回国工作的话，为什么要舍近求远呢？ # 晚餐后看了一篇毕世门的推送，感觉自己的内心好像又开始动摇了 想想父母的话，我又觉得心安了。 这是机会啊学了什么会了什么目前有些什么想法任何问题都可以问 大学生涯综述目前掌握的技能一点点把自己培养成技术人员该达到的水平 学习到的 读过的书 网络是怎样连接的 网络部 户根勤 密码学 jsdom编程艺术 编程语言类 课程ics 使用过c/c++/简易汇编/python/matlab/java/js/html/css/ ctf Linux/mac -&gt; 实验室 软件漏洞分析 人工智能的方法 漏洞分析学校的课程软硬皆功 理财 基金 背单词 小说 课余活动 志愿者 团体活动学生组织课业做ps 不会设计 想退实验室 看书 尽快地 运动比较少与人交流比较少认识的朋友也 想法长远考虑读硕士 不读博士走业界 不走学界 读完硕士 在国内就职 不想就简简单单写代码]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>保研 出国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sophomore Winter Dairy]]></title>
    <url>%2F2019%2F02%2F05%2FSophomoreWinter%2F</url>
    <content type="text"><![CDATA[2019年2月5日18:41:53大年初一，在家宅了一整天没有出门。 下午在玩新发现的卡牌类MOBA红莲之王，感觉可定制的程度更加大了，同时竞技性略有下降，娱乐性确实很强。 早上在Pinterest上随便搜了一张图群发微信好友，发到一半就不怎么想发了。 看到阿阳男神今天第一次上高架，特别羡慕，我还有几天才能满1年能上高架。 感觉他们都各有各自的朋友，而我，什么也没有。 忍受寂寞。 2019年2月3日19:36:04决定和寒假颓废的自己告别了 QQ飞车也开过了 LOL也打过了 王者荣耀也玩了 300英雄也玩了漫画也看了 番也补了 小说也看了 想做的事都干了 很遗憾我闲下来的时候最先想到的居然是这些事 说人话的话 就是： 我玩腻了 2019年2月1日23:56:00又在家宅了一整天 白天下LOL 下午玩LOL 晚上卸载LOL 苦笑 这也算是一种进步吧 不是吗 已经没有游戏能够吸引我超过一天了 在游戏里我也无法寻找自己曾经所追寻的那个世界了 还有2min 睡了]]></content>
      <categories>
        <category>Dairy</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MCM/ICM Thoughts]]></title>
    <url>%2F2019%2F01%2F29%2FMCM%26ICM%2F</url>
    <content type="text"><![CDATA[2019-1-29 09:55:44随便写点什么吧 随便写点关于参加完美赛的感想 可是我发觉我根本什么都不想写 美赛的四天，我大部分时间是在郁闷中度过的 今天通了个宵 没有什么特别的感觉 看着太阳落下去 然后再次升起来 有一种恍若隔世的感觉 春节已经到了 美赛完了 我也没有任何特别的计划 没有人逼着我我是不会去学的 可是我在巨大的压力之下 又学不进 前几天红星的歌现在是一首也听不进 研究计划已经跟不上了 还有厚厚的一本书等着我 shit 2019-1-21 12:34:15 这是大一的暑假我们四人留下的为数不多的合影 好想和他们每隔一段时间都留下一张令人难忘的合影啊 从长远来看，所有的事情都会变得物是人非 既然这样 为什么还要对现况患得患失 享受当下 2019-1-19 23:20:03开始慌了不知道自己能不能应对这次的MCM挑战啊 英语阅读已经连着一个礼拜没有碰过了 培训前3天我还在打游戏的时候重要的培训都已经讲过了555 后悔ing]]></content>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sophomore Fall Final]]></title>
    <url>%2F2019%2F01%2F11%2FFinal%2F</url>
    <content type="text"><![CDATA[剩余的课程已经没有剩余的考试了感谢自己到最后都没有放弃我自己感谢自己又熬过了一个期末这真是我度过的最难受的一个期末了看这考试列表里的科目被一门一门地划掉原来最多只能有6级标题 随便写点吧看这考试列表里的科目被一门一门地划掉，现在一个人在寝室里安享这静谧的午后：熟悉的atom界面时隔一周又能够打开了，可以放心地在空调间里脱去棉袄而不用担心着凉感冒了，这个午后注定是我一生中独特的、无所顾虑的午后。 总结一下这次考试周从后往前吧，概统是我复习的最不充分的一门。理力考前一天凌晨3点梦中惊醒，发现自己浑身是汗，被子都出湿了，然后入睡困难，爬起来听歌，再睡，第二天战略性地睡懒觉。 我给自己的压力实在太大了，这也和我这学期平时确实没有好好学习有关。实力没有，靠前虚，还想考个好成绩。现在回想起来，真的是太难受了。 我宁愿回高中考垫底、也不想在大学面临挂科的压力而学习了。 整理一下接下来要做的事情一件事情的结束永远意味着另外一件事情的开始 考完试，专业的老师就立马开了专业介绍会 好让我们想清楚自己剩下的2.5年在交大的生活该怎么过 我对自己的未来感到摇摆不定了 我想出国，但是不一定想读博士，但是老师却说在国外最好待满5年，别2年就回来，会被别人瞧不起。 但是无论如何，无论工作、保研、出国选择哪一条路 学习永远是排在第一位的 永远记住 学习永远是排在第一位的 梳理一下接下来的工作 准备数学建模竞赛 扫题 写作业 实验室 看书 写读书报告 自己看算法 用java实现 看一看下学期专业课的内容，最好预习起来 预约姚医生 学期总结考试周结束的这个周末，我车也开了，王者荣耀也打过了，小说也熬夜看过了，漫画也看过了，斗地主也打了。 该放纵自己的事情差不多全干完了，该收收心好好学习了。 我时刻提醒着自己不要忘记了我迈入交大第一天时自己的心情。 那可能是我本科期间最充满自信的一段时光 走到哪儿都是挺直了腰杆的，高傲的男孩 如今他在哪儿？ 相信自己能够成为自己心中的那个人 你的目标在哪儿？ 你后悔你当初考入交大的决定吗？ 我永远都不会后悔]]></content>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP Algorithm]]></title>
    <url>%2F2018%2F11%2F30%2FKnuth-Morris-Pratt-Algorithm%2F</url>
    <content type="text"><![CDATA[Introduction &amp;&amp; Core thoughtsCalculate the maximum shifting digits based on the characterics of the given patten string. How to calculate?Suppose we have a pattern string p[0:n] and the comparation failure happened when comparing s[i+j] with p[j] (when comparing s[i:i+n] with p[0:n]), that indicates that s[i:j-1] are already known and are equal to p[0:j-1]. So that suggests us to take a great heap as much as possible provided that Notice that when the failure happens at p[j], the digits before are already clearify and can tell whether the naive comparsion will succeed or not. VisualizationI think these two pictures can clearly illustrate the phenomenon: AcknowledgementsA lot of thanks to KMP算法详解 which let me understand this algorithm.]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scholarship]]></title>
    <url>%2F2018%2F11%2F14%2Fscholarship%2F</url>
    <content type="text"><![CDATA[奖学金每当自己要填各种申请表格的时候，我总会发现自己一无是处。 两面性今天的铣工做的是还算不是很爆炸，但是晚上情绪就很低落，大物和概统的作业都做的很难受。 不敢相信他们了不想看着自己每况愈下，成绩渐渐开始走下坡路。 所以说我为什么不喜欢在qq上问别人问题我讨厌等别人回答我迫切需要解答的问题 想要自己弄明白一切的东西，想要知道这一切背后所隐藏的奥秘，想要从一开始就有一个好的基础。 所以上课好好听可以嘛？ 理论力学…没能做完…，一道典型的三联杆问题，第一下没反应过来就慌了，到最后才突然明白是三联杆。 计算确实有点太慢，但也没办法，这就是我啊…这就是考试呗。 媒体创意经济结束了很遗憾这学期并没有学到什么东西，最后的小组大作业我自己也是什么事情都没有干，就是把大家的论文全部拼起来，加一个头加一个尾。真的是抱到了大腿了。 在家靠父母，出门靠朋友。 朋友越多，遇到事情就不会感到害怕。这是你的人脉啊。 人脉资源将是你踏上社会之后最重要的资源 小组报告我也觉得没有怎么用心做 要是我自己根本就不敢上去讲.. 突然发现我已经好久没有码代码了向github上提交的内容全是划水的注释上马回来之后觉得自己又成长了一些 钳工交大学子都是能够给一张图纸就能够把整机装起来的人！]]></content>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-图5 Saving James Bond - Hard Version]]></title>
    <url>%2F2018%2F10%2F17%2FDS-07-%E5%9B%BE5%2F</url>
    <content type="text"><![CDATA[LinksHere ThoughtsHow to use the function qsort() parameters: qsort(void * array, int numberofcells, int sizeofeachcell, function cmp) function cmp: cmp(const void * a, const void * b) &#123;12 return ((*pointer* to the type of the elements waiting to be sorted)a)-&gt;some attribute of the element - ...b;&#125; It is certainly a great habbit to write comments while writing the codesTalk is cheap, show me your Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define max 102const int radius = 50;int maxtime = max;struct node &#123; //crocodile -- node int x, y; //position label x and y bool flag; //true if the crocodile is close enough to the beach node * precedent; //pointer to the previous crocodile double distance; //distance to the previous crocodile int nodetime; //attribute that trace the distance from island&#125;;struct Stack &#123; //stack to implement the closest way node * stack[max * 2]; int sp; node * Pop()&#123;return stack[sp--];&#125; void Push(node * ptr)&#123;stack[++sp] = ptr;&#125;&#125;;node croco[max]; //all the crocodiles are kept in this arrayStack priostack; //priority stacknode * FinalNode = NULL;//keep the exitusing namespace std;double getdis(int x1, int y1, int x2, int y2);void dfs(node * ptr, int n, int d, node * pre, int times);int cmp(const void * a, const void * b);int main(int argc, char const *argv[]) &#123; freopen("../test.txt", "r", stdin); int n, d;cin &gt;&gt; n &gt;&gt; d; priostack.sp = -1; for (int i = 0; i &lt; n; ++i) &#123; //inialization cin &gt;&gt; croco[i].x &gt;&gt; croco[i].y; croco[i].flag = radius - abs(croco[i].x) &lt;= d || radius - abs(croco[i].y) &lt;= d; croco[i].precedent = NULL; croco[i].distance = 0; croco[i].nodetime = max; &#125; //first iteration for (int i = 0; i &lt; n; ++i) &#123; if (getdis(0,0,croco[i].x,croco[i].y)&lt;=7.5+d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; if (priostack.sp+1 &gt; 1) qsort(&amp;priostack.stack[0], priostack.sp+1, sizeof(node*), cmp); int cnt = 0, num = priostack.sp + 1; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,NULL,1); //out put section if (maxtime == max) cout &lt;&lt; 0; else if (d &gt;= 43) cout &lt;&lt; 1; else &#123; int outputcnt = 0; while (FinalNode) &#123; outputcnt++; priostack.Push(FinalNode); FinalNode = FinalNode-&gt;precedent; &#125; cout &lt;&lt; outputcnt + 1 &lt;&lt; endl; while (outputcnt--) &#123; FinalNode = priostack.Pop(); cout &lt;&lt; FinalNode-&gt;x &lt;&lt; ' ' &lt;&lt; FinalNode-&gt;y &lt;&lt; endl; &#125; &#125; return 0;&#125;void dfs(node * ptr, int n, int d, node * pre, int times) &#123; ptr-&gt;precedent = pre; if (ptr-&gt;flag &amp;&amp; times &lt; maxtime) &#123; maxtime = times; FinalNode = ptr; &#125; ptr-&gt;nodetime = times; int bp = priostack.sp; for (int i = 0; i &lt; n; ++i) &#123; if (croco[i].nodetime&gt;times+1 &amp;&amp; getdis(ptr-&gt;x,ptr-&gt;y,croco[i].x,croco[i].y)&lt;=d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; int num = priostack.sp - bp; if (num &gt; 1) qsort(&amp;priostack.stack[bp+1], (size_t)priostack.sp-bp, sizeof(node*), cmp); int cnt = 0; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,ptr,times+1);&#125;int cmp(const void * a, const void * b) &#123; double d = (*((node**)b))-&gt;distance - (*((node**)a))-&gt;distance; return d &gt; 0 ? 1 : -1;&#125;double getdis(int x1, int y1, int x2, int y2) &#123; double ret = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); return ret;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Woman decays like this]]></title>
    <url>%2F2018%2F10%2F12%2FWoman-translate%2F</url>
    <content type="text"><![CDATA[一个女人是这样衰老的1When I was twenty, walked around the campus in a vested denim skirt, my face flushed as my mouth open. Now I am thirty, sitting in my office and scolding my subordinates, crulty written on my face, “How can you dare to ask such a silly question before even making a draft?” 二十岁的时候，我穿着一条背心式牛仔裙在校园里走来走去，一说话就脸红。 三十岁的我穿着名牌套装，坐在办公桌前，满脸冷酷地对下属说：“这么愚蠢的问题你也敢问？也不先打个草稿。” 2When I was twenty, the books borrowed from the library were The Complete Works of Shakespeare, Self-portrait of a young artist and Ulysses. Now I am in my thirties, on the bedside table lays The scrects of following the banker, ELLE and A manager’s personal charm. 二十岁的时候，从图书馆借的是《莎士比亚全集》、《一个青年艺术家的自画像》和《尤里西斯》。 三十岁之后，床头摆的是《跟庄密笈》、《ELLE》和《经理人的个人魅力》. 3In the summer of my twenty, met the boy I crushed who was said to be admitted to a graduate school. Dismayed by the progress he had made, my heart torn with grief and my tears droped as it occured to me that it was beyond my whole life to become elegent enough so that he could gave me a glance. After thirty, searching everywhere for a bought MBA. 二十岁的暑假，在家乡的大街上偶遇自己的暗恋对象，听说他考上了研究生，被他的进步所打击，心如刀绞，想到这辈子终于不能出色得让他看我一眼，不禁怅然泪下。 三十岁之后，到处打听那里可以花钱买个MBA. 4In my twenty, indicating my age from time to time, even before they asked. After thirty, find it an odious thing when asked about age. If you do, “have a guess”. 二十岁的时候，随时随地向人透露我的年龄，答得比问的还快。 三十岁之后，最恨别人问年龄，你要是非问不可，你猜啊。 5In my twenty, overwhelmed with the idea to date with boys majoring in sports or arts. After thirty, regard myself then as an idiot. 二十岁的时候，一心想和体育系、美术系的男生约会。 三十岁后，我简直认为自己当年是白痴。 6In my twenty, saw a bookstore and went in, have books there and bought. After thirty, turn a blind eye to bookstores and directly went into the Beauty Salon next door. 二十岁的时候，有书店必须逛，有书必买。 三十岁之后，对书店视而不见，直接去了隔壁的美容院。 7In my twenty, bet on myself that I wasn’t as outdated as defending this place till dead. Live elsewhere. After thirty, run out of my legs for a house in this city that I satisfied and can afford. 二十岁的时候，打赌说我这辈子不可能土到死守在一个地方，生活在别处嘛。 三十岁之后，我为了在这座城市买个满意又便宜的房子跑断了双腿. 8In my twenty, went to a movie with someone at night. Hand in hand without conscious which made me happy for a whole summer. After thirty, sitting in the revolving restaurant of Shangri-La Hotel to accompany clients and eat self help meals. As the restaurant rotates slowly, I feels an unknow inanity and suddenly grows boring toward the whole world. 二十岁的时候，和某个人晚上一起去看了场电影，不经意中拉了一次手，结果幸福了整整一个夏天。 三十岁之后，坐在香格里拉酒店的旋转餐厅陪客户吃自主助餐，在缓缓的转动之中，莫名其妙地一阵空虚，突然间对一切感到索然无味 Acknowledgement 周可, my handsome roommate who inspired me to translate this passage that moved me so much.]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-11 关键活动]]></title>
    <url>%2F2018%2F09%2F19%2FDS-7-11%2F</url>
    <content type="text"><![CDATA[进展 题目是什么意思啊？我一开始以为是最小生成树，后来觉得是dijkstra,现在我已经弄不清楚了。 有向图 需要判断是不是有回路 好吧，似乎是拓扑排序…. 预备知识 AOV网络(Activity on Vertex) Top拓扑序:若v-&gt;w 则v先输出 拓扑排序：AOV若有合理的拓扑序(无环)，则必定是有向无环图(DAG, Directed Acyclic Graph) 关键路径问题：AOE网络(Activity on Edge) 题目描述原题在这 思路难点体会与感想 好累啊，好想哭啊 刷OJ最难受的事情就是要求太多的输出格式 一道题卡了两天的感受实在是太难受了 学习的过程绝对的连续的 一旦你停止在一件事情上花时间，他马上就会给你颜色看关键代码 7-11.cpp]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构1 两个有序链表序列的合并]]></title>
    <url>%2F2018%2F09%2F14%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841%2F</url>
    <content type="text"><![CDATA[感想 写程序题实在是太麻烦了 好久没用malloc了，连头指针和头结点都分不清楚了。 使用头结点可以很方便地解决很多的问题 源代码123456789101112131415161718192021222324252627282930List Merge( List L1, List L2 )&#123; List head = (List)malloc(sizeof(struct Node)); PtrToNode current = head; PtrToNode ptr1 = L1-&gt;Next; PtrToNode ptr2 = L2-&gt;Next; while (1) &#123; if (!ptr1) &#123; current-&gt;Next = ptr2; break; &#125; if (!ptr2) &#123; current-&gt;Next = ptr1; break; &#125; if (ptr1-&gt;Data &lt; ptr2-&gt;Data) &#123; current-&gt;Next = ptr1; current = ptr1; ptr1 = ptr1-&gt;Next; &#125;else&#123; current-&gt;Next = ptr2; current = ptr2; ptr2 = ptr2-&gt;Next; &#125; &#125; L1-&gt;Next = NULL; L2-&gt;Next = NULL; return head;&#125; 顺便把二分查找的代码也贴上来12345678910111213Position BinarySearch( List L, ElementType X )&#123; int start = 1, end = L-&gt;Last, mid; while (start&lt;=end) &#123; mid = (start + end) / 2; if (L-&gt;Data[mid]&lt;X) &#123; start = mid + 1; &#125;else if (L-&gt;Data[mid]&gt;X) &#123; end = mid - 1; &#125;else if (L-&gt;Data[mid]==X) return mid; &#125; return NotFound;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-树2 List Leaves]]></title>
    <url>%2F2018%2F09%2F14%2FDS-03-%E6%A0%912%2F</url>
    <content type="text"><![CDATA[thoughts 重要的细节，也是全部写完之后发现的唯一一个错误：char的数字向int装换的时候要-‘0’； 实现细节，就是给每一个节点一个完全二叉树时的序号，然后sort qsort的具体使用细节 参数表：qsort(void *, num, sizeof(), cmp) cmp的参数：int cmp(const void front, const void rear)，不可以自己改 return的参数：返回正数就是说 cmp 传入参数第一个要放在第二个后面, 负数就是传入参数第一个要放第二个前面, 如果是 0, 那就无所谓谁前谁后. ‘’+’’ 需要swap ‘’-‘’ 不要交换 int cmp(const void small, const void big) return small - big 从小到大 codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;struct node &#123; int data; bool leaf; unsigned int pos; char left; char right;&#125;;int readtree(node * tree, int n, int * num);void attachweight(node * tree, int ptr, int weight);void printleaf(node * tree, int n);int cmp(const void * front, const void * rear);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n;cin &gt;&gt; n; node * tree = new node [n]; int leafnum = 0; int head = readtree(tree,n,&amp;leafnum); //cout &lt;&lt; head; attachweight(tree,head,1); //cout &lt;&lt; "attach done"; qsort(tree,n,sizeof(node),cmp); //cout &lt;&lt; "sorted"; printleaf(tree,leafnum); delete [] tree; return 0;&#125;void printleaf(node * tree, int n) &#123; int cnt = 0; for (int i = 0; true; i++) &#123; if (tree[i].leaf) &#123; cout &lt;&lt; tree[i].data; ++cnt; if (cnt!=n) &#123; cout &lt;&lt; ' '; &#125;else return; &#125; &#125;&#125;int cmp(const void * front, const void * rear) &#123; int ret = ((node*)front)-&gt;pos - ((node*)rear)-&gt;pos; return ret;&#125;void attachweight(node * tree, int ptr, int weight) &#123; tree[ptr].pos = weight; if (tree[ptr].left!='-') &#123; attachweight(tree,tree[ptr].left-'0',2*weight); &#125; if (tree[ptr].right!='-') &#123; attachweight(tree,tree[ptr].right-'0',2*weight+1); &#125;&#125;int readtree(node * tree, int n, int * num) &#123; bool * ishead = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; ishead[i] = true; &#125; for (int i = 0; i &lt; n; i++) &#123; tree[i].data = i; tree[i].leaf = true; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; if (tree[i].left!='-') &#123; tree[i].leaf = false; ishead[tree[i].left-'0'] = false; &#125; if (tree[i].right!='-') &#123; tree[i].leaf = false; ishead[tree[i].right-'0'] = false; &#125; if (tree[i].leaf) &#123; (*num)++; &#125; &#125; int head = 0; for (int i = 0; i &lt; n; i++) &#123; if (ishead[i]==true) &#123; head = i; break; &#125; &#125; delete [] ishead; return head;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构4 Pop Sequence]]></title>
    <url>%2F2018%2F09%2F14%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844%2F</url>
    <content type="text"><![CDATA[thoughts too simple: just stack simulation 这一次真的是爽啊，一次性过，代码简洁没有任何冗余的边界调试 这样的题目是可遇而不可求啊！ 我用树和用图也要达到我用堆的这样的境界！ codes12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;bool check(int m, int n);int main(int argc, char const *argv[]) &#123; int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; bool valid = check(m,n); if (valid) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125;bool check(int m, int n) &#123; int * stack = new int [n], stk = -1; int * store = new int [n], str = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; store[i]; &#125; bool valid = false; for (int topush = 1; topush &lt;= n; topush++) &#123; stack[++stk] = topush; if (stk==m) break; while (stk!=-1 &amp;&amp; store[str]==stack[stk]) &#123; stk--;str++; &#125; &#125; if (stk==-1) valid = true; delete [] stack; return valid;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构3 Reversing Linked List]]></title>
    <url>%2F2018%2F09%2F12%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843%2F</url>
    <content type="text"><![CDATA[进展 时间 进展 2018年9月12日中午 到目前为止还有两个测试点没过一个是全部反转，我测试的时候是对的呀；还有一个是超时 2018年9月13日21:02:58 AC 难点 容易想到一些歪门邪道，比如说我第一次想到的排序方法。 模拟内存的想法。 具体进行逆转的时候的操作 反思 做OJ的题目有一些注意事项是你不得不放在心上的 边界条件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;iomanip&gt;#define max 100005using namespace std;struct node &#123; int ads; int data; int next;&#125;;node memory[max];int getlength(node * head);node * reverse(node * head, int k);void print(node * head, int length);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int ads, n, k;cin &gt;&gt; ads &gt;&gt; n &gt;&gt; k; int address, data, next; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; memory[address].ads = address; memory[address].data = data; memory[address].next = next; &#125; node head, *headptr; head.next = ads; headptr = &amp;head; int length = getlength(headptr); for (size_t i = k; i &lt;= length; i+=k) &#123; int front = headptr-&gt;next; headptr-&gt;next = reverse(headptr,k)-&gt;ads; headptr = &amp;memory[front]; //print(&amp;head,length);cout &lt;&lt; endl; &#125; headptr = &amp;head; print(headptr,length); return 0;&#125;node * reverse(node * head, int k) &#123; node * front = &amp;memory[head-&gt;next]; node * rear = &amp;memory[front-&gt;next]; node * temp; int cnt = 1; while (cnt&lt;k) &#123; temp = &amp;memory[rear-&gt;next]; rear-&gt;next = front-&gt;ads; front = rear; rear = temp; cnt++; &#125; memory[head-&gt;next].next = rear-&gt;ads; return front;&#125;int getlength(node * head) &#123; int cnt = 0, adds = head-&gt;next; while (adds!=-1) &#123; cnt++; adds = memory[adds].next; &#125; return cnt;&#125;void print(node * head, int length) &#123; node * ptr = &amp;memory[head-&gt;next]; for (size_t i = 0; i &lt; length; i++) &#123; cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;ads; cout &lt;&lt; ' ' &lt;&lt; ptr-&gt;data &lt;&lt; ' '; if ( i==length-1 ) cout &lt;&lt; "-1"; else cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;next &lt;&lt; endl; ptr = &amp;memory[ptr-&gt;next]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-复杂度2 Maximum Subsequence Sum]]></title>
    <url>%2F2018%2F09%2F12%2FDS-01-%E5%A4%8D%E6%9D%82%E5%BA%A62%2F</url>
    <content type="text"><![CDATA[主要做的几个改动 引入track变量来控制ij的记录时间点 修补了maxsum=0的一个小bug 反思 好好看清楚题目再做很重要，不要觉得自己做过一遍就有多懂了，还不是花了2h多吗，看看清楚要输出序号还是要输出值。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-10 公路村村通]]></title>
    <url>%2F2018%2F08%2F24%2FDS-7-10%2F</url>
    <content type="text"><![CDATA[预备知识 最小生成树(Minimum Spanning Tree) 是一棵树 是由原图生成的 包含图内的所有的顶点 所有的边都是图中的边 权最小 图连通 等价 存在最小生成树 贪心算法 每一步都要眼前最好的 约束条件 Prim算法-让小数长大 算法复杂度 平方级别 稠密图 Kruskal算法-将森林合并成树 算法复杂度 ElogE 稀疏图 需要储备的数据结构：集合、并查集、最小堆 集合存储实现： 树结构：双亲表示法 孩子指向父节点 数组： 根节点为-1 堆是用数组实现的完全二叉树题目描述(更新)原题在这 思路Prim算法，日后再实现Kruskal算法 难点Prim算法的实现 体会与感想 Prim算法简直了，和Dijkstra算法一模一样 好tm烦啊 关键代码 7-10-Prim.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int Prim(int ** G, int n) &#123; bool * collected = new bool [n]; int * dist = new int [n], mincost = 0; for (int i = 0; i &lt; n; i++) &#123; collected[i] = false; dist[i] = inf; &#125; collected[0] = true; dist[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (G[0][i]&lt;dist[i]) &#123; dist[i] = G[0][i]; &#125; &#125; while (true) &#123; bool found = false; int min = inf, v = 0; for (int i = 1; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]&lt;min) &#123; found = true; min = dist[i]; v = i; &#125; &#125; if (!found) &#123; break; &#125; mincost += min; collected[v] = true; dist[v] = 0; // for every node w linking to the node v for (int w = 0; w &lt; n; w++) &#123; if (G[v][w]!=inf &amp;&amp; !collected[w]) &#123; if (G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (collected[i]==false) &#123; return -1; &#125; &#125; return mincost;&#125;]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训日记]]></title>
    <url>%2F2018%2F08%2F23%2FMilitaryTrainning%2F</url>
    <content type="text"><![CDATA[8月23日8月24日今天上午的训练结束之前连长组织了会操，我觉得自己的口令下的没什么毛病，同学们做的也都很好，可是没有被表扬。可能是走的时候排面还是没有标齐。 8月26日昨天晚上忘记知米背单词的打卡了，今天早上才发现，心里好难受。 今天上午还是下雨，我们班的进度我感觉已经十分落后了。大家正步走的时候分解动作都不稳。 下午教唱歌：打靶归来、有我在、军中绿花。 下午主攻正步走和跑步走的连贯练习。 先是正步走的臂腿结合一步两动的练习 8月27日哈哈哈昨晚拉练。 很开心，现在只记得前面的连是3连，后面的连是八连，走到凯旋门之前我们一直在疯狂拉歌。拍完照之后前后连队距离都比较大，也就没有再拉歌了。 记一下一件我认为是宝贵教训的一次经历：过了凯旋门的那一个加油点我居然怂恿梁力佳去女生手里拿了一瓶农夫山泉orz。然后他不要我就背自己包里了。我本来带的两瓶水明明正正好好，结果后半程我就在疯狂喝水，结果到最后还没喝完。 你要的东西会成为你的负担。 想清楚你要什么。 8月29日昨天晚上和7连联谊，玩到熄灯了才猛然惊醒，收拾收拾回宿舍了。 我总是觉得我准备的还不够充分，觉得自己没有买水果，买的士力架发现是辣花生味的。 说实话，联谊，有点累的。 今天下午我原来带的班被拆掉了，负责新的一列，是方阵的队形。 然后下午练跑步走的时候再一次被当场活捉。orz捉奸现场 今天不开连务会，早点休息。好想王宏武…… 8月30日今天一整天都是练方阵，orz，先送上一首分列式进行曲，此乃洗脑神曲也。 然后结束的时候我们营长来验收，我们好像把自己走的最差的一次展现给了营长看…. 从（1，4）的位置调到了（9,1）的位置，很舒服，能直接看到标兵，就是标齐感觉有些困难。 连着两天内务满分，嘤嘤嘤，我们好强。 加油，所有的一切终将消失，好好珍惜剩下的仅剩4天的训练时间吧！ 8月31日今天还是在练无聊的方阵。中途被连长T出去休息了好一会，最后又被连长调上第一列了orz 求无聊的日子快点结束吧！ 9月1日今天早上醒来发现手机开不了，悲剧。昨天夜间不就是设置了一个夜间更新然后今早起来就爆掉了。 上午去胡法光体育场练了三遍，踢的乱七八糟、一塌糊涂。 在等手机开了之后去取周可的杯子。 9月3日军训明天就结束了，看了一遍《悟空》，真的很难说再见。 王宏武说这会是一个难忘的军训，确实，真的很难忘。 我该怎样去告别这一段岁月。 这一敬，你我命运相交。 别人穿上军装就是这么好看，而为什么穿在自己的身上却觉得没那么好看了呢？ 昨晚的军训晚会坐在了很偏的位置，只能听到下面女生的尖叫声，和舞台上不停变幻着的刺眼灯光。]]></content>
      <categories>
        <category>军训</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-9 旅游规划]]></title>
    <url>%2F2018%2F08%2F17%2FDS-7-9%2F</url>
    <content type="text"><![CDATA[预备知识 Floyd算法：复杂度 V^3 重要前提：一步一步向后推的 三重循环，每次从DK 归纳推理到 DK+1 其中DK是只经过编号为i（i&lt;K）时各个点对间的最短路 Dijkstra算法: 复杂度最高 V^2+E 这就是运行超时和答案正确之间的区别 题目描述原题在这 思路原先想着用Floyd算法去做的，写完发现有一个测试点运行超时了，无奈只好回到了Dijkstra算法，思路基本一致，唯一的不同点就是图换成了邻接矩阵表示，同时还多了一个fee的权需要检测。 难点不能用Floyd，本题实质是单源有权图的最短路问题（从s到d）。 体会与感想 stray ‘\357’ in program```出现此类错误的原因，在编辑器中使用的utf-8的格式保存源代码中出现了中文的标点符号。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 关键代码&gt;7-9-Floyd.cpp```C++#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);void Floyd(int ** G, int n, int ** cost);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\SJTU\\Freshman Summer\\DS\\test.txt&quot;, &quot;r&quot;, stdin); int n, m, s, d, ** cost = NULL; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); Floyd(G,n,cost); int length = G[s][d]; int fee = cost[s][d]; cout &lt;&lt; length &lt;&lt; &apos; &apos; &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;void Floyd(int ** G, int n, int ** cost) &#123; for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (G[i][j] &gt; G[i][k]+G[k][j]) &#123; G[i][j] = G[i][k] + G[k][j]; cost[i][j] = cost[i][k] + cost[k][j]; &#125; else if (G[i][j] == G[i][k]+G[k][j]) &#123; if (cost[i][j] &gt; cost[i][k] + cost[k][j]) &#123; cost[i][j] = cost[i][k] + cost[k][j]; &#125; &#125; &#125; &#125; &#125;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125; 7-9-Dijkstra.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n, m, s, d, ** cost = NULL, fee; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); int length = Dijkstra(G,n,s,d,cost,&amp;fee); cout &lt;&lt; length &lt;&lt; ' ' &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend)&#123; int * dist = new int [n]; int * fee = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; fee[i] = inf; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; for (int i = 0; i &lt; n; i++) &#123; if(!collected[i] &amp;&amp; G[s][i]!=inf) &#123; dist[i] = G[s][i]; fee[i] = cost[s][i]; &#125; &#125; int v = -1; while (true) &#123; int min = inf; v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (v==d || v==-1) break; collected[v] = true; for (int w = 0; w &lt; n; w++) &#123; if(!collected[w] &amp;&amp; G[v][w]!=inf) &#123; if (dist[v]+G[v][w]&lt;dist[w]) &#123; dist[w] = dist[v] + G[v][w]; fee[w] = fee[v] + cost[v][w]; &#125;else if (dist[v]+G[v][w]==dist[w]) &#123; if (fee[w] &gt; fee[v] + cost[v][w]) &#123; fee[w] = fee[v] + cost[v][w]; &#125; &#125; &#125; &#125; &#125; int ret = dist[v]; *spend = fee[v]; delete [] dist; delete [] fee; delete [] collected; return ret;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125;]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-8 哈利·波特的考试]]></title>
    <url>%2F2018%2F08%2F17%2FDS-7-8%2F</url>
    <content type="text"><![CDATA[预备知识 最短路径问题的分类： 单源最短路：从固定的源点出发求其到所有其他顶点的最短路径 无权图 BFS算法 有权图 Dijkstra 多源最短路 无权图的单源最短路算法：BFS算法 按照递增的顺序找出找出源点到各个顶点的最短路 算法要点：需要两个数组dist和path分别记录最短距离和上一个顶点 有权图的单源最短路算法：Dijkstra算法 分为已经确定最短路的集合S以及一个长度数组dist 实现原理：若路径是按照递增顺序生成的，则： 下一个加入S的点必定只经过S内的点（不然不是S内的点应该比当前点先加入S） 每次选一个dist最小的加入S（贪心算法） 加入点后会影响dist，影响的都是加入点的邻接点 算法实现要点： 需要dist、path和collected数组分别记录最短距离、上一个节点以及是否被收入S的信息 初始化条件：dist都为无穷大，path都没有，collect全不是 123dist[i] = inf;path[i] = -1;collected[i] = false; 修改源点的数据，进入Dijkstra函数 题目描述原题在这给定一张有权图，判断是否连通，若连通，则求使从一个顶点出发最长的最短路最短的那个节点。 思路Dijsktra算法对每一个节点使用 难点Dijsktra算法实现 体会与感想 这个金光闪闪的算法一定要记在脑子里啊~ 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int Dijkstra(node * G, int n, int s)&#123; int * dist = new int [n]; int * path = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; path[i] = -1; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; node * ptr = G[s].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[s]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[s] + ptr-&gt;weight; path[w] = s; &#125; &#125; ptr = ptr-&gt;next; &#125; while (true) &#123; int min = inf, v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (min==inf || v&lt;0) break; collected[v] = true; node * ptr = G[v].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[v]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[v] + ptr-&gt;weight; path[w] = v; &#125; &#125; ptr = ptr-&gt;next; &#125; &#125; int min = -1; for (int i = 0; i &lt; n; i++) &#123; if (dist[i]==inf) return -1; if (dist[i]&gt;min) min = dist[i]; &#125; delete [] dist; delete [] path; delete [] collected; return min;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-7 六度空间]]></title>
    <url>%2F2018%2F08%2F15%2FDS-7-7%2F</url>
    <content type="text"><![CDATA[预备知识 六度空间理论：社交关系图中，任一两个节点总可以在六步之内相互关联。 题目描述用深度优先搜索一幅图的每一个节点相对于其他所有节点满足六度空间理论的百分率。 思路用上次写的邻接表表示的图，基本没什么多的操作，就是控制一下BFS的层数就结束了。 难点没有难点 体会与感想 在Clion中调试的时候，想看new出来的一片连续空间时，需要在new watch中添加命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175- c++想要控制输出固定位小数时，先用fixed固定好小数点，在用setprecesion控制保留几位小数- setprecesion本来是用来控制有效数字的# 源代码```C++#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);int BFSvalid(node * G, int i, int n);void deleteGraph(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\SJTU\\Freshman Summer\\DS\\test.txt&quot;, &quot;r&quot;, stdin); int n, m;cin &gt;&gt; n &gt;&gt; m; node * G = createGraph(n); readGraph(G,m); for (int i = 0; i &lt; n; i++) &#123; int valid = BFSvalid(G,i,n); double percentage = valid / (double)n; cout &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 100 * percentage; cout &lt;&lt; &apos;%&apos; &lt;&lt; endl; &#125; deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited, int * cnt) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); (*cnt)++; visited[min] = true; &#125;&#125;int BFSvalid(node * G, int start, int n) &#123; //return the number of valid nodes Queue * q = creatQueue(n); //of the BFS of node i bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; int cnt = 1, degree = 6; enQueue(q,start); visited[start] = true; int sentry = q-&gt;tail; while (q-&gt;head!=q-&gt;tail+1 &amp;&amp; degree&gt;0) &#123; while (q-&gt;head!=sentry+1) &#123; int popelement = deQueue(q); push(q,&amp;G[popelement],visited,&amp;cnt); &#125; sentry = q-&gt;tail; degree--; &#125; delete [] visited; deleteQueue(q); return cnt;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi-1, vj-1); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-6 列出连通集]]></title>
    <url>%2F2018%2F08%2F14%2FDS-7-6%2F</url>
    <content type="text"><![CDATA[预备知识 图 多对多的关系 无向边（u v） 有向边 线性表 一对一 树 一对多 抽象数据类型定义的三要 类型名称 数据对象集 操作集 网络 带权重的图 图的表示方法取决于你要解决的具体问题 DFS 深度优先搜索 出栈 DFS 时间复杂度取决于图的表示方法 领接表 O(N+E) 邻接矩阵 O(N^2) BFS 广度优先 DFS BFS 复杂度相同 广优的话，占内存多，能找到最优解，必须遍历所有分枝. 广优的一个应用就是迪科斯彻单元最短路径算法. 深优的话，占内存少，能找到最优解（一定条件下），但能很快找到接近解（优点），可能不必遍历所有分枝（也就是速度快）, 深优的一个应用就是连连看游戏. 连通分量 一次DFS 遍历了一个连通分量 题目描述分别用深度优先搜索和广度优先搜索遍历一幅图的所有节点。 思路首先就是考虑这个图该用领接表还是邻接矩阵来表示，后来在码代码的过程中发现确实是邻接矩阵方便的多，不用findmin函数。但我没用过邻接表，这次练习一下。 难点基本没有难点 体会与感想 大工程绝对不要企图用一个.cpp文件就想写完，太天真了。 果然写的太长了是因为我太菜了嘛 半天200行的效率 反复传图指针很难受 还没来得及看视频 源代码 这次的代码比较长，放一个文件里也比较乱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;iostream&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);void DFSlistComponents(node * G, int n);void deleteGraph(node * G, int n);void BFSlistComponents(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n, e;cin &gt;&gt; n &gt;&gt; e; node * G = createGraph(n); readGraph(G,e); DFSlistComponents(G,n); BFSlistComponents(G,n); deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); visited[min] = true; &#125;&#125;void BFSlistComponents(node * G, int n) &#123; Queue * q = creatQueue(n); bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i]) &#123; cout &lt;&lt; "&#123; "; enQueue(q,i); visited[i] = true; while (q-&gt;head!=q-&gt;tail+1) &#123; int popelement = deQueue(q); cout &lt;&lt; popelement &lt;&lt;" "; push(q,&amp;G[popelement],visited); &#125; cout &lt;&lt; '&#125;' &lt;&lt; endl; &#125; &#125; delete [] visited; deleteQueue(q);&#125;void DFS(node * G, int i, bool * visited) &#123; while (remains(&amp;G[i],visited)) &#123; int min = findMin(&amp;G[i],visited); if (min==-1) return; cout &lt;&lt; min &lt;&lt;" "; visited[min] = true; DFS(G,min,visited); &#125;&#125;void DFSlistComponents(node * G, int n) &#123; bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (visited[i]) continue; cout &lt;&lt; "&#123; "; if (!visited[i]) &#123; cout &lt;&lt; i &lt;&lt;" "; visited[i] = true; DFS(G,i,visited); &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl; &#125; delete [] visited;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi, vj); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自搭梯子翻越GFW]]></title>
    <url>%2F2018%2F08%2F12%2FGFW%2F</url>
    <content type="text"><![CDATA[主要借鉴 十分钟搭建自己的科学上网SSR梯子非常感谢！ 思路 首先你得先租借好专用的VPS，推荐的有Digitalocean和Vultr 我先是试了试Singapore的服务器发现很慢，于是换了LA的，爽的不行。 然后就是在登陆服务器之后通过rrsmu.sh脚本安装ShadowsocksR 最后在自己的客户端装上SSR 奇迹就这样发生了]]></content>
  </entry>
  <entry>
    <title><![CDATA[7-4 是否同一棵二叉搜索树]]></title>
    <url>%2F2018%2F08%2F12%2FDS-7-4%2F</url>
    <content type="text"><![CDATA[题目描述判断给定的插入序列是否构成同一棵二叉搜索树 （二叉搜索树：所有左子树元素都小于自身，所有右子树元素都大于自身） 输入12345678984 23 1 4 23 4 1 23 2 4 12 12 11 20 输出123YesNoNo 思路判断数列的奇淫技巧，测试点1过不了。 哈哈现在我的奇淫技巧过了。 更新了根据即将插入的根进行判断。 难点选择比较的方法以及原始数据和比较数据的储存形式 体会与感想自己写的代码多看几遍总归是能看懂的，理清楚的。 还有很想说的是cmake不支持中文以及文件名中的空格，以后再也不用中文了。 真的，实在是..所有中文一律乱码 看了视频之后再写真的是畅通无比，一次提交直接AC。 膜递归… 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;void comparetree(int n, int l);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); while (true) &#123; int n;cin&gt;&gt;n; if (n==0) break; int l;cin&gt;&gt;l; comparetree(n,l); &#125; return 0;&#125;void print(bool same)&#123; switch (same) &#123; case true: cout &lt;&lt; "Yes" &lt;&lt; endl;break; case false:cout &lt;&lt; "No" &lt;&lt; endl;break; &#125;&#125;void comparetree(int n, int l)&#123; int * src = new int [n]; //src--the original array int * select = new int [n]; //select 0--&gt;not added to the cmp tree for (size_t i = 0; i &lt; n; i++) cin &gt;&gt; src[i]; //select 1--&gt;added to the cmp tree int * cmp = new int [n]; for (size_t i = 0; i &lt; l; i++) &#123; bool same = true; for (size_t i = 0; i &lt; n; i++) &#123;cin &gt;&gt; cmp[i];select[i]=0;&#125; if (src[0]!=cmp[0]) &#123; //judge the head same = false; print(same); continue; &#125;else select[0] = 1; for (size_t i = 1; i &lt; n &amp;&amp; same; i++) &#123; //i--indecate the cmp node int rootcmp = src[0]; for (size_t k = 1; k &lt; n; k++) &#123; if (src[k]&gt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&gt;rootcmp) &#123; rootcmp = src[k]; &#125;else if (src[k]&lt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&lt;rootcmp) &#123; rootcmp = src[k]; &#125; &#125; for (size_t j = 1; j &lt; n; j++) &#123; if (select[j]==1) continue; if (cmp[i]==src[j]) &#123; select[j] = 1; break; &#125; int rootsrc = src[0]; for (size_t k = 1; k &lt; j; k++) &#123; if (src[k]&gt;rootsrc&amp;&amp;src[j]&gt;rootsrc) &#123; rootsrc = src[k]; &#125;else if (src[k]&lt;rootsrc&amp;&amp;src[j]&lt;rootsrc) &#123; rootsrc = src[k]; &#125; &#125; if (rootcmp==rootsrc) &#123; if (cmp[i]&gt;rootcmp&amp;&amp;src[j]&gt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; if (cmp[i]&lt;rootcmp&amp;&amp;src[j]&lt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; &#125; &#125; &#125; if (same) print(same); &#125;&#125; 顺便再贴一下看了视频之后的源码结构更加清晰 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;struct node &#123; int value; node * left; node * right; int select;&#125;;node * maketree(int n);void deletetree(node * tree);bool treecmp(node * tree, int n);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n;cin &gt;&gt; n; while (n) &#123; int l;cin &gt;&gt; l; node * tree = maketree(n); for (int i = 0; i &lt; l; i++) &#123; if (treecmp(tree,n)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; deletetree(tree); cin &gt;&gt; n; &#125; return 0;&#125;bool check(node * tree, int v)&#123; if (!tree) return false; if (tree-&gt;value==v) &#123; tree-&gt;select = 1; return true; &#125; if (tree-&gt;select==0) &#123; return false; &#125; if (tree-&gt;value&gt;v) &#123; return check(tree-&gt;left,v); &#125;else&#123; return check(tree-&gt;right,v); &#125;&#125;void settree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) settree(tree-&gt;left) ; if (tree-&gt;right) settree(tree-&gt;right); tree-&gt;select = 0;&#125;bool treecmp(node * tree, int n)&#123; settree(tree); int v; bool ret = true; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v; if (!check(tree,v)) ret = false; &#125; return ret;&#125;void deletetree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) deletetree(tree-&gt;left) ; if (tree-&gt;right) deletetree(tree-&gt;right); delete tree;&#125;node * newnode(int value)&#123; node * treenode = new node; treenode-&gt;left = NULL ; treenode-&gt;right = NULL ; treenode-&gt;value = value ; treenode-&gt;select = 0 ; return treenode;&#125;node * attachnode(node * tree, int value)&#123; if (!tree) &#123; return newnode(value); &#125;else&#123; if (tree-&gt;value&gt;value) tree-&gt;left = attachnode(tree-&gt;left ,value); else tree-&gt;right= attachnode(tree-&gt;right,value); return tree; &#125;&#125;node * maketree(int n)&#123; int value; node * tree = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; tree = attachnode(tree,value); &#125; return tree;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-3 树的同构]]></title>
    <url>%2F2018%2F08%2F11%2FDS-7-3%2F</url>
    <content type="text"><![CDATA[题目描述判断给出的两棵树是否是同构的（同构-即左右子树可以相互交换位置） 输入1234567891011121314151617188A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 - 输出1Yes 思路刚开始听了MOOC上说用静态链表（简单来说就是数组，只不过每个元素带有指针效果的元素）后这么想的：读入需要两个inArray，再根据这两个Array构造两个满二叉树的char型数组，然后用递归写一个cmp在满二叉树的char型数组上比较。实在太麻烦了。 然后就用了MOOC上的方法。搞了全局变量，简直不要太舒服。 最后一个边界条件（n=0）引起的段错误调的我ooxx 难点怎么组织你的数据，就像老师讲的： 你打算怎么储存两棵树 怎么找到根节点（这个简单） 怎么比较同构1和3我现在都还是无法驾驭。1是熟练掌握数据结构的应用，3是写递归程序。 体会与感想深深地体会到了大神的代码和我自己的代码之间的区别（100+行都写不完和60行AC的差距）orz 当你函数的参数≥四个并且还是在反复传同一个参数的时候，你就该想想你的思路是不是不太对了。 有时候全局变量该用就得用，否则到时候难受的是你自己。 main函数里东西越少越好，代码质量越高，可读性越好。 递归函数感觉还是比较虚，边界条件有时理不清。 尽可能地检查边界条件（极小与极大）。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#define max 10#define null -1using namespace std;struct node &#123; char element; int left; int right;&#125;tree1[max], tree2[max];int build(node * tree);bool isomorphic(int r1, int r2);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int r1 = 0, r2 = 0; r1 = build(tree1); r2 = build(tree2); if (r1!=-1 &amp;&amp; r2!=-1) &#123; if (isomorphic(r1,r2)) cout &lt;&lt; "Yes"; else cout &lt;&lt; "No"; &#125;else if (r1==-1 &amp;&amp; r2==-1) &#123; cout &lt;&lt; "Yes"; &#125;else cout &lt;&lt; "No"; return 0;&#125;bool isomorphic(int r1, int r2)&#123; if (r1==null &amp;&amp; r2==null) return true; if (r1==null || r2==null) return false; int n1 = 0, n2 = 0; if (tree1[r1].left==null) n1++; if (tree1[r1].right==null) n1++; if (tree2[r2].left==null) n2++; if (tree2[r2].right==null) n2++; if (n1!=n2) return false; if (tree1[r1].element!=tree2[r2].element) return false; if (n1==2) return true; else if (n1==1) &#123; if (tree1[r1].left==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].right); &#125; else if (tree1[r1].left==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].left); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].right); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].left); &#125; &#125; else if (n1==0) &#123; if (tree1[tree1[r1].left].element==tree2[tree2[r2].left].element) &#123; return isomorphic(tree1[r1].left,tree2[r2].left) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].right); &#125;else&#123; return isomorphic(tree1[r1].left,tree2[r2].right) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].left); &#125; &#125; return true;&#125;int build(node * tree)&#123; int n;cin &gt;&gt; n; if (n==0) return -1; int * select = new int [n]; char le, ri; for (int i = 0; i &lt; n; i++) select[i] = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tree[i].element &gt;&gt; le &gt;&gt; ri; if (le!='-') &#123; tree[i].left = le - '0'; select[tree[i].left] = 1; &#125;else tree[i].left = null; if (ri!='-') &#123; tree[i].right = ri - '0'; select[tree[i].right] = 1; &#125;else tree[i].right = null; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (select[i]==0) &#123; ret = i; break; &#125; &#125; delete [] select; return ret;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编程艺术读后感]]></title>
    <url>%2F2018%2F08%2F02%2Fjsdom%2F</url>
    <content type="text"><![CDATA[关于本书知乎上不知道是看了谁的推荐找到的这本书，从上周五放假了之后花了一周陆陆续续看完了 感想js感觉和c没什么差别啦最大的感觉就是web规范还有穿透全书的两大主题：平稳退化以及渐进增强 平稳退化：就是你要考虑到当你写的js被禁用的时候网页会变成什么样子。是直接蹦了还是跑样式了还是能勉强浏览。这是作者始终在强调的，可是我觉得现在我是理解无能的。说实话，有点小小抵触这种想法，我学js不就是为了实现那些行为效果吗，可能以后会有更深的理解的。 渐进增强：由底向上编程。了解了web才知道HTML css js这三驾马车，缺一不可。HTML是网站的主体内容，css负责美工上色，js负责网页行为交互。书最后还介绍了Ajax，我是看不懂了。总之看了这本书给我的一个启示就是：我不喜欢js。]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学期结束了，假期开始了]]></title>
    <url>%2F2018%2F07%2F27%2FSummerSemesterEnd%2F</url>
    <content type="text"><![CDATA[离别昨天傍晚阿阳一家就已经接他回江苏了，今早阿可一个人很早就出发了，中午的时候，阿韬的爸妈也来接他回江苏了。寝室里的人一个个地减少，最后，现在只剩下我了。 宿舍里的生气渐渐变少，阳台上晒着的衣服一件件地被不同的人收了进来，带回了家，阳台变得一干二净。上铺的床被搬空，书架上的书被带回了家，书桌被收拾的干干净净。窗外的蝉叫的更响亮了。 离别的气息充斥。 我一个人默默地考完最后一场考试，从东上院走出来。路上没有什么人，整个校园安安静静，仿佛整个世界只剩下闷热的空气。 孤独是一种常态吧，是嘛？ 我曾经不停地希望着中午回到寝室他们能不要吵，让我安安静静地再看一会儿书。 人可真是奇怪的动物，哈哈。 QQ也已经聊得很少了，在学期里明明是不想过多地去了解别人的消息，可是现在却热切地渴望着掌握别人的动态。 起航这个假期我准备干些什么呢？ 我想准备GRE，复习数据结构，看js书，多多做一些家务，多学一些日常本领。 还想预习一下下学期的电学基础课，多看一些文学书。 想保证一个健康的作息。]]></content>
      <tags>
        <tag>Freshman-Summer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-2 一元多项式的乘法与加法运算]]></title>
    <url>%2F2018%2F07%2F18%2FDS-7-2%2F</url>
    <content type="text"><![CDATA[题目描述设计函数分别求两个一元多项式的乘积与和。 输入124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 思路首先要确定多项式的储存结构，决定用链表按照指数递降顺序存储。 接下来无非就是两个难题，一个是怎么加，一个是怎么乘。 难点一开始的时候我乘法用了我现在用的加法算法在一个个向后推，可以说是相当的蠢萌了。 加法标准做法是3个循环搞定，第一轮循环两个链表同时向后推，一个推到最后就把另一个剩下的全接上去就可以了。 乘法有很多种做法，我用了老师讲的插入法。 两轮循环，每一次都要向已有的链表上插入一个新的点，有时需要合并，有时需要删点。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;iostream&gt;using namespace std;const int MAX = 1003;struct node&#123; int coef;//系数 int expo;//指数 node * next;&#125;;node * CreatList(node * head); //单链表的读入与创建void PrintList(node * head); //输出以head为头结点的链表node * MultiplyList(node * p1, node *p2); //多项式乘法void Attach(int coef, int expo, node **nodepointer); //插入一个节点至nodepointer后node * AddList(node * p1, node *p2); //多项式加法void FreeList(node * p); //内存释放int main(int argc, char const *argv[]) &#123; node *head1 = NULL, *head2 = NULL; head1 = CreatList(head1); head2 = CreatList(head2); node *multi = MultiplyList(head1, head2); node *add = AddList(head1, head2); PrintList(multi);cout &lt;&lt; endl; PrintList(add); FreeList(head1);FreeList(head2);FreeList(multi);FreeList(add); return 0;&#125;node * CreatList(node * head)&#123; int coef, expo, k; node * p; head = new node; cin &gt;&gt; k; if ( !k ) return NULL; cin &gt;&gt; coef &gt;&gt; expo; head-&gt;coef = coef; head-&gt;expo = expo; head-&gt;next = NULL; p = head; for (size_t i = 1; i &lt; k; i++) &#123; cin &gt;&gt; coef &gt;&gt; expo; node *temp = new node; p-&gt;next = temp; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = NULL; p = temp; &#125; return head;&#125;void PrintList(node * head)&#123; if ( !head ) &#123; cout &lt;&lt; "0 0"; &#125; while ( head ) &#123; cout &lt;&lt; head-&gt;coef &lt;&lt; " " &lt;&lt; head-&gt;expo; head = head-&gt;next; if ( head ) cout &lt;&lt; " "; &#125;&#125;//by inserting to the right place 2 loopsnode * MultiplyList(node * p1, node *p2)//p is the pointor&#123; //poining to the current node node *head = new node; head-&gt;expo = MAX; head-&gt;next = NULL; while ( p1 ) &#123; node *p = p2; while ( p ) &#123; //PrintList(head-&gt;next); //cout &lt;&lt; endl &lt;&lt; endl; int coef = p1-&gt;coef * p-&gt;coef; int expo = p1-&gt;expo + p-&gt;expo; node *temp = head; while ( true ) &#123; //point to one in front // cout &lt;&lt; "once "; if ( !(temp-&gt;next) || temp-&gt;next-&gt;expo&lt;=expo ) break; temp = temp-&gt;next; &#125; //now temp points to the insert place ahead // cout &lt;&lt; "now expo is " &lt;&lt; expo; // cout &lt;&lt; "my temp-&gt;expo = " &lt;&lt; temp-&gt;expo &lt;&lt; endl; if ( temp-&gt;next &amp;&amp; temp-&gt;next-&gt;expo == expo ) &#123; if ( temp-&gt;next-&gt;coef + coef == 0 ) &#123; //delete node * tobefreed = temp-&gt;next; temp-&gt;next = tobefreed-&gt;next; delete tobefreed; &#125;else &#123; //join together temp-&gt;next-&gt;coef += coef; &#125; &#125;else Attach(coef, expo, &amp;temp); p = p-&gt;next; &#125; p1 = p1-&gt;next; &#125; node * tobedeleted = head; head = head-&gt;next; delete tobedeleted; return head;&#125;void Attach(int coef, int expo, node **nodepointer)&#123; // cout &lt;&lt; "now coef=" &lt;&lt; coef &lt;&lt; " expo=" &lt;&lt; expo &lt;&lt; // " inserted after expo=" &lt;&lt; (*nodepointer)-&gt;expo &lt;&lt; endl; node * temp = new node; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = (*nodepointer)-&gt;next; (*nodepointer)-&gt;next = temp;//here // cout &lt;&lt; "now temp-&gt;next=" &lt;&lt; temp-&gt;next; // cout &lt;&lt; " *nodepointer points to expo" &lt;&lt; (*nodepointer)-&gt;expo;&#125;node * AddList(node * p1, node *p2) //receive 2 pointers and return the AddList&#123; //head is a pointer to the head node node * p, * head; head = new node; //head is a head noder contains p = head; //nothing but a next pointor head-&gt;coef = 0; head-&gt;expo = 0; head-&gt;next = NULL; while ( p1 &amp;&amp; p2 ) &#123; int expo1, expo2; expo1 = p1-&gt;expo; expo2 = p2-&gt;expo; if ( expo1 &gt; expo2 ) &#123;//copy p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125;else if ( expo1 &lt; expo2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125;else &#123; int coef = p1-&gt;coef + p2-&gt;coef; if ( coef ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = coef; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; &#125; while ( p2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125; while ( p1 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125; //cout &lt;&lt; head-&gt;next; p = head; head = head-&gt;next; delete p; return head; // if ( head-&gt;next ) &#123; // &#125;else &#123; // return head; // &#125;&#125;void FreeList(node * p)&#123; node * next; while ( p ) &#123; next = p-&gt;next; delete p; p = p-&gt;next; &#125;&#125;/*程序最后的两个细节问题1- 当加法结果为零时的输出2- 当有一个k为零时的输出*/]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[期末感想]]></title>
    <url>%2F2018%2F06%2F07%2Fdark-time-reflection%2F</url>
    <content type="text"><![CDATA[我曾经一直以为期末挂科是不可能的 现在发现我太天真了It is possible that I am going to fail the 大学物理 量子物理 电路理论就是因为别人不在听，所以我就没有动力去做吗就是因为觉得课程弱智，一点都帮不到我，所以我就一拖再拖，拖到最后就不做吗网络并不是万能的远远不是万能的 他搜索不到钱寅哲的下落 你永远都想不到你连大英都会挂我并不认为自己比别人差我认为把自己在做的事情做到最好就可以了 这只不过是一道坎罢了 坚持下去 跨过去 你就会成长what doesn’t kill you makes you stronger. 为了加分使劲地举手 很令人丢脸吗我的存在对他人的影响 有很大吗 有电脑在手上 就是把自由带在了身边不要把别人想的想你一样浅薄 是什么让我变得平庸 他们从来都没有失败我觉得他们比我自己强多了失败让他们变得更加强大那么我呢失败是否会击败我还是让我变的更加强大呢 成绩难道不是我自己求得的吗只是我自己的随想罢了 我本来很强嘛我觉得思考这些东西很累说实话 让我去思考什么全球化的东西 我一点感想都没有让我对时政发表看法 我一点想法都没有我认为别人会时时刻刻地关注我然而 他们并没有 他们只是关注于自己的事情罢了就像我自己一样我有时候很讨厌说话装逼的人我有时候讨厌那些说大话空话的人我有时候根本就不想说话我有时候想享受大家对我的关心然而却不愿意去主动关心他人 你学到的东西eye contact]]></content>
      <tags>
        <tag>不要放弃 熬过去就行了</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-A-1051]]></title>
    <url>%2F2018%2F05%2F07%2FPAT-A-1051%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Thoughtsjust Stack simulation Long time no code and my coding ability drops significantly. This problem may be rather simple for some one, but it just serve the purpose of revieweing the basic knowledges for me. Sometimes a tiny bug can drive you crazy. No one can come to the final solution at the first glance, but as long as you spend your time on it, it will no doubt seem more ane more clear to you. Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]) &#123; //freopen(&quot;D:\\cpphomework\\test.txt&quot;, &quot;r&quot;, stdin); int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; int **Sequence = new int * [k]; for (size_t i = 0; i &lt; k; i++) Sequence[i] = new int [n]; int *used = new int [n+1], *result = new int [n]; int remaining = m; for (size_t i = 0; i &lt; k; i++) &#123; result[i] = 1; for (size_t j = 0; j &lt; n; j++) &#123; cin &gt;&gt; Sequence[i][j]; &#125; &#125; //prepare for (size_t i = 0; i &lt; k; i++) &#123; remaining = m; for (size_t j = 1; j &lt;= n; j++) used[j]=0; int q = 1, c = 0; //start while ( q&lt;=n &amp;&amp; remaining&gt;0 &amp;&amp; result[i] ) &#123; if ( q==Sequence[i][c] ) &#123; used[q] = 1; while ( c+1&lt;n &amp;&amp; Sequence[i][c+1]&lt;Sequence[i][c] ) &#123; int examine = Sequence[i][c]-1; while ( used[examine]==1 ) examine--; if ( Sequence[i][c+1]==examine ) &#123; used[examine] = 1; remaining++;c++; &#125;else &#123; result[i] = 0;break; &#125; &#125; q++;c++; &#125; else &#123; q++;remaining--; &#125; &#125; if ( q&lt;=n ) &#123; result[i] = 0; &#125; for (size_t j = 1; result[i] &amp;&amp; j &lt;= n; j++) &#123; if ( used[j]!=1 ) &#123; result[j] = 0; break; &#125; &#125; &#125; //output for (size_t i = 0; i &lt; k; i++) &#123; switch ( result[i] ) &#123; case 1: cout &lt;&lt; &quot;YES&quot;;break; case 0: cout &lt;&lt; &quot;NO&quot;;break; &#125; if ( i!=k-1 ) cout &lt;&lt; endl; &#125; //delete for (size_t i = 0; i &lt; k; i++) delete [] Sequence[i]; delete [] Sequence; delete [] used; delete [] result; return 0;&#125;]]></content>
      <tags>
        <tag>PAT-Advanced-Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-04-03]]></title>
    <url>%2F2018%2F04%2F03%2Freflectino%2F</url>
    <content type="text"><![CDATA[我并不是讨厌生活，我只是讨厌现在的自己中午搜了半小时的《向死而生》的当年看过的那篇博客。 然后就发现了，我确实是不会用搜索引擎。 上午的高数课最后一小点儿我没听懂 大物课我也是最后的质心参考系没跟上老师的进度。 我只是想把我在做的每一件事都尽我的可能做到最好，为什么这么简单的要求我还是做不到？昨天两次实验全部做崩。 物理实验线性关系没有做出来 化学实验产率13% 思路一旦没有转过来我就全完蛋 这几天为什么都诸事不顺啊高数做10题能错7题。离散上周的作业都留到了这周才做。思修小组作业没有做。练琴没有时间练。电路理论上了课作业还是不会做。 大学和高中完全不同。 大学可能是玄学。 怎么在巩固好学业的基础上处理学生事务、生活事务。 不要灰心、不要沮丧、坚持、坚持、坚持、坚持、坚持。 黎明前的黑暗是最难熬的。 不要再自我安慰了离散你只是上课去听个课你说你能学好吗？ 就像你只听老师讲c++自己不码代码绝对的挂科。 晚安。 开心一点。 再过几分钟就是全新的一天了。 明天加油。 思修课抱到大腿了超级大的腿 天生的演讲者 不劳而获的愧疚感 不要一直只想着自己 多为别人考虑考虑]]></content>
      <tags>
        <tag>心情日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假见闻]]></title>
    <url>%2F2018%2F02%2F14%2F%E5%AF%92%E5%81%87%E8%A7%81%E9%97%BB%2F</url>
    <content type="text"><![CDATA[这个寒假我干了啥呢？ 日期 事件 5日 去九院看牙齿，得知还不能装上牙套，母生气，徐家汇购物，校医院配药 6日 外婆家，高烧，傍晚五院点滴 7日 科目四，查询报销 8日 无所事事,忘了 9日 blog 10日 收快递，驾照，win7 11日 外婆家， 12日 ？ 13日 外婆，dokidoki cao，全tm记不起来了我一直以为我可以记得很tm清楚的 不得不说，我真的是一个很拖延的人，明明知道有些事是对的事，有些事是错的事，但是我并没有去做那些对的事，也没有改掉那些错的习惯。 离开舒适区，请，求你了。 大年三十又是糟糕的一天 一整天几乎就没干什么事情 在外婆家有一种什么都干不了的感觉 真的好烦。 与其坐以待毙，不如主动出击。 大一暑假假期见闻这个暑假好像很短啊！先是忙小学期，然后稍微修整了十多天军训就轰轰烈烈地开始了，度过了这个难忘的军训之后我抽空和几位舍友一起去南京玩了两天，回来之后就是现在了，开学了，我已经大二了。 首先说说小学期吧。这个小学期我选了三门非常喜欢的课：ICS、大学生健康教育和刑法与生活。真的是学到了很多的东西，虽然最后的成绩都不是很好看，但是回想上课的那四周我真的是完全地投入其中的。哎，期末的时候千万不要太放松，你一放松期末总评就刷刷往下掉，越到期末越是不能放松啊。 虽然这中间的十几天没有参加什么有意思有意义的社会实践，但是不久就开始小班长集训了。大学的军训我是一辈子都不会忘记的，这可能是大家最后一次表现地这么有凝聚力，共同齐心协力只为了一个共同的目标的时光了。我们收获珍贵的情谊，培养过硬的作风，把军人坚韧刚毅果敢的品质内化为自己的内心力量。虽然交大的军训确实是有点水，除了队列练习基本上没有什么别的主要的内容了，体贴学生简直到了放纵的地步，但是最后那几天方阵彩排的那个闷热的上午，我第一次知道我的手臂上居然能沁出如此细密的汗珠，第一次知道汗水流到眼睛里是多么的刺眼睛，第一次感受到汗水顺着腹部流下的奇痒难忍。]]></content>
      <tags>
        <tag>寒假</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinstall my Win7 Ultimate]]></title>
    <url>%2F2018%2F02%2F10%2FWin7-SSD%2F</url>
    <content type="text"><![CDATA[TriggersMy old ThinkPad E430c, which my father bought in about 2012, is operatering more and more slowly nowadays. A few days ago, it even experienced several bruescreens breakups, and it took me a whole morning to just start it. After examing the hard-drive, I found that it was severely damaged, maybe due to the bumping on the road. So last night, I bought a SSD (TOSHIBA Q200 240G) PreparationsAfter searching the Internet for almost a whole day, I decided to still install the Win7 Ultimate. I also learned a lot through searching. :D I finally found a detailed tutorial called xitongcheng. It guided me to turn my original onlydisk into a USB setup disk. What I need now is only a Win7 system now (from msdn). Place the SSD in place and start your computerHere comes a terrible question.What should I do? I googled it and founded the solution. just type in three commands:123find --set-root /bootmgrchainloader /bootmgrboot and it entered the PE system. Then just choose the Win7 Ultimate. It works. install the DRIVERFirst of all, you should make sure that your computer can have access to the Internet. Then everything went on smoothly without explaination. Inflections I don’t want to reinstall any system any longer! It’s really complicated!]]></content>
  </entry>
</search>
