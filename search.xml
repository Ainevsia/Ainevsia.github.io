<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2006混淆C语言大赛-sykes2源码解析]]></title>
    <url>%2F2019%2F04%2F19%2Fsykes2%2F</url>
    <content type="text"><![CDATA[上周六在准备华为网络技术考试的闲暇之余发现了一段超级有趣的代码，出自国际C语言混乱代码大赛。或许你像我一样第一次听说这个比赛，那就摘一段维基百科的介绍： 国际C语言混乱代码大赛（IOCCC, The International Obfuscated C Code Contest）是一项国际程序设计赛事。从1984年开始，本赛事每年举办一次。本赛事的目的是写出最有创意和最让人难以理解的C语言代码。 先看一眼这段小巧玲珑的代码1main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; 运行这段代码看看干了啥123456789$ gcc ioccc.c -o a.out$ ./a.out !! !! !! !!!!!! !!!!!! !!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !! !! !! !! !! !!!! !!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !!!!!! !!!!!! 这段代码居然能够将编译时刻系统时间（非运行程序时间）按照ASCII风格输出，太强了。 说实话，第一次看到这种操作的我感觉已经被秀了一脸了；等我仔细研究完这行代码之后的感觉是：太骚了，代码居然还能这么写！ 接下来准备详细分析这一行小小的代码是如何实现如此炫酷复杂吊炸天的功能的。 全文极度烧脑预警 一些你可能从来没有考虑过的问题何时可以不指明返回类型？正常的main函数声明都是这样的 12345int main(int argc, char * arcgc[])&#123; return 0;&#125; 当然main函数的参数是可以省略的，可以单单写成main()。return 0也是可以省略的，程序会正常终止，只不过会多一条warning。 在实际生产环境中当然不会出现这样的代码，这只是极客们利用c语言的细节追求极简的成果。 甚至，main前面的int声明都可以省略。 Stack Overflow上有讨论这个默认类型声明： 在K&amp;R的经典教材C Programming Language的§6.5.2.1中列举了一些隐含的类型声明：int, signed, signed int 或是没有声明类型这四者是等价的。 所以main前面的int可以省略，参数列表里的int也可以省略，最后就会只剩下代码中的： 1main(_)&#123;&#125; 注意到_是一个变量名，处在原本argc的位置，经过试验发现，其功能就是记录传入的参数个数。当你想我一样使用$ ./a.out不加任何参数调用的时候，其值就是1。 argc is 1; argv[0] is the string “./a.out” argv[1] is a NULL pointer 何时可以不包含头文件？putchar()函数可以不用include头文件。虽然它不是系统函数，但是实测确实可以。 这样我们可以愉快地把这段代码的格式排排好，把省略的声明补齐，顺便加上头函数。 预处理：变得能看1234567#include &lt;stdio.h&gt;int main(int i)&#123; i^448&amp;&amp;main(-~i); putchar(--i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); return 0;&#125; 利用&amp;&amp;的短路求值特性将第一行展开，^亦或运算符仅在i==448时为假，-~i将i取反之后取负数。由于int是使用补码在计算机内部存储的，取负数操作实际上等效于按位取反后加1，-~i等效于i+1。所以可以发现第一行就是一个条件递归。 123456int main(int i)&#123; if (i != 448) main(i+1); i--; putchar(i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); return 0;&#125; 此时需要知道我们在第一次进入main函数的时候i的初始值是1（不加参数的话）。此时需要把之后会对i有操作的–i提取到putchar外面（不然没法转化），这句递归可以转化为循环（非常不直观，需要花点时间好好想想）。 12345int main()&#123; for (int i=447; i&gt;=0; i--) &#123; //由于外层i--的操作，这里从447到0 putchar(i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); &#125;&#125; 要注意i是从447减小到0的，一共执行448次。因为递归调用的时候是从main(1)一直到main(448)。i=448时不再继续递归，但该次main剩下的操作还是要进行。 接下来只有一句putchar了，看来一共会输出448个字符。最后的:10可以知道根据条件输出会有回车LF(ASCII:10)，数一数最开始输出的图形的行数，我们发现有7行，可以猜测一下这个输出回车的条件应该会是与7的倍数有关。但是中间这一行putchar实在太长，我们一点一点看。首先看一看第一个?:运算符的条件 1putchar(i%64?/*some value*/:10); 这时我们突然发现每行的字符448/7=64。于是我们知道了每64个字符会出现一个换行符。 把:?运算符写成if-else形式会更加直观1234567891011int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; putchar(32 | -~7[__TIME__ - i / 8 % 8]["&gt;'txiZ^(~z?" - 48] &gt;&gt; ";;;====~$::199"[i * 2 &amp; 8 | i / 64] / (i &amp; 2 ? 1 : 8) % 8 &amp; 1) &#125; &#125; return 0;&#125; 你看的精疲力尽了吗？哈哈我也写的累了。但是正真巧妙的东西还没有开始呢！ 我们需要花非常大的力气去看看putchar里到底写了什么。 预处理：变得像人写的来看这个输出，发现里面有两个字符串常量，还有移位运算和许多的位运算。这时候我不得不默默地掏出了好久没看的运算符优先级顺序表，给优先级加上括号。一句话就是算数运算优先，然后是移位运算，然后逻辑比较运算，最后位运算。 132|-~7[__TIME__-(i/8%8)]["&gt;'txiZ^(~z?"-48] &gt;&gt; ";;;====~$::199"[(i*2)&amp;8|i/64]/(((i&amp;2)?1:8)%8)&amp;1 所以说上面这一行表达式的运算顺序是32|/*some value*/是最后算的，右边是(一个含有__TIME__宏的大东西 &gt;&gt; 一个字符串一样的东西) &amp;1，这里可以先定义两个本地变量来使最后的结果显得更加清楚。 123456789101112int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char a = -~7[__TIME__-(i/8%8)]["&gt;'txiZ^(~z?"-48]; char b = ";;;====~$::199"[((i*2)&amp;8)|(i/64)]/((i&amp;2)?1:8)%8; putchar(32 | ((a &gt;&gt; b) &amp; 1)); &#125; &#125; return 0;&#125; 然后来处理这一堆方括号，这其中可能又会触及到大家对c语法的一些盲区了。大家都知道a[1]这个表达式是取了数组a中的第二个元素，但是其实还有一种等价的写法是1[a]，大多数人应该基本不会碰到这样的表达式，实在是太……无聊的写法，但是这也向我们揭示了一个关于[]运算符的一个本质，就是a[1] =&gt; *(a + 1)，大家永远不应该忘记[]的实质是在一个指针上偏移一个量再去取出其中的数据。利用这一个知识点，把形如1[a]的表达式中方括号之前的东西的位置换到后面去并加上方括号，我们继续把上面的a和b展开。 前文已经提到过：-~i等效于i+1123456789101112int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char a = ("&gt;'txiZ^(~z?"-48)[(__TIME__-(i/8%8))[7]] + 1; char b = ";;;====~$::199"[((i*2)&amp;8)|(i/64)]/((i&amp;2)?1:8)%8; putchar(32 | ((a &gt;&gt; b) &amp; 1)); &#125; &#125; return 0;&#125; 再引入一个变量t以简化，并且把-48和-(i/8%8)这两个偏移量移动到后面的方括号内去,12char t = __TIME__[7 - i / 8 % 8];char a = "&gt;'txiZ^(~z?"[t - 48] + 1; 我们知道，在&gt;&gt;号右边的应该是一个数来表示位移量，于是我们再引入一个shift变量，并且根据优先级展开b变量，用c表示a&gt;&gt;b。注意到，(i&amp;2)?1:8里还有一个条件判断，把他展开成一个分支语句。 1234567891011121314151617int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char t = __TIME__[7 - i / 8 % 8]; char a = "&gt;'txiZ^(~z?"[t - 48] + 1; char shift = ";;;====~$::199"[(i*2)&amp;8 | i/64]; if ((i&amp;2) == 0) shift /= 8; shift = shift % 8; char c = a &gt;&gt; shift; putchar(32 | c&amp;1); &#125; &#125; return 0;&#125; 写到这里我们先停一下，看上去已经比较像是正常的代码了（误），一些运算符的优先级我们也都已经展开完毕了，好像似乎无法进行简化了，但是程序的逻辑真的是一丝都没有任何的明朗。我们需要从头开始看看整体逻辑。for循环一共执行448次，每64次会换行，这样就会输出7行。不换行的时候会进行一堆判断，最后输出的关键语句是putchar(32 | c&amp;1)，稍微看一下这个逻辑就会发现，32 | c&amp;1只有两个值，要么是32(ASCII 空格)或是33(ASCII !)。这样会给我们真正地深入分析提供思路。 处理：理清逻辑1234567!! !!!!!! !!!!!! !!!!!! !! !!!!!!!! !! !! !! !! !! !! !! !!!! !! !! !! !! !! !! !! !!!! !! !! !! !! !!!! !! !!!!!! !!!!!!!! !! !! !! !! !! !!!! !! !! !! !! !! !!!! !! !!!!!! !!!! !! !!!!!! 再次整理一下我们已经了解的一些信息： 最终输出一共有7行，每行64个字符。不知大家是否对64和代码中出现了很多次的8这两个数字有些许感觉，其实在这里结合我们观察到的图形，我们已经可以大胆地假设：$64=8\times 8$。有人会想这还要你假设，这不是事实吗？我的意思是一行的64个字符可以被均分为8组，每组8个字符。写到这里你再看看上图就知道：冒号其实和数字是同等的地位，这是后话了。这样的话我们就可以把这个$7\times 64$矩形分割成为八个$7\times 8$的小矩形，分别对应小时的两位数字、冒号、分钟的两位数字、冒号秒的两位数字。 这样的话我们就有足够的insight可以着眼于shift这个变量了。 shift 移位变量初探1234char shift = ";;;====~$::199"[ (i*2)&amp;8 | i/64];if ((i&amp;2) == 0) shift /= 8;shift = shift % 8; i/64这是两个整型做除法，所以得到向下取整的整数。不难想象这可以表示行号，在0到6之间，用3个bit就可以表示。 (i*2)&amp;8涉及到了位运算。(i*2)等价于i左移1位，(i*2)&amp;8等价于检测原本i的倒数第3位的情况，只要i = 4, 5, 6, 7 mod 8，这位就是1。 (i*2)&amp;8 | i/64前半部分的结果除了倒数第4位有可能有值，其他位全为0；后半部分只有3个bit，与在一起正好是一个4bit的数。相当于x000|0yyy--&gt;xyyy。 当i = 0, 1, 4, 5 mod 8时，i&amp;2为0，进入if分支，shift将会左移三位。 最后如论如何，shift mod 8后被映射到了0-7上，那么shift就是一个0-7的数。 string1 居然是……到了这个时候你可能会想了，这个shift居然是一个和行号有关的量，我们完全有理由相信shift就是一个用来表示位置的量。这时候我们再回过神来看前面的那个含宏的变量a。在这之前，补充一个必须的知识点，就是__TIME__这个宏是长啥样的。__TIME__会返回一个字符串，用printf(&quot;%s&quot;, __TIME__)会得如下的结果：19:22:18，形如&quot;HH:MM:SS&quot;。 12char t = __TIME__[7 - i / 8 % 8];char a = "&gt;'txiZ^(~z?"[t - 48] + 1; 又是出现了好多的8啊！但是这回你应该可以自己分析出来了，i / 8 % 8得到的是当前位置我应该打印的是什么字符（$7\times 8$的小矩形），用7减是因为i是从448开始减小的，这样随着i的减小，7 - i / 8 % 8可以按照从0到7的顺序反复遍历了。注意到十进制的48在ascii码表中对应的是数字0哦。那样的话，&quot;&gt;&#39;txiZ^(~z?&quot;[t - 48]就相当于根据这一位该显示的数字在字符串&quot;&gt;&#39;txiZ^(~z?&quot;中做选择。 看到这一步，我们该是不知道这个字符串是干嘛用的，但是大家不用慌，我们已经知道t - 48只能在0-9和10（冒号）中取值，我这就给大家来个枚举法，看看到底是什么。 顺便一提，为什么一定要写成&quot;&gt;&#39;txiZ^(~z?&quot;[t - 48] + 1这种+1的形式而不直接写&quot;另一个字符串&quot;[t-48]呢？这是因为~再加1就不是可打印字符了哦，真是挺凑巧的。 0-&gt;10在字符串中做选择后的值的二进制表示如下：12345678910110 001111111 001010002 011101013 011110014 011010105 010110116 010111117 001010018 011111119 01111011: 01000000 请大家在往下翻之前好好的看几眼这个表，看看每个二进制的第一位，特别是8这个数字所对应的二进制，再看看别的二进制。你想到了什么？ …… 现在就是拿出你数字电路水平的时候了。其实这tm就是个7段数码管！你可能会想，这我怎么看的出来啊！没事，回过头来看shift你就完全能感受到了。 shift 移位变量深入1234char shift = ";;;====~$::199"[ (i*2)&amp;8 | i/64];if ((i&amp;2) == 0) shift /= 8;shift = shift % 8; 这个if条件的除8后模8是不是有点眼熟啊，__TIME__[7 - i / 8 % 8]中就已经出现过了，不过这里的意思是 当i = 0, 1, 4, 5 mod 8时，i&amp;2为0，进入if分支，shift将会右移三位后取剩下的最低三位。 当i = 2, 3, 6, 7 mod 8时，shift直接取剩下的最低三位。 i/64表示行号，(i*2)&amp;8表示在小剧情的左半边还是右半边。 话不多说，打表！123456700005577117755771177557711665577227733772277337744443377 让我们对着表来理解&quot;;;;====~$::199&quot;[ (i*2)&amp;8 | i/64]，方括号内右边表示我（i）在第几行，左边表示我在这一行的左边还是右边。再次注意到这里的i是7-实际的行号（i是从448开始减小的，而putchar是从左上方到右下方的）。 在左半边：(i*2)&amp;8==1时就在”$::199”中选择（注意字符串结尾还有一个结束标志\0,行号从0到6，所以有7个选择）。 如果在右半边：(i*2)&amp;8==0时就在”;;;====~”中做选择。这样就和前面一样有7个选择了。其实我们马上可以意识到最后的~字符完全是用来凑数的，可以换成任何的可打印字符，因为永远用不到（只有7行0-&gt;6，数不到7）。 7段数码管原理再简化一点，$7\times 64$矩形被分割成为八个$7\times 8$的小矩形，每个小矩形按照模8的等价关系再被分为每一行和每一行的左半边和右半边。由于行号是从6减小到0，所以说选择的时候是从”$::199”和”;;;====~”中逆着选的。”$::199”对应行竖着下来”0111224”，”;;;====”对应着行竖着下来”5555333”，为什么左右半边又被分了呢？因为还有if条件的移位啊： 当i = 0, 1, 4, 5 mod 8时，shift将会右移三位后取剩下的最低三位。 当i = 2, 3, 6, 7 mod 8时，shift直接取剩下的最低三位。 也就是说，当在图中红框内时，属于i = 2, 3, 6, 7 mod 8时（再次提醒i是减小的），直接取低3位；别的位置时，取高三位。 这就很有意思了，看到有一列全是7，是在右边的情况，高位为111，可以验证;:的高三位全1 给大家贴一张ASCII码表 写到这里，大家都明白是怎么一会事了吧。再一次重新看完整的代码。 1234567891011121314151617int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char t = __TIME__[7 - i / 8 % 8]; char a = "&gt;'txiZ^(~z?"[t - 48] + 1; char shift = ";;;====~$::199"[(i*2)&amp;8 | i/64]; if ((i&amp;2) == 0) shift /= 8; shift = shift % 8; char c = a &gt;&gt; shift; putchar(32 | c&amp;1); &#125; &#125; return 0;&#125; 使用单维度i来标志当前打印字符的位置，8位字符a表示这一个区域内：$7\times 8$的小矩形内该显示的数字的七段数码管各管脚的高低电平。shift移位后用来确定当前bit是否应该被点亮。 大家有部分没有看懂的话没关系的，只需要知道原理就是7段数码管的原理，两个字符串只不过是构造这个7段数码管。 当然，这里面的思想更加深邃。 后记从详细地分析这一行代码的过程中我们得到了些什么呢？ 知道了一行代码到底能干什么事 知道了看别人写的代码时是什么感受 知道了c还有这么多我不知道的特性 知道了一个道理：想的越多，写的越少 知道了条条大路通底层电子技术原理 对比1main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; vs12345678910111213141516171819202122int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char line_num_inv = i / 64; char section_num_inv = i / 8 % 8; char section_num = 7 - section_num_inv; char t = __TIME__[section_num]; char a = "&gt;'txiZ^(~z?"[t - 48] + 1; char shift = ";;;====!$::199"[(i * 2) &amp; 8 | line_num_inv]; if ((i&amp;2) == 0) shift /= 8; shift = shift % 8; char c = a &gt;&gt; shift; putchar(32 | c&amp;1); &#125; &#125; return 0;&#125; do the same thing AcknowledgementStack Overflow - Obfuscated C Code Contest 2006. Please explain sykes2.c]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>ioccc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-next+LaTeX输入公式时遇到的一些错误]]></title>
    <url>%2F2019%2F03%2F23%2FusingLaTeXinmd%2F</url>
    <content type="text"><![CDATA[起因去next配置里开了mathjax功能试了一下，遇到了些问题。 举个栗子当你按照LaTeX语法在md文件里输入如下公式时，在本地的Markdown preview里是没有任何错误的，但是部署上线后会是如下的效果 公式 1$J(\theta)=-\frac&#123;1&#125;&#123;m&#125; \sum_&#123;i=1&#125;^&#123;m&#125;\left[y^&#123;(i)&#125; \log \left(h_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)+\left(1-y^&#123;(i)&#125;\right) \log \left(1-h_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)\right]$ 效果 $J(\theta)=-\frac{1}{m} \sum{i=1}^{m}\left[y^{(i)} \log \left(h{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$ 注意在_之间的部分全部被解析成了Markdown语法中的斜体，其实原因就是hexo在静态生成网页时是先用Markdown的语法解析器解析你的md文件，然后再交给mathjax解析其中的公式。 解决在_前全部加上Markdown语法中的转义符\。 不过这样感觉就即不是纯正的Markdown，也不是是纯正的LaTeX了。 公式 1$J(\theta)=-\frac&#123;1&#125;&#123;m&#125; \sum\_&#123;i=1&#125;^&#123;m&#125;\left[y^&#123;(i)&#125; \log \left(h\_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)+\left(1-y^&#123;(i)&#125;\right) \log \left(1-h\_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)\right]$ 效果 $J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>LaTeX hexo-nex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anagram]]></title>
    <url>%2F2019%2F03%2F09%2Fanagram%2F</url>
    <content type="text"><![CDATA[一个很有意思的易位构词本来想在寝室四人的合影上刻上一句话 结果想到了易位构词 Three hero outwit few gamer. Together with me, we are four.]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode-2-AddTwoNumbers%2F</url>
    <content type="text"><![CDATA[读题的时候不认真看题写的时候就会完全按照自己想象中的题目去解题 这道题两个数字明明是已经逆向好给我做加法了 我还傻呵呵地先写了一遍 把两个链表逆向了一遍 另外 java也不太懂 reflections5+5的情况WA了一次 没有想到这样的情况 myCode1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; boolean conti = true; ListNode ret = new ListNode(0), al1 = l1, al2 = l2; ListNode r = ret; while (conti) &#123; int a1 = 0, a2 = 0; if (al1!=null) &#123; a1 = al1.val; al1 = al1.next; &#125; if (al2!=null) &#123; a2 = al2.val; al2 = al2.next; &#125; int sum = a1 + a2 + carry; if (sum&gt;=10) &#123; sum -= 10; carry = 1; &#125;else &#123; carry = 0; &#125; ret.val = sum; if (al1==null &amp;&amp; al2==null &amp;&amp; carry==0) conti = false; if (conti) &#123; ret.next = new ListNode(0); ret = ret.next; &#125; &#125; return r; &#125;&#125; Official12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 真的是短小精悍啊！]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假回顾+学期计划]]></title>
    <url>%2F2019%2F02%2F17%2Fsophomore-Winter%2F</url>
    <content type="text"><![CDATA[寒假见闻寒假从1月14日开始执行，由于在1月25日约了朋友一起参加美赛，所以14日到25日这两个礼拜就是常规培训、准备美赛。由于我和密院同年级的同学组队，中途跑了一个，只好带了一个大一小学妹凑满3个人，十足的菜鸡队配置。好像是第一次认认真真地参加大型团队竞赛，内心也没有什么底，抱着纯粹体验一把的心态稀里糊涂地就混到了25日。 我个人确实是极其不擅长与他人合作完成一个项目。开赛两小时我去图书馆借走了相关的书，我一度认为这些书能成为我们队的优势。但是，可能就是这些书限制了思路。书上用了CA，虽然到最后我们也没有能实现这个程序。当我和别人发生意见上的分歧时，我总是很难说服对方，我总是倾向于放弃我自己的想法，去听别人的指挥做事。我觉得自己除了第一天状态是在线的，剩下的4天智商全面下线，程序不想写，模型不知道怎么建，自暴自弃。 最后一天的通宵也是非常有意思。人生中第一次通宵，0点小憩了10分钟左右，之后完全没有很难受的感觉。整个教室挤满了人，没有回去睡觉的……虽然如此，如果是为了我个人的事情，我是绝对不会通宵的。 我也很想变的强一点，想一个更好的模型云云。美赛结束就已经29日了，再过一个礼拜就春节了。29日到除夕这个礼拜就完全是放飞自我的状态，每天打网游、补番、刷小说，干着自己每次放假都会干的事。把自己玩过的游戏一个个地玩过来，没有一个游戏能让我玩超过半天。我已经不再年轻了，曾经陪我一起打网游的人，现在也都各奔东西，再也找不到曾今的感觉了。而那些游戏，也随之失去了意义。嘛总之，花了不超过两周吧，把那些令人放纵的东西都玩腻了，把目光转向修养身心的东西上。 阅读文学类的从学期结束之前就已经在知米阅读上看原版的《时间机器》和《弗兰肯斯坦》，也不是会每天都读，会把情节攒起来一口气看。开学之后必须要养成每日打卡的习惯了，因为没什么时间能一口气看了。 非文学类的看了《万万没想到》、《csapp》、《算法》，这三本都是只看了10页的那种看，真正看的主要是老师要求的《漏洞分析》。 春节的时候，我轻哼：三个礼拜二十一天三百页十七章，按照我三天四章的速度，真的是绰绰有余。今天已经是寒假最后一天了，我正好看了一半。 有些时候吧，求其上者得其中，这种感觉真的实在是太强烈了。像我这种懒惰的人，在设定目标的时候就应该设置的高一点。压力对我来说并不是朋友，在高压下我只会惊慌失措，只有在心情平稳的时候我的效率才是最高的。所以说，大段的连续的时间是我必须要全神贯注地工作学习的时候。 有的时候我会问自己：我这是在干什么？当舍友告诉我他因为组会没法参加而决定退出的时候，我问自己：我是真的喜欢漏洞挖掘所以来到目前的这个实验室吗？我思考问题的时候一直是一种小农思想，即使进入大学这种想法也没法改正过来。过分地关注短期将会得到的利益，而不做长远的考虑。我害怕做出选择，选择之后又患得患失。我还需学习的知识实在是太多了，不知道我学什么能够学好。解决这种选择困难的方法就是安慰自己：我的生活并不会因为这一个选择就能变好，选了就选了，硬着头皮干下去，时间和努力不会亏待你的。 未来规划这个寒假和父母稍微聊了一下关于自己未来准备走的路线。我个人还是非常向往国外的教育的，但是父亲指出我根本不具备一个人在异国独立生活的基本能力。我想想也是，所以还是把目标定在了保研或是考研国内升学的方向。 上个学期给自己定下的每门课不低于85分的目标完美地完成了，更多的还是因为课程考试不难的原因，但是这学期出现了信号与系统和模电，我不敢再轻言不下85了。我渐渐意识到这种单纯以成绩来评价一学期是不科学的，因为这学期我还会有实验室的工作要做，难免会占去学习课内知识的时间。 我这学期的计划是信安的专业课我绝对是放在第一优先级的事情，然后再是电院的平台课，中间穿插实验室的研究吧。 写的非常的乱，但都是心底想说的话，暂且作为人生这一小段时光的总结吧。]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>保研 出国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP Algorithm]]></title>
    <url>%2F2018%2F11%2F30%2FKnuth-Morris-Pratt-Algorithm%2F</url>
    <content type="text"><![CDATA[Introduction &amp;&amp; Core thoughtsCalculate the maximum shifting digits based on the characterics of the given patten string. How to calculate?Suppose we have a pattern string p[0:n] and the comparation failure happened when comparing s[i+j] with p[j] (when comparing s[i:i+n] with p[0:n]), that indicates that s[i:j-1] are already known and are equal to p[0:j-1]. So that suggests us to take a great heap as much as possible provided that Notice that when the failure happens at p[j], the digits before are already clearify and can tell whether the naive comparsion will succeed or not. VisualizationI think these two pictures can clearly illustrate the phenomenon: AcknowledgementsA lot of thanks to KMP算法详解 which let me understand this algorithm.]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-图5 Saving James Bond - Hard Version]]></title>
    <url>%2F2018%2F10%2F17%2FDS-07-%E5%9B%BE5%2F</url>
    <content type="text"><![CDATA[LinksHere ThoughtsHow to use the function qsort() parameters: qsort(void * array, int numberofcells, int sizeofeachcell, function cmp) function cmp: cmp(const void * a, const void * b) &#123;12 return ((*pointer* to the type of the elements waiting to be sorted)a)-&gt;some attribute of the element - ...b;&#125; It is certainly a great habbit to write comments while writing the codesTalk is cheap, show me your Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define max 102const int radius = 50;int maxtime = max;struct node &#123; //crocodile -- node int x, y; //position label x and y bool flag; //true if the crocodile is close enough to the beach node * precedent; //pointer to the previous crocodile double distance; //distance to the previous crocodile int nodetime; //attribute that trace the distance from island&#125;;struct Stack &#123; //stack to implement the closest way node * stack[max * 2]; int sp; node * Pop()&#123;return stack[sp--];&#125; void Push(node * ptr)&#123;stack[++sp] = ptr;&#125;&#125;;node croco[max]; //all the crocodiles are kept in this arrayStack priostack; //priority stacknode * FinalNode = NULL;//keep the exitusing namespace std;double getdis(int x1, int y1, int x2, int y2);void dfs(node * ptr, int n, int d, node * pre, int times);int cmp(const void * a, const void * b);int main(int argc, char const *argv[]) &#123; freopen("../test.txt", "r", stdin); int n, d;cin &gt;&gt; n &gt;&gt; d; priostack.sp = -1; for (int i = 0; i &lt; n; ++i) &#123; //inialization cin &gt;&gt; croco[i].x &gt;&gt; croco[i].y; croco[i].flag = radius - abs(croco[i].x) &lt;= d || radius - abs(croco[i].y) &lt;= d; croco[i].precedent = NULL; croco[i].distance = 0; croco[i].nodetime = max; &#125; //first iteration for (int i = 0; i &lt; n; ++i) &#123; if (getdis(0,0,croco[i].x,croco[i].y)&lt;=7.5+d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; if (priostack.sp+1 &gt; 1) qsort(&amp;priostack.stack[0], priostack.sp+1, sizeof(node*), cmp); int cnt = 0, num = priostack.sp + 1; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,NULL,1); //out put section if (maxtime == max) cout &lt;&lt; 0; else if (d &gt;= 43) cout &lt;&lt; 1; else &#123; int outputcnt = 0; while (FinalNode) &#123; outputcnt++; priostack.Push(FinalNode); FinalNode = FinalNode-&gt;precedent; &#125; cout &lt;&lt; outputcnt + 1 &lt;&lt; endl; while (outputcnt--) &#123; FinalNode = priostack.Pop(); cout &lt;&lt; FinalNode-&gt;x &lt;&lt; ' ' &lt;&lt; FinalNode-&gt;y &lt;&lt; endl; &#125; &#125; return 0;&#125;void dfs(node * ptr, int n, int d, node * pre, int times) &#123; ptr-&gt;precedent = pre; if (ptr-&gt;flag &amp;&amp; times &lt; maxtime) &#123; maxtime = times; FinalNode = ptr; &#125; ptr-&gt;nodetime = times; int bp = priostack.sp; for (int i = 0; i &lt; n; ++i) &#123; if (croco[i].nodetime&gt;times+1 &amp;&amp; getdis(ptr-&gt;x,ptr-&gt;y,croco[i].x,croco[i].y)&lt;=d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; int num = priostack.sp - bp; if (num &gt; 1) qsort(&amp;priostack.stack[bp+1], (size_t)priostack.sp-bp, sizeof(node*), cmp); int cnt = 0; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,ptr,times+1);&#125;int cmp(const void * a, const void * b) &#123; double d = (*((node**)b))-&gt;distance - (*((node**)a))-&gt;distance; return d &gt; 0 ? 1 : -1;&#125;double getdis(int x1, int y1, int x2, int y2) &#123; double ret = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); return ret;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Woman decays like this]]></title>
    <url>%2F2018%2F10%2F12%2FWoman-translate%2F</url>
    <content type="text"><![CDATA[一个女人是这样衰老的1When I was twenty, walked around the campus in a vested denim skirt, my face flushed as my mouth open. Now I am thirty, sitting in my office and scolding my subordinates, crulty written on my face, “How can you dare to ask such a silly question before even making a draft?” 二十岁的时候，我穿着一条背心式牛仔裙在校园里走来走去，一说话就脸红。 三十岁的我穿着名牌套装，坐在办公桌前，满脸冷酷地对下属说：“这么愚蠢的问题你也敢问？也不先打个草稿。” 2When I was twenty, the books borrowed from the library were The Complete Works of Shakespeare, Self-portrait of a young artist and Ulysses. Now I am in my thirties, on the bedside table lays The scrects of following the banker, ELLE and A manager’s personal charm. 二十岁的时候，从图书馆借的是《莎士比亚全集》、《一个青年艺术家的自画像》和《尤里西斯》。 三十岁之后，床头摆的是《跟庄密笈》、《ELLE》和《经理人的个人魅力》. 3In the summer of my twenty, met the boy I crushed who was said to be admitted to a graduate school. Dismayed by the progress he had made, my heart torn with grief and my tears droped as it occured to me that it was beyond my whole life to become elegent enough so that he could gave me a glance. After thirty, searching everywhere for a bought MBA. 二十岁的暑假，在家乡的大街上偶遇自己的暗恋对象，听说他考上了研究生，被他的进步所打击，心如刀绞，想到这辈子终于不能出色得让他看我一眼，不禁怅然泪下。 三十岁之后，到处打听那里可以花钱买个MBA. 4In my twenty, indicating my age from time to time, even before they asked. After thirty, find it an odious thing when asked about age. If you do, “have a guess”. 二十岁的时候，随时随地向人透露我的年龄，答得比问的还快。 三十岁之后，最恨别人问年龄，你要是非问不可，你猜啊。 5In my twenty, overwhelmed with the idea to date with boys majoring in sports or arts. After thirty, regard myself then as an idiot. 二十岁的时候，一心想和体育系、美术系的男生约会。 三十岁后，我简直认为自己当年是白痴。 6In my twenty, saw a bookstore and went in, have books there and bought. After thirty, turn a blind eye to bookstores and directly went into the Beauty Salon next door. 二十岁的时候，有书店必须逛，有书必买。 三十岁之后，对书店视而不见，直接去了隔壁的美容院。 7In my twenty, bet on myself that I wasn’t as outdated as defending this place till dead. Live elsewhere. After thirty, run out of my legs for a house in this city that I satisfied and can afford. 二十岁的时候，打赌说我这辈子不可能土到死守在一个地方，生活在别处嘛。 三十岁之后，我为了在这座城市买个满意又便宜的房子跑断了双腿. 8In my twenty, went to a movie with someone at night. Hand in hand without conscious which made me happy for a whole summer. After thirty, sitting in the revolving restaurant of Shangri-La Hotel to accompany clients and eat self help meals. As the restaurant rotates slowly, I feels an unknow inanity and suddenly grows boring toward the whole world. 二十岁的时候，和某个人晚上一起去看了场电影，不经意中拉了一次手，结果幸福了整整一个夏天。 三十岁之后，坐在香格里拉酒店的旋转餐厅陪客户吃自主助餐，在缓缓的转动之中，莫名其妙地一阵空虚，突然间对一切感到索然无味 Acknowledgement 周可, my handsome roommate who inspired me to translate this passage that moved me so much.]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-11 关键活动]]></title>
    <url>%2F2018%2F09%2F19%2FDS-7-11%2F</url>
    <content type="text"><![CDATA[进展 题目是什么意思啊？我一开始以为是最小生成树，后来觉得是dijkstra,现在我已经弄不清楚了。 有向图 需要判断是不是有回路 好吧，似乎是拓扑排序…. 预备知识 AOV网络(Activity on Vertex) Top拓扑序:若v-&gt;w 则v先输出 拓扑排序：AOV若有合理的拓扑序(无环)，则必定是有向无环图(DAG, Directed Acyclic Graph) 关键路径问题：AOE网络(Activity on Edge) 题目描述原题在这 思路难点体会与感想 好累啊，好想哭啊 刷OJ最难受的事情就是要求太多的输出格式 一道题卡了两天的感受实在是太难受了 学习的过程绝对的连续的 一旦你停止在一件事情上花时间，他马上就会给你颜色看关键代码 7-11.cpp]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构1 两个有序链表序列的合并]]></title>
    <url>%2F2018%2F09%2F14%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841%2F</url>
    <content type="text"><![CDATA[感想 写程序题实在是太麻烦了 好久没用malloc了，连头指针和头结点都分不清楚了。 使用头结点可以很方便地解决很多的问题 源代码123456789101112131415161718192021222324252627282930List Merge( List L1, List L2 )&#123; List head = (List)malloc(sizeof(struct Node)); PtrToNode current = head; PtrToNode ptr1 = L1-&gt;Next; PtrToNode ptr2 = L2-&gt;Next; while (1) &#123; if (!ptr1) &#123; current-&gt;Next = ptr2; break; &#125; if (!ptr2) &#123; current-&gt;Next = ptr1; break; &#125; if (ptr1-&gt;Data &lt; ptr2-&gt;Data) &#123; current-&gt;Next = ptr1; current = ptr1; ptr1 = ptr1-&gt;Next; &#125;else&#123; current-&gt;Next = ptr2; current = ptr2; ptr2 = ptr2-&gt;Next; &#125; &#125; L1-&gt;Next = NULL; L2-&gt;Next = NULL; return head;&#125; 顺便把二分查找的代码也贴上来12345678910111213Position BinarySearch( List L, ElementType X )&#123; int start = 1, end = L-&gt;Last, mid; while (start&lt;=end) &#123; mid = (start + end) / 2; if (L-&gt;Data[mid]&lt;X) &#123; start = mid + 1; &#125;else if (L-&gt;Data[mid]&gt;X) &#123; end = mid - 1; &#125;else if (L-&gt;Data[mid]==X) return mid; &#125; return NotFound;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-树2 List Leaves]]></title>
    <url>%2F2018%2F09%2F14%2FDS-03-%E6%A0%912%2F</url>
    <content type="text"><![CDATA[thoughts 重要的细节，也是全部写完之后发现的唯一一个错误：char的数字向int装换的时候要-‘0’； 实现细节，就是给每一个节点一个完全二叉树时的序号，然后sort qsort的具体使用细节 参数表：qsort(void *, num, sizeof(), cmp) cmp的参数：int cmp(const void front, const void rear)，不可以自己改 return的参数：返回正数就是说 cmp 传入参数第一个要放在第二个后面, 负数就是传入参数第一个要放第二个前面, 如果是 0, 那就无所谓谁前谁后. ‘’+’’ 需要swap ‘’-‘’ 不要交换 int cmp(const void small, const void big) return small - big 从小到大 codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;struct node &#123; int data; bool leaf; unsigned int pos; char left; char right;&#125;;int readtree(node * tree, int n, int * num);void attachweight(node * tree, int ptr, int weight);void printleaf(node * tree, int n);int cmp(const void * front, const void * rear);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n;cin &gt;&gt; n; node * tree = new node [n]; int leafnum = 0; int head = readtree(tree,n,&amp;leafnum); //cout &lt;&lt; head; attachweight(tree,head,1); //cout &lt;&lt; "attach done"; qsort(tree,n,sizeof(node),cmp); //cout &lt;&lt; "sorted"; printleaf(tree,leafnum); delete [] tree; return 0;&#125;void printleaf(node * tree, int n) &#123; int cnt = 0; for (int i = 0; true; i++) &#123; if (tree[i].leaf) &#123; cout &lt;&lt; tree[i].data; ++cnt; if (cnt!=n) &#123; cout &lt;&lt; ' '; &#125;else return; &#125; &#125;&#125;int cmp(const void * front, const void * rear) &#123; int ret = ((node*)front)-&gt;pos - ((node*)rear)-&gt;pos; return ret;&#125;void attachweight(node * tree, int ptr, int weight) &#123; tree[ptr].pos = weight; if (tree[ptr].left!='-') &#123; attachweight(tree,tree[ptr].left-'0',2*weight); &#125; if (tree[ptr].right!='-') &#123; attachweight(tree,tree[ptr].right-'0',2*weight+1); &#125;&#125;int readtree(node * tree, int n, int * num) &#123; bool * ishead = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; ishead[i] = true; &#125; for (int i = 0; i &lt; n; i++) &#123; tree[i].data = i; tree[i].leaf = true; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; if (tree[i].left!='-') &#123; tree[i].leaf = false; ishead[tree[i].left-'0'] = false; &#125; if (tree[i].right!='-') &#123; tree[i].leaf = false; ishead[tree[i].right-'0'] = false; &#125; if (tree[i].leaf) &#123; (*num)++; &#125; &#125; int head = 0; for (int i = 0; i &lt; n; i++) &#123; if (ishead[i]==true) &#123; head = i; break; &#125; &#125; delete [] ishead; return head;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构4 Pop Sequence]]></title>
    <url>%2F2018%2F09%2F14%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844%2F</url>
    <content type="text"><![CDATA[thoughts too simple: just stack simulation 这一次真的是爽啊，一次性过，代码简洁没有任何冗余的边界调试 这样的题目是可遇而不可求啊！ 我用树和用图也要达到我用堆的这样的境界！ codes12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;bool check(int m, int n);int main(int argc, char const *argv[]) &#123; int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; bool valid = check(m,n); if (valid) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125;bool check(int m, int n) &#123; int * stack = new int [n], stk = -1; int * store = new int [n], str = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; store[i]; &#125; bool valid = false; for (int topush = 1; topush &lt;= n; topush++) &#123; stack[++stk] = topush; if (stk==m) break; while (stk!=-1 &amp;&amp; store[str]==stack[stk]) &#123; stk--;str++; &#125; &#125; if (stk==-1) valid = true; delete [] stack; return valid;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构3 Reversing Linked List]]></title>
    <url>%2F2018%2F09%2F12%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843%2F</url>
    <content type="text"><![CDATA[进展 时间 进展 2018年9月12日中午 到目前为止还有两个测试点没过一个是全部反转，我测试的时候是对的呀；还有一个是超时 2018年9月13日21:02:58 AC 难点 容易想到一些歪门邪道，比如说我第一次想到的排序方法。 模拟内存的想法。 具体进行逆转的时候的操作 反思 做OJ的题目有一些注意事项是你不得不放在心上的 边界条件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;iomanip&gt;#define max 100005using namespace std;struct node &#123; int ads; int data; int next;&#125;;node memory[max];int getlength(node * head);node * reverse(node * head, int k);void print(node * head, int length);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int ads, n, k;cin &gt;&gt; ads &gt;&gt; n &gt;&gt; k; int address, data, next; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; memory[address].ads = address; memory[address].data = data; memory[address].next = next; &#125; node head, *headptr; head.next = ads; headptr = &amp;head; int length = getlength(headptr); for (size_t i = k; i &lt;= length; i+=k) &#123; int front = headptr-&gt;next; headptr-&gt;next = reverse(headptr,k)-&gt;ads; headptr = &amp;memory[front]; //print(&amp;head,length);cout &lt;&lt; endl; &#125; headptr = &amp;head; print(headptr,length); return 0;&#125;node * reverse(node * head, int k) &#123; node * front = &amp;memory[head-&gt;next]; node * rear = &amp;memory[front-&gt;next]; node * temp; int cnt = 1; while (cnt&lt;k) &#123; temp = &amp;memory[rear-&gt;next]; rear-&gt;next = front-&gt;ads; front = rear; rear = temp; cnt++; &#125; memory[head-&gt;next].next = rear-&gt;ads; return front;&#125;int getlength(node * head) &#123; int cnt = 0, adds = head-&gt;next; while (adds!=-1) &#123; cnt++; adds = memory[adds].next; &#125; return cnt;&#125;void print(node * head, int length) &#123; node * ptr = &amp;memory[head-&gt;next]; for (size_t i = 0; i &lt; length; i++) &#123; cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;ads; cout &lt;&lt; ' ' &lt;&lt; ptr-&gt;data &lt;&lt; ' '; if ( i==length-1 ) cout &lt;&lt; "-1"; else cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;next &lt;&lt; endl; ptr = &amp;memory[ptr-&gt;next]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-复杂度2 Maximum Subsequence Sum]]></title>
    <url>%2F2018%2F09%2F12%2FDS-01-%E5%A4%8D%E6%9D%82%E5%BA%A62%2F</url>
    <content type="text"><![CDATA[主要做的几个改动 引入track变量来控制ij的记录时间点 修补了maxsum=0的一个小bug 反思 好好看清楚题目再做很重要，不要觉得自己做过一遍就有多懂了，还不是花了2h多吗，看看清楚要输出序号还是要输出值。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-10 公路村村通]]></title>
    <url>%2F2018%2F08%2F24%2FDS-7-10%2F</url>
    <content type="text"><![CDATA[预备知识 最小生成树(Minimum Spanning Tree) 是一棵树 是由原图生成的 包含图内的所有的顶点 所有的边都是图中的边 权最小 图连通 等价 存在最小生成树 贪心算法 每一步都要眼前最好的 约束条件 Prim算法-让小数长大 算法复杂度 平方级别 稠密图 Kruskal算法-将森林合并成树 算法复杂度 ElogE 稀疏图 需要储备的数据结构：集合、并查集、最小堆 集合存储实现： 树结构：双亲表示法 孩子指向父节点 数组： 根节点为-1 堆是用数组实现的完全二叉树题目描述(更新)原题在这 思路Prim算法，日后再实现Kruskal算法 难点Prim算法的实现 体会与感想 Prim算法简直了，和Dijkstra算法一模一样 好tm烦啊 关键代码 7-10-Prim.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int Prim(int ** G, int n) &#123; bool * collected = new bool [n]; int * dist = new int [n], mincost = 0; for (int i = 0; i &lt; n; i++) &#123; collected[i] = false; dist[i] = inf; &#125; collected[0] = true; dist[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (G[0][i]&lt;dist[i]) &#123; dist[i] = G[0][i]; &#125; &#125; while (true) &#123; bool found = false; int min = inf, v = 0; for (int i = 1; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]&lt;min) &#123; found = true; min = dist[i]; v = i; &#125; &#125; if (!found) &#123; break; &#125; mincost += min; collected[v] = true; dist[v] = 0; // for every node w linking to the node v for (int w = 0; w &lt; n; w++) &#123; if (G[v][w]!=inf &amp;&amp; !collected[w]) &#123; if (G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (collected[i]==false) &#123; return -1; &#125; &#125; return mincost;&#125;]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训日记]]></title>
    <url>%2F2018%2F08%2F23%2FMilitaryTrainning%2F</url>
    <content type="text"><![CDATA[8月23日8月24日今天上午的训练结束之前连长组织了会操，我觉得自己的口令下的没什么毛病，同学们做的也都很好，可是没有被表扬。可能是走的时候排面还是没有标齐。 8月26日昨天晚上忘记知米背单词的打卡了，今天早上才发现，心里好难受。 今天上午还是下雨，我们班的进度我感觉已经十分落后了。大家正步走的时候分解动作都不稳。 下午教唱歌：打靶归来、有我在、军中绿花。 下午主攻正步走和跑步走的连贯练习。 先是正步走的臂腿结合一步两动的练习 8月27日哈哈哈昨晚拉练。 很开心，现在只记得前面的连是3连，后面的连是八连，走到凯旋门之前我们一直在疯狂拉歌。拍完照之后前后连队距离都比较大，也就没有再拉歌了。 记一下一件我认为是宝贵教训的一次经历：过了凯旋门的那一个加油点我居然怂恿梁力佳去女生手里拿了一瓶农夫山泉orz。然后他不要我就背自己包里了。我本来带的两瓶水明明正正好好，结果后半程我就在疯狂喝水，结果到最后还没喝完。 你要的东西会成为你的负担。 想清楚你要什么。 8月29日昨天晚上和7连联谊，玩到熄灯了才猛然惊醒，收拾收拾回宿舍了。 我总是觉得我准备的还不够充分，觉得自己没有买水果，买的士力架发现是辣花生味的。 说实话，联谊，有点累的。 今天下午我原来带的班被拆掉了，负责新的一列，是方阵的队形。 然后下午练跑步走的时候再一次被当场活捉。orz捉奸现场 今天不开连务会，早点休息。好想王宏武…… 8月30日今天一整天都是练方阵，orz，先送上一首分列式进行曲，此乃洗脑神曲也。 然后结束的时候我们营长来验收，我们好像把自己走的最差的一次展现给了营长看…. 从（1，4）的位置调到了（9,1）的位置，很舒服，能直接看到标兵，就是标齐感觉有些困难。 连着两天内务满分，嘤嘤嘤，我们好强。 加油，所有的一切终将消失，好好珍惜剩下的仅剩4天的训练时间吧！ 8月31日今天还是在练无聊的方阵。中途被连长T出去休息了好一会，最后又被连长调上第一列了orz 求无聊的日子快点结束吧！ 9月1日今天早上醒来发现手机开不了，悲剧。昨天夜间不就是设置了一个夜间更新然后今早起来就爆掉了。 上午去胡法光体育场练了三遍，踢的乱七八糟、一塌糊涂。 在等手机开了之后去取周可的杯子。 9月3日军训明天就结束了，看了一遍《悟空》，真的很难说再见。 王宏武说这会是一个难忘的军训，确实，真的很难忘。 我该怎样去告别这一段岁月。 这一敬，你我命运相交。 别人穿上军装就是这么好看，而为什么穿在自己的身上却觉得没那么好看了呢？ 昨晚的军训晚会坐在了很偏的位置，只能听到下面女生的尖叫声，和舞台上不停变幻着的刺眼灯光。]]></content>
      <categories>
        <category>军训</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-9 旅游规划]]></title>
    <url>%2F2018%2F08%2F17%2FDS-7-9%2F</url>
    <content type="text"><![CDATA[预备知识 Floyd算法：复杂度 V^3 重要前提：一步一步向后推的 三重循环，每次从DK 归纳推理到 DK+1 其中DK是只经过编号为i（i&lt;K）时各个点对间的最短路 Dijkstra算法: 复杂度最高 V^2+E 这就是运行超时和答案正确之间的区别 题目描述原题在这 思路原先想着用Floyd算法去做的，写完发现有一个测试点运行超时了，无奈只好回到了Dijkstra算法，思路基本一致，唯一的不同点就是图换成了邻接矩阵表示，同时还多了一个fee的权需要检测。 难点不能用Floyd，本题实质是单源有权图的最短路问题（从s到d）。 体会与感想 stray ‘\357’ in program```出现此类错误的原因，在编辑器中使用的utf-8的格式保存源代码中出现了中文的标点符号。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 关键代码&gt;7-9-Floyd.cpp```C++#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);void Floyd(int ** G, int n, int ** cost);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\SJTU\\Freshman Summer\\DS\\test.txt&quot;, &quot;r&quot;, stdin); int n, m, s, d, ** cost = NULL; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); Floyd(G,n,cost); int length = G[s][d]; int fee = cost[s][d]; cout &lt;&lt; length &lt;&lt; &apos; &apos; &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;void Floyd(int ** G, int n, int ** cost) &#123; for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (G[i][j] &gt; G[i][k]+G[k][j]) &#123; G[i][j] = G[i][k] + G[k][j]; cost[i][j] = cost[i][k] + cost[k][j]; &#125; else if (G[i][j] == G[i][k]+G[k][j]) &#123; if (cost[i][j] &gt; cost[i][k] + cost[k][j]) &#123; cost[i][j] = cost[i][k] + cost[k][j]; &#125; &#125; &#125; &#125; &#125;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125; 7-9-Dijkstra.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n, m, s, d, ** cost = NULL, fee; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); int length = Dijkstra(G,n,s,d,cost,&amp;fee); cout &lt;&lt; length &lt;&lt; ' ' &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend)&#123; int * dist = new int [n]; int * fee = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; fee[i] = inf; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; for (int i = 0; i &lt; n; i++) &#123; if(!collected[i] &amp;&amp; G[s][i]!=inf) &#123; dist[i] = G[s][i]; fee[i] = cost[s][i]; &#125; &#125; int v = -1; while (true) &#123; int min = inf; v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (v==d || v==-1) break; collected[v] = true; for (int w = 0; w &lt; n; w++) &#123; if(!collected[w] &amp;&amp; G[v][w]!=inf) &#123; if (dist[v]+G[v][w]&lt;dist[w]) &#123; dist[w] = dist[v] + G[v][w]; fee[w] = fee[v] + cost[v][w]; &#125;else if (dist[v]+G[v][w]==dist[w]) &#123; if (fee[w] &gt; fee[v] + cost[v][w]) &#123; fee[w] = fee[v] + cost[v][w]; &#125; &#125; &#125; &#125; &#125; int ret = dist[v]; *spend = fee[v]; delete [] dist; delete [] fee; delete [] collected; return ret;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125;]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-8 哈利·波特的考试]]></title>
    <url>%2F2018%2F08%2F17%2FDS-7-8%2F</url>
    <content type="text"><![CDATA[预备知识 最短路径问题的分类： 单源最短路：从固定的源点出发求其到所有其他顶点的最短路径 无权图 BFS算法 有权图 Dijkstra 多源最短路 无权图的单源最短路算法：BFS算法 按照递增的顺序找出找出源点到各个顶点的最短路 算法要点：需要两个数组dist和path分别记录最短距离和上一个顶点 有权图的单源最短路算法：Dijkstra算法 分为已经确定最短路的集合S以及一个长度数组dist 实现原理：若路径是按照递增顺序生成的，则： 下一个加入S的点必定只经过S内的点（不然不是S内的点应该比当前点先加入S） 每次选一个dist最小的加入S（贪心算法） 加入点后会影响dist，影响的都是加入点的邻接点 算法实现要点： 需要dist、path和collected数组分别记录最短距离、上一个节点以及是否被收入S的信息 初始化条件：dist都为无穷大，path都没有，collect全不是 123dist[i] = inf;path[i] = -1;collected[i] = false; 修改源点的数据，进入Dijkstra函数 题目描述原题在这给定一张有权图，判断是否连通，若连通，则求使从一个顶点出发最长的最短路最短的那个节点。 思路Dijsktra算法对每一个节点使用 难点Dijsktra算法实现 体会与感想 这个金光闪闪的算法一定要记在脑子里啊~ 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int Dijkstra(node * G, int n, int s)&#123; int * dist = new int [n]; int * path = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; path[i] = -1; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; node * ptr = G[s].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[s]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[s] + ptr-&gt;weight; path[w] = s; &#125; &#125; ptr = ptr-&gt;next; &#125; while (true) &#123; int min = inf, v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (min==inf || v&lt;0) break; collected[v] = true; node * ptr = G[v].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[v]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[v] + ptr-&gt;weight; path[w] = v; &#125; &#125; ptr = ptr-&gt;next; &#125; &#125; int min = -1; for (int i = 0; i &lt; n; i++) &#123; if (dist[i]==inf) return -1; if (dist[i]&gt;min) min = dist[i]; &#125; delete [] dist; delete [] path; delete [] collected; return min;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-7 六度空间]]></title>
    <url>%2F2018%2F08%2F15%2FDS-7-7%2F</url>
    <content type="text"><![CDATA[预备知识 六度空间理论：社交关系图中，任一两个节点总可以在六步之内相互关联。 题目描述用深度优先搜索一幅图的每一个节点相对于其他所有节点满足六度空间理论的百分率。 思路用上次写的邻接表表示的图，基本没什么多的操作，就是控制一下BFS的层数就结束了。 难点没有难点 体会与感想 在Clion中调试的时候，想看new出来的一片连续空间时，需要在new watch中添加命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175- c++想要控制输出固定位小数时，先用fixed固定好小数点，在用setprecesion控制保留几位小数- setprecesion本来是用来控制有效数字的# 源代码```C++#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);int BFSvalid(node * G, int i, int n);void deleteGraph(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\SJTU\\Freshman Summer\\DS\\test.txt&quot;, &quot;r&quot;, stdin); int n, m;cin &gt;&gt; n &gt;&gt; m; node * G = createGraph(n); readGraph(G,m); for (int i = 0; i &lt; n; i++) &#123; int valid = BFSvalid(G,i,n); double percentage = valid / (double)n; cout &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 100 * percentage; cout &lt;&lt; &apos;%&apos; &lt;&lt; endl; &#125; deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited, int * cnt) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); (*cnt)++; visited[min] = true; &#125;&#125;int BFSvalid(node * G, int start, int n) &#123; //return the number of valid nodes Queue * q = creatQueue(n); //of the BFS of node i bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; int cnt = 1, degree = 6; enQueue(q,start); visited[start] = true; int sentry = q-&gt;tail; while (q-&gt;head!=q-&gt;tail+1 &amp;&amp; degree&gt;0) &#123; while (q-&gt;head!=sentry+1) &#123; int popelement = deQueue(q); push(q,&amp;G[popelement],visited,&amp;cnt); &#125; sentry = q-&gt;tail; degree--; &#125; delete [] visited; deleteQueue(q); return cnt;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi-1, vj-1); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-6 列出连通集]]></title>
    <url>%2F2018%2F08%2F14%2FDS-7-6%2F</url>
    <content type="text"><![CDATA[预备知识 图 多对多的关系 无向边（u v） 有向边 线性表 一对一 树 一对多 抽象数据类型定义的三要 类型名称 数据对象集 操作集 网络 带权重的图 图的表示方法取决于你要解决的具体问题 DFS 深度优先搜索 出栈 DFS 时间复杂度取决于图的表示方法 领接表 O(N+E) 邻接矩阵 O(N^2) BFS 广度优先 DFS BFS 复杂度相同 广优的话，占内存多，能找到最优解，必须遍历所有分枝. 广优的一个应用就是迪科斯彻单元最短路径算法. 深优的话，占内存少，能找到最优解（一定条件下），但能很快找到接近解（优点），可能不必遍历所有分枝（也就是速度快）, 深优的一个应用就是连连看游戏. 连通分量 一次DFS 遍历了一个连通分量 题目描述分别用深度优先搜索和广度优先搜索遍历一幅图的所有节点。 思路首先就是考虑这个图该用领接表还是邻接矩阵来表示，后来在码代码的过程中发现确实是邻接矩阵方便的多，不用findmin函数。但我没用过邻接表，这次练习一下。 难点基本没有难点 体会与感想 大工程绝对不要企图用一个.cpp文件就想写完，太天真了。 果然写的太长了是因为我太菜了嘛 半天200行的效率 反复传图指针很难受 还没来得及看视频 源代码 这次的代码比较长，放一个文件里也比较乱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;iostream&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);void DFSlistComponents(node * G, int n);void deleteGraph(node * G, int n);void BFSlistComponents(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n, e;cin &gt;&gt; n &gt;&gt; e; node * G = createGraph(n); readGraph(G,e); DFSlistComponents(G,n); BFSlistComponents(G,n); deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); visited[min] = true; &#125;&#125;void BFSlistComponents(node * G, int n) &#123; Queue * q = creatQueue(n); bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i]) &#123; cout &lt;&lt; "&#123; "; enQueue(q,i); visited[i] = true; while (q-&gt;head!=q-&gt;tail+1) &#123; int popelement = deQueue(q); cout &lt;&lt; popelement &lt;&lt;" "; push(q,&amp;G[popelement],visited); &#125; cout &lt;&lt; '&#125;' &lt;&lt; endl; &#125; &#125; delete [] visited; deleteQueue(q);&#125;void DFS(node * G, int i, bool * visited) &#123; while (remains(&amp;G[i],visited)) &#123; int min = findMin(&amp;G[i],visited); if (min==-1) return; cout &lt;&lt; min &lt;&lt;" "; visited[min] = true; DFS(G,min,visited); &#125;&#125;void DFSlistComponents(node * G, int n) &#123; bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (visited[i]) continue; cout &lt;&lt; "&#123; "; if (!visited[i]) &#123; cout &lt;&lt; i &lt;&lt;" "; visited[i] = true; DFS(G,i,visited); &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl; &#125; delete [] visited;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi, vj); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自搭梯子翻越GFW]]></title>
    <url>%2F2018%2F08%2F12%2FGFW%2F</url>
    <content type="text"><![CDATA[主要借鉴 十分钟搭建自己的科学上网SSR梯子非常感谢！ 思路 首先你得先租借好专用的VPS，推荐的有Digitalocean和Vultr 我先是试了试Singapore的服务器发现很慢，于是换了LA的，爽的不行。 然后就是在登陆服务器之后通过rrsmu.sh脚本安装ShadowsocksR 最后在自己的客户端装上SSR 奇迹就这样发生了]]></content>
  </entry>
  <entry>
    <title><![CDATA[7-4 是否同一棵二叉搜索树]]></title>
    <url>%2F2018%2F08%2F12%2FDS-7-4%2F</url>
    <content type="text"><![CDATA[题目描述判断给定的插入序列是否构成同一棵二叉搜索树 （二叉搜索树：所有左子树元素都小于自身，所有右子树元素都大于自身） 输入12345678984 23 1 4 23 4 1 23 2 4 12 12 11 20 输出123YesNoNo 思路判断数列的奇淫技巧，测试点1过不了。 哈哈现在我的奇淫技巧过了。 更新了根据即将插入的根进行判断。 难点选择比较的方法以及原始数据和比较数据的储存形式 体会与感想自己写的代码多看几遍总归是能看懂的，理清楚的。 还有很想说的是cmake不支持中文以及文件名中的空格，以后再也不用中文了。 真的，实在是..所有中文一律乱码 看了视频之后再写真的是畅通无比，一次提交直接AC。 膜递归… 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;void comparetree(int n, int l);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); while (true) &#123; int n;cin&gt;&gt;n; if (n==0) break; int l;cin&gt;&gt;l; comparetree(n,l); &#125; return 0;&#125;void print(bool same)&#123; switch (same) &#123; case true: cout &lt;&lt; "Yes" &lt;&lt; endl;break; case false:cout &lt;&lt; "No" &lt;&lt; endl;break; &#125;&#125;void comparetree(int n, int l)&#123; int * src = new int [n]; //src--the original array int * select = new int [n]; //select 0--&gt;not added to the cmp tree for (size_t i = 0; i &lt; n; i++) cin &gt;&gt; src[i]; //select 1--&gt;added to the cmp tree int * cmp = new int [n]; for (size_t i = 0; i &lt; l; i++) &#123; bool same = true; for (size_t i = 0; i &lt; n; i++) &#123;cin &gt;&gt; cmp[i];select[i]=0;&#125; if (src[0]!=cmp[0]) &#123; //judge the head same = false; print(same); continue; &#125;else select[0] = 1; for (size_t i = 1; i &lt; n &amp;&amp; same; i++) &#123; //i--indecate the cmp node int rootcmp = src[0]; for (size_t k = 1; k &lt; n; k++) &#123; if (src[k]&gt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&gt;rootcmp) &#123; rootcmp = src[k]; &#125;else if (src[k]&lt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&lt;rootcmp) &#123; rootcmp = src[k]; &#125; &#125; for (size_t j = 1; j &lt; n; j++) &#123; if (select[j]==1) continue; if (cmp[i]==src[j]) &#123; select[j] = 1; break; &#125; int rootsrc = src[0]; for (size_t k = 1; k &lt; j; k++) &#123; if (src[k]&gt;rootsrc&amp;&amp;src[j]&gt;rootsrc) &#123; rootsrc = src[k]; &#125;else if (src[k]&lt;rootsrc&amp;&amp;src[j]&lt;rootsrc) &#123; rootsrc = src[k]; &#125; &#125; if (rootcmp==rootsrc) &#123; if (cmp[i]&gt;rootcmp&amp;&amp;src[j]&gt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; if (cmp[i]&lt;rootcmp&amp;&amp;src[j]&lt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; &#125; &#125; &#125; if (same) print(same); &#125;&#125; 顺便再贴一下看了视频之后的源码结构更加清晰 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;struct node &#123; int value; node * left; node * right; int select;&#125;;node * maketree(int n);void deletetree(node * tree);bool treecmp(node * tree, int n);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n;cin &gt;&gt; n; while (n) &#123; int l;cin &gt;&gt; l; node * tree = maketree(n); for (int i = 0; i &lt; l; i++) &#123; if (treecmp(tree,n)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; deletetree(tree); cin &gt;&gt; n; &#125; return 0;&#125;bool check(node * tree, int v)&#123; if (!tree) return false; if (tree-&gt;value==v) &#123; tree-&gt;select = 1; return true; &#125; if (tree-&gt;select==0) &#123; return false; &#125; if (tree-&gt;value&gt;v) &#123; return check(tree-&gt;left,v); &#125;else&#123; return check(tree-&gt;right,v); &#125;&#125;void settree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) settree(tree-&gt;left) ; if (tree-&gt;right) settree(tree-&gt;right); tree-&gt;select = 0;&#125;bool treecmp(node * tree, int n)&#123; settree(tree); int v; bool ret = true; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v; if (!check(tree,v)) ret = false; &#125; return ret;&#125;void deletetree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) deletetree(tree-&gt;left) ; if (tree-&gt;right) deletetree(tree-&gt;right); delete tree;&#125;node * newnode(int value)&#123; node * treenode = new node; treenode-&gt;left = NULL ; treenode-&gt;right = NULL ; treenode-&gt;value = value ; treenode-&gt;select = 0 ; return treenode;&#125;node * attachnode(node * tree, int value)&#123; if (!tree) &#123; return newnode(value); &#125;else&#123; if (tree-&gt;value&gt;value) tree-&gt;left = attachnode(tree-&gt;left ,value); else tree-&gt;right= attachnode(tree-&gt;right,value); return tree; &#125;&#125;node * maketree(int n)&#123; int value; node * tree = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; tree = attachnode(tree,value); &#125; return tree;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-3 树的同构]]></title>
    <url>%2F2018%2F08%2F11%2FDS-7-3%2F</url>
    <content type="text"><![CDATA[题目描述判断给出的两棵树是否是同构的（同构-即左右子树可以相互交换位置） 输入1234567891011121314151617188A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 - 输出1Yes 思路刚开始听了MOOC上说用静态链表（简单来说就是数组，只不过每个元素带有指针效果的元素）后这么想的：读入需要两个inArray，再根据这两个Array构造两个满二叉树的char型数组，然后用递归写一个cmp在满二叉树的char型数组上比较。实在太麻烦了。 然后就用了MOOC上的方法。搞了全局变量，简直不要太舒服。 最后一个边界条件（n=0）引起的段错误调的我ooxx 难点怎么组织你的数据，就像老师讲的： 你打算怎么储存两棵树 怎么找到根节点（这个简单） 怎么比较同构1和3我现在都还是无法驾驭。1是熟练掌握数据结构的应用，3是写递归程序。 体会与感想深深地体会到了大神的代码和我自己的代码之间的区别（100+行都写不完和60行AC的差距）orz 当你函数的参数≥四个并且还是在反复传同一个参数的时候，你就该想想你的思路是不是不太对了。 有时候全局变量该用就得用，否则到时候难受的是你自己。 main函数里东西越少越好，代码质量越高，可读性越好。 递归函数感觉还是比较虚，边界条件有时理不清。 尽可能地检查边界条件（极小与极大）。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#define max 10#define null -1using namespace std;struct node &#123; char element; int left; int right;&#125;tree1[max], tree2[max];int build(node * tree);bool isomorphic(int r1, int r2);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int r1 = 0, r2 = 0; r1 = build(tree1); r2 = build(tree2); if (r1!=-1 &amp;&amp; r2!=-1) &#123; if (isomorphic(r1,r2)) cout &lt;&lt; "Yes"; else cout &lt;&lt; "No"; &#125;else if (r1==-1 &amp;&amp; r2==-1) &#123; cout &lt;&lt; "Yes"; &#125;else cout &lt;&lt; "No"; return 0;&#125;bool isomorphic(int r1, int r2)&#123; if (r1==null &amp;&amp; r2==null) return true; if (r1==null || r2==null) return false; int n1 = 0, n2 = 0; if (tree1[r1].left==null) n1++; if (tree1[r1].right==null) n1++; if (tree2[r2].left==null) n2++; if (tree2[r2].right==null) n2++; if (n1!=n2) return false; if (tree1[r1].element!=tree2[r2].element) return false; if (n1==2) return true; else if (n1==1) &#123; if (tree1[r1].left==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].right); &#125; else if (tree1[r1].left==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].left); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].right); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].left); &#125; &#125; else if (n1==0) &#123; if (tree1[tree1[r1].left].element==tree2[tree2[r2].left].element) &#123; return isomorphic(tree1[r1].left,tree2[r2].left) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].right); &#125;else&#123; return isomorphic(tree1[r1].left,tree2[r2].right) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].left); &#125; &#125; return true;&#125;int build(node * tree)&#123; int n;cin &gt;&gt; n; if (n==0) return -1; int * select = new int [n]; char le, ri; for (int i = 0; i &lt; n; i++) select[i] = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tree[i].element &gt;&gt; le &gt;&gt; ri; if (le!='-') &#123; tree[i].left = le - '0'; select[tree[i].left] = 1; &#125;else tree[i].left = null; if (ri!='-') &#123; tree[i].right = ri - '0'; select[tree[i].right] = 1; &#125;else tree[i].right = null; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (select[i]==0) &#123; ret = i; break; &#125; &#125; delete [] select; return ret;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学期结束了，假期开始了]]></title>
    <url>%2F2018%2F07%2F27%2FSummerSemesterEnd%2F</url>
    <content type="text"><![CDATA[离别昨天傍晚阿阳一家就已经接他回江苏了，今早阿可一个人很早就出发了，中午的时候，阿韬的爸妈也来接他回江苏了。寝室里的人一个个地减少，最后，现在只剩下我了。 宿舍里的生气渐渐变少，阳台上晒着的衣服一件件地被不同的人收了进来，带回了家，阳台变得一干二净。上铺的床被搬空，书架上的书被带回了家，书桌被收拾的干干净净。窗外的蝉叫的更响亮了。 离别的气息充斥。 我一个人默默地考完最后一场考试，从东上院走出来。路上没有什么人，整个校园安安静静，仿佛整个世界只剩下闷热的空气。 孤独是一种常态吧，是嘛？ 我曾经不停地希望着中午回到寝室他们能不要吵，让我安安静静地再看一会儿书。 人可真是奇怪的动物，哈哈。 QQ也已经聊得很少了，在学期里明明是不想过多地去了解别人的消息，可是现在却热切地渴望着掌握别人的动态。 起航这个假期我准备干些什么呢？ 我想准备GRE，复习数据结构，看js书，多多做一些家务，多学一些日常本领。 还想预习一下下学期的电学基础课，多看一些文学书。 想保证一个健康的作息。]]></content>
      <tags>
        <tag>Freshman-Summer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-2 一元多项式的乘法与加法运算]]></title>
    <url>%2F2018%2F07%2F18%2FDS-7-2%2F</url>
    <content type="text"><![CDATA[题目描述设计函数分别求两个一元多项式的乘积与和。 输入124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 思路首先要确定多项式的储存结构，决定用链表按照指数递降顺序存储。 接下来无非就是两个难题，一个是怎么加，一个是怎么乘。 难点一开始的时候我乘法用了我现在用的加法算法在一个个向后推，可以说是相当的蠢萌了。 加法标准做法是3个循环搞定，第一轮循环两个链表同时向后推，一个推到最后就把另一个剩下的全接上去就可以了。 乘法有很多种做法，我用了老师讲的插入法。 两轮循环，每一次都要向已有的链表上插入一个新的点，有时需要合并，有时需要删点。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;iostream&gt;using namespace std;const int MAX = 1003;struct node&#123; int coef;//系数 int expo;//指数 node * next;&#125;;node * CreatList(node * head); //单链表的读入与创建void PrintList(node * head); //输出以head为头结点的链表node * MultiplyList(node * p1, node *p2); //多项式乘法void Attach(int coef, int expo, node **nodepointer); //插入一个节点至nodepointer后node * AddList(node * p1, node *p2); //多项式加法void FreeList(node * p); //内存释放int main(int argc, char const *argv[]) &#123; node *head1 = NULL, *head2 = NULL; head1 = CreatList(head1); head2 = CreatList(head2); node *multi = MultiplyList(head1, head2); node *add = AddList(head1, head2); PrintList(multi);cout &lt;&lt; endl; PrintList(add); FreeList(head1);FreeList(head2);FreeList(multi);FreeList(add); return 0;&#125;node * CreatList(node * head)&#123; int coef, expo, k; node * p; head = new node; cin &gt;&gt; k; if ( !k ) return NULL; cin &gt;&gt; coef &gt;&gt; expo; head-&gt;coef = coef; head-&gt;expo = expo; head-&gt;next = NULL; p = head; for (size_t i = 1; i &lt; k; i++) &#123; cin &gt;&gt; coef &gt;&gt; expo; node *temp = new node; p-&gt;next = temp; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = NULL; p = temp; &#125; return head;&#125;void PrintList(node * head)&#123; if ( !head ) &#123; cout &lt;&lt; "0 0"; &#125; while ( head ) &#123; cout &lt;&lt; head-&gt;coef &lt;&lt; " " &lt;&lt; head-&gt;expo; head = head-&gt;next; if ( head ) cout &lt;&lt; " "; &#125;&#125;//by inserting to the right place 2 loopsnode * MultiplyList(node * p1, node *p2)//p is the pointor&#123; //poining to the current node node *head = new node; head-&gt;expo = MAX; head-&gt;next = NULL; while ( p1 ) &#123; node *p = p2; while ( p ) &#123; //PrintList(head-&gt;next); //cout &lt;&lt; endl &lt;&lt; endl; int coef = p1-&gt;coef * p-&gt;coef; int expo = p1-&gt;expo + p-&gt;expo; node *temp = head; while ( true ) &#123; //point to one in front // cout &lt;&lt; "once "; if ( !(temp-&gt;next) || temp-&gt;next-&gt;expo&lt;=expo ) break; temp = temp-&gt;next; &#125; //now temp points to the insert place ahead // cout &lt;&lt; "now expo is " &lt;&lt; expo; // cout &lt;&lt; "my temp-&gt;expo = " &lt;&lt; temp-&gt;expo &lt;&lt; endl; if ( temp-&gt;next &amp;&amp; temp-&gt;next-&gt;expo == expo ) &#123; if ( temp-&gt;next-&gt;coef + coef == 0 ) &#123; //delete node * tobefreed = temp-&gt;next; temp-&gt;next = tobefreed-&gt;next; delete tobefreed; &#125;else &#123; //join together temp-&gt;next-&gt;coef += coef; &#125; &#125;else Attach(coef, expo, &amp;temp); p = p-&gt;next; &#125; p1 = p1-&gt;next; &#125; node * tobedeleted = head; head = head-&gt;next; delete tobedeleted; return head;&#125;void Attach(int coef, int expo, node **nodepointer)&#123; // cout &lt;&lt; "now coef=" &lt;&lt; coef &lt;&lt; " expo=" &lt;&lt; expo &lt;&lt; // " inserted after expo=" &lt;&lt; (*nodepointer)-&gt;expo &lt;&lt; endl; node * temp = new node; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = (*nodepointer)-&gt;next; (*nodepointer)-&gt;next = temp;//here // cout &lt;&lt; "now temp-&gt;next=" &lt;&lt; temp-&gt;next; // cout &lt;&lt; " *nodepointer points to expo" &lt;&lt; (*nodepointer)-&gt;expo;&#125;node * AddList(node * p1, node *p2) //receive 2 pointers and return the AddList&#123; //head is a pointer to the head node node * p, * head; head = new node; //head is a head noder contains p = head; //nothing but a next pointor head-&gt;coef = 0; head-&gt;expo = 0; head-&gt;next = NULL; while ( p1 &amp;&amp; p2 ) &#123; int expo1, expo2; expo1 = p1-&gt;expo; expo2 = p2-&gt;expo; if ( expo1 &gt; expo2 ) &#123;//copy p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125;else if ( expo1 &lt; expo2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125;else &#123; int coef = p1-&gt;coef + p2-&gt;coef; if ( coef ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = coef; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; &#125; while ( p2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125; while ( p1 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125; //cout &lt;&lt; head-&gt;next; p = head; head = head-&gt;next; delete p; return head; // if ( head-&gt;next ) &#123; // &#125;else &#123; // return head; // &#125;&#125;void FreeList(node * p)&#123; node * next; while ( p ) &#123; next = p-&gt;next; delete p; p = p-&gt;next; &#125;&#125;/*程序最后的两个细节问题1- 当加法结果为零时的输出2- 当有一个k为零时的输出*/]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-A-1051]]></title>
    <url>%2F2018%2F05%2F07%2FPAT-A-1051%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Thoughtsjust Stack simulation Long time no code and my coding ability drops significantly. This problem may be rather simple for some one, but it just serve the purpose of revieweing the basic knowledges for me. Sometimes a tiny bug can drive you crazy. No one can come to the final solution at the first glance, but as long as you spend your time on it, it will no doubt seem more ane more clear to you. Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]) &#123; //freopen(&quot;D:\\cpphomework\\test.txt&quot;, &quot;r&quot;, stdin); int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; int **Sequence = new int * [k]; for (size_t i = 0; i &lt; k; i++) Sequence[i] = new int [n]; int *used = new int [n+1], *result = new int [n]; int remaining = m; for (size_t i = 0; i &lt; k; i++) &#123; result[i] = 1; for (size_t j = 0; j &lt; n; j++) &#123; cin &gt;&gt; Sequence[i][j]; &#125; &#125; //prepare for (size_t i = 0; i &lt; k; i++) &#123; remaining = m; for (size_t j = 1; j &lt;= n; j++) used[j]=0; int q = 1, c = 0; //start while ( q&lt;=n &amp;&amp; remaining&gt;0 &amp;&amp; result[i] ) &#123; if ( q==Sequence[i][c] ) &#123; used[q] = 1; while ( c+1&lt;n &amp;&amp; Sequence[i][c+1]&lt;Sequence[i][c] ) &#123; int examine = Sequence[i][c]-1; while ( used[examine]==1 ) examine--; if ( Sequence[i][c+1]==examine ) &#123; used[examine] = 1; remaining++;c++; &#125;else &#123; result[i] = 0;break; &#125; &#125; q++;c++; &#125; else &#123; q++;remaining--; &#125; &#125; if ( q&lt;=n ) &#123; result[i] = 0; &#125; for (size_t j = 1; result[i] &amp;&amp; j &lt;= n; j++) &#123; if ( used[j]!=1 ) &#123; result[j] = 0; break; &#125; &#125; &#125; //output for (size_t i = 0; i &lt; k; i++) &#123; switch ( result[i] ) &#123; case 1: cout &lt;&lt; &quot;YES&quot;;break; case 0: cout &lt;&lt; &quot;NO&quot;;break; &#125; if ( i!=k-1 ) cout &lt;&lt; endl; &#125; //delete for (size_t i = 0; i &lt; k; i++) delete [] Sequence[i]; delete [] Sequence; delete [] used; delete [] result; return 0;&#125;]]></content>
      <tags>
        <tag>PAT-Advanced-Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假见闻]]></title>
    <url>%2F2018%2F02%2F14%2F%E5%AF%92%E5%81%87%E8%A7%81%E9%97%BB%2F</url>
    <content type="text"><![CDATA[这个寒假我干了啥呢？ 日期 事件 5日 去九院看牙齿，得知还不能装上牙套，母生气，徐家汇购物，校医院配药 6日 外婆家，高烧，傍晚五院点滴 7日 科目四，查询报销 8日 无所事事,忘了 9日 blog 10日 收快递，驾照，win7 11日 外婆家， 12日 ？ 13日 外婆，dokidoki cao，全tm记不起来了我一直以为我可以记得很tm清楚的 不得不说，我真的是一个很拖延的人，明明知道有些事是对的事，有些事是错的事，但是我并没有去做那些对的事，也没有改掉那些错的习惯。 离开舒适区，请，求你了。 大年三十又是糟糕的一天 一整天几乎就没干什么事情 在外婆家有一种什么都干不了的感觉 真的好烦。 与其坐以待毙，不如主动出击。 大一暑假假期见闻这个暑假好像很短啊！先是忙小学期，然后稍微修整了十多天军训就轰轰烈烈地开始了，度过了这个难忘的军训之后我抽空和几位舍友一起去南京玩了两天，回来之后就是现在了，开学了，我已经大二了。 首先说说小学期吧。这个小学期我选了三门非常喜欢的课：ICS、大学生健康教育和刑法与生活。真的是学到了很多的东西，虽然最后的成绩都不是很好看，但是回想上课的那四周我真的是完全地投入其中的。哎，期末的时候千万不要太放松，你一放松期末总评就刷刷往下掉，越到期末越是不能放松啊。 虽然这中间的十几天没有参加什么有意思有意义的社会实践，但是不久就开始小班长集训了。大学的军训我是一辈子都不会忘记的，这可能是大家最后一次表现地这么有凝聚力，共同齐心协力只为了一个共同的目标的时光了。我们收获珍贵的情谊，培养过硬的作风，把军人坚韧刚毅果敢的品质内化为自己的内心力量。虽然交大的军训确实是有点水，除了队列练习基本上没有什么别的主要的内容了，体贴学生简直到了放纵的地步，但是最后那几天方阵彩排的那个闷热的上午，我第一次知道我的手臂上居然能沁出如此细密的汗珠，第一次知道汗水流到眼睛里是多么的刺眼睛，第一次感受到汗水顺着腹部流下的奇痒难忍。]]></content>
      <tags>
        <tag>寒假</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinstall my Win7 Ultimate]]></title>
    <url>%2F2018%2F02%2F10%2FWin7-SSD%2F</url>
    <content type="text"><![CDATA[TriggersMy old ThinkPad E430c, which my father bought in about 2012, is operatering more and more slowly nowadays. A few days ago, it even experienced several bruescreens breakups, and it took me a whole morning to just start it. After examing the hard-drive, I found that it was severely damaged, maybe due to the bumping on the road. So last night, I bought a SSD (TOSHIBA Q200 240G) PreparationsAfter searching the Internet for almost a whole day, I decided to still install the Win7 Ultimate. I also learned a lot through searching. :D I finally found a detailed tutorial called xitongcheng. It guided me to turn my original onlydisk into a USB setup disk. What I need now is only a Win7 system now (from msdn). Place the SSD in place and start your computerHere comes a terrible question.What should I do? I googled it and founded the solution. just type in three commands:123find --set-root /bootmgrchainloader /bootmgrboot and it entered the PE system. Then just choose the Win7 Ultimate. It works. install the DRIVERFirst of all, you should make sure that your computer can have access to the Internet. Then everything went on smoothly without explaination. Inflections I don’t want to reinstall any system any longer! It’s really complicated!]]></content>
  </entry>
</search>
