---
layout: blog
title: 7-9 旅游规划
date: 2018-8-17 19:01:28
categories: 数据结构与算法题目集（中文）
tags: 数据结构与算法题目集（中文）
---
# 预备知识
- Floyd算法：复杂度 V^3
 - 重要前提：一步一步向后推的
 - 三重循环，每次从DK 归纳推理到 DK+1
 - 其中DK是只经过编号为i（i<K）时各个点对间的最短路
- Dijkstra算法: 复杂度最高 V^2+E
- 这就是**运行超时**和**答案正确**之间的区别


# 题目描述
[原题在这](https://pintia.cn/problem-sets/15/problems/717)


# 思路
原先想着用Floyd算法去做的，写完发现有一个测试点运行超时了，无奈只好回到了Dijkstra算法，思路基本一致，唯一的不同点就是图换成了邻接矩阵表示，同时还多了一个fee的权需要检测。

# 难点
不能用Floyd，本题实质是**单源有权图的最短路问题**（从s到d）。

# 体会与感想
- ```error: stray ‘\357’ in program```出现此类错误的原因，在编辑器中使用的utf-8的格式保存源代码中出现了中文的标点符号。

# 关键代码
>7-9-Floyd.cpp

```C++
#include <iostream>
#define inf 10000

using namespace std;

int ** readGraph(int n, int m, int *** cost);
void deleteGraph(int ** G, int n, int ** cost);
void Floyd(int ** G, int n, int ** cost);

int main(int argc, char const *argv[]) {
    freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin);
    int n, m, s, d, ** cost = NULL;
    cin >> n >> m >> s >> d;
    int ** G = readGraph(n,m,&cost);
    Floyd(G,n,cost);
    int length = G[s][d];
    int fee = cost[s][d];
    cout << length << ' ' << fee;
    deleteGraph(G,n,cost);
    return 0;
}

void Floyd(int ** G, int n, int ** cost) {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (G[i][j] > G[i][k]+G[k][j]) {
                    G[i][j] = G[i][k] + G[k][j];
                    cost[i][j] = cost[i][k] + cost[k][j];
                }
                else if (G[i][j] == G[i][k]+G[k][j]) {
                    if (cost[i][j] > cost[i][k] + cost[k][j]) {
                        cost[i][j] = cost[i][k] + cost[k][j];
                    }
                }
            }
        }
    }
}

void deleteGraph(int ** G, int n, int ** cost) {
    for (int i = 0; i < n; i++) {
        delete [] G[i];
        delete [] cost[i];
    }
    delete [] G;
    delete [] cost;
}

int ** readGraph(int n, int m, int *** cost) {
    int ** G = new int* [n];
    *cost = new int* [n];
    for (int i = 0; i < n; i++) {
        G[i] = new int [n];
        (*cost)[i] = new int [n];
    }
    for (int i = 0; i < n; i++) {
        G[i][i] = 0;
        (*cost)[i][i] = 0;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            G[i][j] = inf;
            G[j][i] = inf;
            (*cost)[i][j] = inf;
            (*cost)[j][i] = inf;
        }
    }

    int city1, city2, length, fee;
    for (int i = 0; i < m; i++) {
        cin >> city1 >> city2 >> length >> fee;
        G[city1][city2] = length;
        G[city2][city1] = length;
        (*cost)[city1][city2] = fee;
        (*cost)[city2][city1] = fee;
    }

    return G;
}

```
>7-9-Dijkstra.cpp

```C++
#include <iostream>
#define inf 10000

using namespace std;

int ** readGraph(int n, int m, int *** cost);
void deleteGraph(int ** G, int n, int ** cost);
int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend);

int main(int argc, char const *argv[]) {
    freopen("D:\\SJTU\\Freshman Summer\\DS\\test.txt", "r", stdin);
    int n, m, s, d, ** cost = NULL, fee;
    cin >> n >> m >> s >> d;
    int ** G = readGraph(n,m,&cost);

    int length = Dijkstra(G,n,s,d,cost,&fee);
    cout << length << ' ' << fee;
    deleteGraph(G,n,cost);
    return 0;
}

int Dijkstra(int** G,int n,int s,int d,int** cost,int *spend)
{
    int * dist = new int [n];
    int * fee = new int [n];
    bool * collected = new bool [n];
    for (int i = 0; i < n; i++) {
        dist[i] = inf;
        fee[i] = inf;
        collected[i] = false;
    }
    dist[s] = 0;
    collected[s] = true;

    for (int i = 0; i < n; i++) {
        if(!collected[i] && G[s][i]!=inf) {
            dist[i] = G[s][i];
            fee[i] = cost[s][i];
        }
    }
    int v = -1;
    while (true) {
        int min = inf;
        v = -1;
        for (int i = 0; i < n; i++) {
            if (!collected[i] && dist[i]!=-1 && dist[i]<min) {
                min = dist[i];
                v = i;
            }
        }
        if (v==d || v==-1) break;
        collected[v] = true;

        for (int w = 0; w < n; w++) {
            if(!collected[w] && G[v][w]!=inf) {
                if (dist[v]+G[v][w]<dist[w]) {
                    dist[w] = dist[v] + G[v][w];
                    fee[w] = fee[v] + cost[v][w];
                }else if (dist[v]+G[v][w]==dist[w]) {
                    if (fee[w] > fee[v] + cost[v][w]) {
                        fee[w] = fee[v] + cost[v][w];
                    }
                }
            }
        }
    }

    int ret = dist[v];
    *spend = fee[v];
    delete [] dist;
    delete [] fee;
    delete [] collected;
    return ret;
}

void deleteGraph(int ** G, int n, int ** cost) {
    for (int i = 0; i < n; i++) {
        delete [] G[i];
        delete [] cost[i];
    }
    delete [] G;
    delete [] cost;
}

int ** readGraph(int n, int m, int *** cost) {
    int ** G = new int* [n];
    *cost = new int* [n];
    for (int i = 0; i < n; i++) {
        G[i] = new int [n];
        (*cost)[i] = new int [n];
    }
    for (int i = 0; i < n; i++) {
        G[i][i] = 0;
        (*cost)[i][i] = 0;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            G[i][j] = inf;
            G[j][i] = inf;
            (*cost)[i][j] = inf;
            (*cost)[j][i] = inf;
        }
    }

    int city1, city2, length, fee;
    for (int i = 0; i < m; i++) {
        cin >> city1 >> city2 >> length >> fee;
        G[city1][city2] = length;
        G[city2][city1] = length;
        (*cost)[city1][city2] = fee;
        (*cost)[city2][city1] = fee;
    }

    return G;
}

```
